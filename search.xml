<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网址大全]]></title>
    <url>%2F2099%2F12%2F31%2FME-%E8%A7%84%E8%8C%83%2F%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86%E6%8A%80%E8%83%BD%2F</url>
    <content type="text"><![CDATA[github 笔者github https://github.com/sywsywsyw 灰哥github https://github.com/gxhpersonal 林哥github https://github.com/lin-sun 腾讯 https://github.com/Tencent 博客 笔者博客 https://sxiaobiblog.com 灰哥博客 https://gxhpersonal.github.io/blog 林哥博客 https://lin-sun.github.io/blog 个人主页 亚林 https://lin-sun.github.io 灰爷 https://gxhpersonal.github.io 小笔 https://sxiaobiblog.comperson/ 优秀文档 TGideas腾讯web整体解决方案 http://tguide.qq.com/main/index.htm TGideas腾讯游戏官方设计团队 http://tgideas.qq.com/ 携程设计委员会 http://ued.ctrip.com/blog/ 百度用户体验中心 http://mux.baidu.com/ 项目优化请求测试 http接口测试 http://www.sojson.com/httpRequest/ 图片压缩工具 TinyPng https://tinypng.com/ 智图 http://zhitu.isux.us/ 图好快 http://www.tuhaokuai.com/image 代码美化工具 在线代码美化工具 http://tool.oschina.net/codeformat/js 在线JS/CSS/HTML压缩(采用YUI Compressor实现) http://tool.oschina.net/jscompress CDN BootCDN http://www.bootcdn.cn/? 阿里巴巴矢量图标库 http://www.iconfont.cn/ JQ插件库 http://www.jq22.com/ 常用技术文档 BUNOOB.COM 菜鸟教程 http://www.runoob.com/git/git-tutorial.html MDN https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects w3c 工具库 https://123.w3cschool.cn/webtools 微信 微信公众平台技术文档 https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1445241432 微信小程序文档 https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html?t=201715 微信支付开发文档 https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_4&amp;index=3 微信测试账号申请 http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login 微信公众平台客服登陆 https://mpkf.weixin.qq.com/cgi-bin/kfloginpage WUI 微信UI https://github.com/weui/weui/blob/master/README_cn.md 腾讯微信gitHub https://github.com/Tencent 前端框架 Swiper.js移动端网页触摸插件 http://www.swiper.com.cn/ layui 弹出窗必用 http://layer.layui.com/ Bootstrap 响应式移动端 http://v3.bootcss.com/ 蚂蚁金服体验技术部出品 @ AFX https://ant.design/index-cn WUI 微信UI https://github.com/weui/weui/blob/master/README_cn.md wUI https://weui.io/ Angular2 https://angular.cn/ Materialize 响应式移动端 http://materializecss.com/ create.js H5游戏 http://www.createjs.cc/ 前端插件 ueditor 富文本编辑器 http://ueditor.baidu.com/website/onlinedemo.html Filterizr – jQuery筛选过滤插件 http://www.dowebok.com/211.html fullpage 全屏滚动插件 http://www.dowebok.com/77.html fullpage github https://github.com/alvarotrigo/fullpage.js 阿里云 ICP代备案管理系统 https://beian.aliyun.com/account/login.htm 万网登陆 https://account.aliyun.com/login/login.htm 网易云信 网易聊天室 web文档 http://dev.netease.im/docs/product/IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/%E6%96%B0%E6%89%8B%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97 开源软件 FFmpeg视频处理的开源计算机程序 http://ffmpeg.org/about.html 服务类平台 腾讯优图开放平台 提供人脸识别 http://open.youtu.qq.com/welcome/index Tengine 服务端解决大并发问题 http://tengine.taobao.org/ 腾讯开放平台|众创空间 http://open.qq.com/ PS切图工具 zeplin快速切图工具 https://app.zeplin.io/welcome.html cutterman http://www.cutterman.cn/zh 项目响应兼容性速度检测 GTmetrix https://gtmetrix.com/ WeTest腾讯质量开放平台 - 专注游戏，提升品质 http://wetest.qq.com/user Modernizr：专为HTML5和CSS3开发的功能检测类库 http://blog.csdn.net/pengpegv5yaya/article/details/9906041 学习文档马上开始 精通gulp常用插件 – 前端网(w3cvip) http://www.w3cvip.com/329.html 大前端完整学习路线（详解）前端网(w3cvip) http://www.w3cvip.com/109.html Pro Git http://iissnan.com/progit/ Git https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF git http://blog.zengrong.net/post/1746.html git 廖雪峰 https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 七天学会node.js http://nodejs.meetrue.com/ bower https://bower.io/blog/ 前端自动化 https://github.com/taptapship/wiredep 素材图片图片素材 花瓣网 http://huaban.com/ 视觉中国 http://shijue.me/ 千图网 http://www.58pic.com/yangji/ Pixbay https://pixabay.com/ 站酷 http://www.zcool.com.cn/ 黄蜂网 http://woofeng.cn/ 爱果果 http://www.iguoguo.net/ 炫酷网站设计 相册 http://materliu.github.io/gallery-by-react/ 百度软件管理，全新启程 http://ruanjian.baidu.com/index/index.html QQ浏览器宣传页 http://browser.qq.com/new/9.5.4/welcome.html 【王者荣耀】末日矩阵：装甲危机·第二季！ http://pvp.qq.com/act/a20160816ssx/index.htm moodica https://www.moodica.com/ 会动的小眼睛 http://www.jorgerieraflores.com/ 两只小羊 https://branded7.com/ Fillory 弗拉里 http://www.welcometofillory.com/map FF911 https://www.ff.com/cn/ 双擎STATION http://www.tpark-toyota.com/index.php?id=10&amp;position=4 QQ游戏2.0下载_QQ游戏http://qqgame.qq.com/qqgame2.0_down/index.html 放大镜效果https://www.senxianbao.com/ 腾出空，去生活http://guanjia.qq.com/http/act/201709zmzl/index.html 优秀网站设计 apple 中国 https://www.apple.com/cn/ 网易邮箱6.0 http://mail.163.com/html/ntesmail6/#node=2 软件下载 Adobe Photoshop CC 2017 https://jingyan.baidu.com/article/0bc808fc2de5841bd485b9a9.html 蓝灯(Lantern) 越狱https://github.com/getlantern/forum 酷Q 免费机器人 https://cqp.cc/ zeplin ps标注 https://zeplin.io/ pxcook ps标注 http://www.fancynode.com.cn/pxcook 快速开发工具 h5 http://www.ih5.cn/not-logged-in WeX5 http://www.wex5.com/appstore/ 人人秀 https://www.rrxiu.net/store#/ 暂时不用 java http://how2j.cn/]]></content>
      <categories>
        <category>SPEC</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序使用Taro转H5]]></title>
    <url>%2F2020%2F04%2F07%2F2020Note%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8Taro%E8%BD%ACH5%2F</url>
    <content type="text"><![CDATA[1. 微信小程序转Taro，文档https://nervjs.github.io/taro/docs/taroize.htmlTaro 可以将你的原生微信小程序应用转换为 Taro 代码，进而你可以通过 taro build 的命令将 Taro 代码转换为对应平台的代码，或者对转换后的 Taro 代码用 React 的方式进行二次开发。微信原生小程序转 Taro 的操作非常简单，首先必须安装使用 npm i -g @tarojs/cli 安装 Taro 命令行工具，其次在命令行中定位到小程序项目的根目录，根目录中运行：1$ taro convert 即可完成转换。转换后的代码保存在根目录下的 taroConvert 文件夹下。你需要定位到 taroConvert目录执行 npm install 命令之后就可以使用 taro build 命令编译到对应平台的代码。预览h51npm run dev:h5 ==注意，转换完之后运行会提示.temp文件有好多报错，不要在这个里面改错误，要去src目录下面更改，因为.temp是临时文件夹，因为这个问题折腾了一下午。== 2.遇到的报错2.1 An identifier or keyword cannot immediately follow a numeric literal报错的意思是标识符以数字开头，这是因为js是弱类型的语言当发现第一个数字是就自动转化为数字类型的但是其中还含有字符所以报了错，’报错的原因是因为我们想传的字符串，但是js却当成数字，所以需要给传的参数加引号。1&lt;Text decode="true"&gt;(最多可选择9张,文件大小\'&#123;10&#125;\'M)&lt;/Text&gt; 2.2 npm ERR! Cannot read property ‘match’ of undefined 错误处理https://blog.csdn.net/Jane_96/article/details/81451759?%3E 2.3 转换过程中因为部分页面语法出错，导致转换报错将项目根目录备份一份然后注释掉app.json中其他文件，有针对性的转换当前文件，查看语法报错。修复后执行taro convert将生成的文件拷贝到之前转换出来的目录下。]]></content>
      <categories>
        <category>2020Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript笔记]]></title>
    <url>%2F2020%2F04%2F03%2F2020Note%2FTypeScript%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[typescript 是javascript的超集，是一种编程语言 1. typescript和javascript的区别 更适合大型应用程序 js的超集，类似于less,sass, 最终会转为javascript 跨平台（浏览器，操作系统linux,mac）且开源 开始于js,终止于js.上手成本低，易于学习 重用js,可以引入js流行的库 echarts typescript 类、接口、模块，更易于组件的编写和维护 ts是强类型，js是弱类型。 为什么要学习typescript? vue、React、ng、都推荐使用typescript。 2. 开发环境的安装1234567npm -vnode -vnpm install typescript -gtsc --versionnpm init -y //-y代表全部默认tsc --init // 生成ts配置npm install @type/node --dev-save 新建helloTs.ts12var message:string = 'helloTypeScript';console.log(message); 命令：helloTs.ts转为helloTs.js1tsc helloTs 使用node命令执行helloTs.js12node helloTs.js // helloTypeScript 3. 变量类型弱类型 数据类型可以被忽略的语言。与强类型语言相反, 一个变量可以赋不同数据类型的值,允许将一块内存看做多种类型,比如直接将整型变量与字符变量相加强类型 使之强制数据类型定义的语言。没有强制类型转化前,不允许两种不同类型的变量相互操作。 undefined：undefined类型 number：数值类型 string: 字符串类型 Boolean: 布尔类型 enum：枚举类型 一般用于大写声明， 一个类的对象是有限且固定的,这种情况下我们使用枚举类就比* 较方便 any：任意类型 万能类型、刚开始是数字类型，后来变成了字符串，然后又变成了，true,如果使用any类型就不会报错了。 void: 空类型 Array: 数组类型 Tuple: 元祖类型 Null: 空类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 变量类型 ts属于强类型，声明的时候必须告诉程序，这是个什么类型，js属于弱类型。// undefinedlet undeFined:any;console.log(undeFined);// stringlet stringVariable:string = '我是string variable';console.log(stringVariable);// numberlet numberVariable:number = 8888;console.log(numberVariable);// Booleanlet booleanVariable:Boolean = true;console.log(booleanVariable);// enum 枚举类型，用于一个类的对象是有限且固定的，比如男人，女人，中性人，一般使用大写命名enum PEOPLE&#123;man='男人',woman='女人',genderBender='中性人'&#125;;console.log(PEOPLE.man);// any 任意类型 我们js习惯了弱类型语言，这个类型就是允许你随意改变变量的类型let anyVariable:any = 888;anyVariable = true;anyVariable = 'anyVariable从数字888变为布尔true最后变成了字符串类型,';console.log(anyVariable);// Arraylet arrayVariable = [1,2,3,4,5];console.log(arrayVariable);// null let nullVariable = null;console.log(nullVariable);// undefined// 我是string variable// 8888// true// 男人// anyVariable从数字888变为布尔true最后变成了字// 符串类型,// [ 1, 2, 3, 4, 5 ]// null 4. 函数形参：函数方法中声明的参数实参：函数调用时候传递进去的值 定义一个函数1234567// 定义函数function searchSmallSister(age:number):string&#123; return 'sxiaobi找了一个'+age+'岁的小姐姐'&#125;let result:string = searchSmallSister(28);console.log(result,'我是基本定义函数 parasm:number');// sxiaobi找了一个28岁的小姐姐 我是基本定义函数 parasm:number 有可选参数的函数params?:string1234567// 可选参数的函数function searchSmallGirl(age:number,stature?:number):string&#123; return 'sxiaobi找了一个' + age + '岁' + stature+'cm的小姐姐'&#125;let girlResult:string = searchSmallGirl(20,178);console.log(girlResult,'我是可选参数身高 params?:number的小姐姐');// sxiaobi找了一个20岁178cm的小姐姐 我是可选参数身高 params?:number的小姐姐 有默认值的函数params:string=’小姐姐’123456function searchYoungLaday(age: number = 20, stature: number = 170,thorax:string='34D'):string&#123; return `sxiaobi找了一个$&#123;age&#125;岁$&#123;stature&#125;cm$&#123;thorax&#125;的小姐姐`;&#125;let youngLaday:string = searchYoungLaday();console.log(youngLaday,'我是默认参数 params:string="34D"的小姐姐');// sxiaobi找了一个20岁170cm34D的小姐姐 我是默认参数 params:string="34D"的小姐姐 有剩余参数的函数…params:string[]123456789101112131415// 有剩余参数的函数function searchSmallWoman(...age:string[]):string&#123; let yy:string = '找了一个'; for(let index in age)&#123; let indexT: any = index; yy = yy + age[indexT]; if ( indexT &lt; age.length-1)&#123; yy = yy+ '、'; &#125; &#125; return `sxiaobi$&#123;yy&#125;的小姐姐`;&#125;let smallWoman:string = searchSmallWoman('20岁','175cm','34D','上海陆家嘴');console.log(smallWoman,'我是有剩余参数的 ...params:string[]')// sxiaobi找了一个20岁、175cm、34D、上海陆家嘴的小姐姐 我是有剩余参数的 ...params:string[] 三种函数的定义方法函数声明法1234function add(one: number, two: number): number &#123; return one + two;&#125;console.log(add(1, 2)); 函数表达式法1234var plus = function (one: number, two: number): number &#123; return one + two;&#125;console.log(plus(1, 2)); 箭头函数1234var sum = (one: number, two: number): number =&gt; &#123; return one + two;&#125;console.log(sum(1, 2)); 5. 引用类型 Array String Date RegExp数组123456789// 数组// 字面量赋值法let arr1:number[] = [1,2,3];let arr2:Array&lt;string&gt; = ['a','b','c'];// 构造函数赋值法 newlet arr3:number[] = new Array(1,2,3,4);console.log(arr1,arr2,arr3);// [ 1, 2, 3 ] [ 'a', 'b', 'c' ] [ 1, 2, 3, 4 ] 字符串12345// 字符串let string1:string = 'sxiaobi';let string2:String = new String('sxiaobi');console.log(string1, string2);// sxiaobi [String: 'sxiaobi'] #####12345678// 日期// 不传递参数let date:Date = new Date();// 传递一个数字let dateNumber:Date = new Date(1000);let dateString:Date = new Date('2019/09/07 05:06:30');console.log(date, dateNumber, dateString);// 2020-04-09T09:41:10.681Z 1970-01-01T00:00:01.000Z 2019-09-06T21:06:30.000Z 6. 面向对象编程6.1 类 // TypeScript 是基于类的面向对象的编程语言 类是对象具体事务的一个抽象，对象是类的具体表现。123456789101112131415var testClass = /** @class */ (function () &#123; function testClass(name, age) &#123; this.name = name; this.age = age; &#125; testClass.prototype.findSister = function () &#123; console.log('找到ywf小姐姐'); &#125;; return testClass;&#125;());var jiejie = new testClass('范冰冰', 18);console.log(jiejie);jiejie.findSister();x// testClass &#123; name: '范冰冰', age: 18 &#125;// 找到ywf小姐姐 我们先用class关键字声明了一个类，并在里边声明了name和age属性。constructor为构造函数。构造函数的主要作用是给类中封装的属性进行赋值。 使用和定义类其实很简单，关键是理解类的思想。要有抽象逻辑的能力，这样才能复用和增强维护性。 6.2 修饰符 public 默认修饰符 公用修饰符 protected 受保护的修饰符 可以在本类和子类中使用 private 私有修饰符 在类内 readonly 只读修饰符 123456789101112131415161718192021222324class final&#123; public sex:string protected name:string private age:number public constrcutor(sex:string,name:string,age:number)&#123; this.sex = sex; this.name = name; this.age = age; &#125; public sayHellow()&#123; console.log('小姐姐对你说：你好'); &#125; protected sayLove()&#123; console.log('小姐姐对你说：我爱你') &#125;&#125;let finalStr:final = new final('女','ywf',28);console.log(finalStr.sex);console.log(finalStr.name);console.log(finalStr.age);finalStr.sayHellow();finalStr.sayLove(); 123456789101112final.ts:23:32 - error TS2554: Expected 0 arguments, but got 3.23 let finalStr:final = new final('女','ywf',28); ~~~~~~~~~~~~final.ts:25:22 - error TS2445: Property 'name' is protected and only accessible within class 'final' and its subclasses.25 console.log(finalStr.name); ~~~~final.ts:26:22 - error TS2341: Property 'age' is private and only accessible within class 'final'.26 console.log(finalStr.age); ~~~final.ts:28:10 - error TS2445: Property 'sayLove' is protected and only accessible within class 'final' and its subclasses.28 finalStr.sayLove(); ~~~~~~~ 123456class Man &#123; public readonly sex: string = '男'&#125;var man: Man = new Man()man.sex = '女' 1234final.ts:36:5 - error TS2540: Cannot assign to 'sex' because it is a read-only property.36 man.sex = '女' ~~~Found 5 errors. 6.3 Class继承和重写== js继承只支持单重继承 ==123456789101112131415161718192021222324252627282930313233343536373839404142class parentClass&#123; public name:string public age:number public skill:string constructor(name: string, age: number,skill:string)&#123; this.name = name; this.age = age; this.skill = skill; &#125; public interest()&#123; console.log('父类的方法') &#125;&#125;let parentObj:parentClass = new parentClass('子小',20,'web');parentObj.interest();class childrenClass extends parentClass&#123; public childrenName:string; public childrenAge:number; public childrenSkill:string; constructor(childrenName: string, childrenAge: number, childrenSkill:string)&#123; super('子小', 20, 'web'); this.childrenName = childrenName; this.childrenAge = childrenAge; this.childrenSkill = childrenSkill; &#125; public interest()&#123; super.interest(); console.log('子类从写了父类的方法') &#125; public loveGril()&#123; console.log('子类泡妞') &#125;&#125;let chilrenObj:childrenClass = new childrenClass('小子',12,'泡妞');chilrenObj.loveGril();chilrenObj.interest();// 父类的方法// 子类泡妞// 父类的方法// 子类从写了父类的方法 6.4 接口 interface 定义接口 1234567interface GirlRequest&#123; sex:string skill:string&#125;let myGirl:GirlRequest = &#123;sex:'女',skill:'爱我'&#125;;console.log(myGirl);// &#123; sex: '女', skill: '爱我' &#125; 可选参数的接口 12345interface GirlRequest&#123; sex:string skill:string beautiful?:boolean // 可选参数&#125; 规范函数类型的接口 123456789interface SearchMan&#123; (source:string,subString:string):boolean&#125;let mySearch: SearchMan = function (source: string, subString: string): boolean&#123; let flag = source.search(subString); return flag != -1;&#125;console.log(mySearch('高、富、帅、德', '胖'))// false 6.5 命名空间 namespace在制作大型应用的时候，为了让程序更加有层次感和变量之间不互相干扰，我们可以使用命名空间来构建程序。举个小例子：比如“德华”这件事，帅哥也有叫德华的，二师兄也有叫德华的。那我们要如何区分那。这对于女孩子选老公来说非常重要啊。当然命名空间就是解决这个问题的，命名空间，又称内部模块，被用于组织有些具有内在联系的特性和对象。我们来看一个例子：123456789101112131415161718192021222324namespace shuaiGe&#123; export class Dehua&#123; public name:string = '刘德华' talk()&#123; console.log('我是帅哥刘德华') &#125; &#125;&#125;namespace bajie&#123; export class Dehua&#123; public name:string = '马德华' talk()&#123; console.log('我是二师兄马德华') &#125; &#125;&#125;let dehua1:shuaiGe.Dehua = new shuaiGe.Dehua()let dehua2:shuaiGe.Dehua = new bajie.Dehua()dehua1.talk()dehua2.talk()// 我是帅哥刘德华// 我是二师兄马德华 通过命名空间我们很好的把程序变的清晰了，各位小姐姐也再也不会刘德华和马德华傻傻分不清了。]]></content>
      <categories>
        <category>2020Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具-VScode使用]]></title>
    <url>%2F2020%2F04%2F03%2FME-%E5%B7%A5%E5%85%B7%2F%E5%B7%A5%E5%85%B7-VScode%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[因为电脑垃圾、atom编辑器在处理长页面是的卡顿迫使我不得不更换一门编辑器，但不可否认的是每个编辑器都是很强大好用的。 安装https://code.visualstudio.com/ 快捷命令ctrl + shift + p 打开命令行 插件安装Vscode web 常用插件 中文安装https://code.visualstudio.com/ 快捷命令ctrl + shift + p 打开命令行 复制前面的英文插件名 别复制后面的汉语1. Chinese (Simplified) Language Pack for Visual Studio Code 适用于 VS Code 的中文（简体）语言包 2. Prettier - Code formatter 漂亮的格式化工具3. Auto Rename Tag 自动重命名标签4. vscode-icons 文件图标5. Project Manager 项目管理 ctrl+p 打开命令面板 输入 Project 6. Beautify 自动美化代码7. HTML CSS Support css样式补全 8. Material Icon Theme 图标主题扩展包9. npm npm10. npm Intellisense 命令代码补全 Visual Studio代码插件，它自动完成导入语句中的NPM模块。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-rWfAzbVe-1585709300744)(https://github.com/ChristianKohler/NpmIntellisense/raw/master/images/auto_complete.gif)] 11. IntelliSense for CSS class names in HTML HTML中CSS类名的智能感知 12. Path Intellisense 路径补全VisualStudio代码插件，自动完成文件名。 13. Vetur vue语法错误检查，包括 CSS/SCSS/LESS/Javascript/TypeScript语法高亮，包括 html/jade/pug css/sass/scss/less/stylus js/tsemmet 支持代码自动补全（目前还是初级阶段），包括 HTML/CSS/SCSS/LESS/JavaScript/TypeScript 14. Vue 2 Snippets vue2代码提示 15. Guides 导轨 代码对齐标线 16. Bracket Pair Colorizer 括号对色器 此扩展允许匹配的括号与颜色识别。用户可以定义要匹配的字符和要使用的颜色。 17. vscode-fileheader 自动添加文件头部描述信息 基本配置： 打开 文件-&gt;首选项-&gt;设置-&gt;用户设置-&gt;搜索fileheader更改里面的信息基本使用： ctrl+alt+i 18 https://blog.csdn.net/shenxianhui1995/article/details/81604818]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[驾照考试]]></title>
    <url>%2F2020%2F04%2F03%2FME-%E4%B8%AA%E4%BA%BA%2F%E5%85%A5%E4%B8%96-%E9%A9%BE%E7%85%A7%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[遵纪守规，人人有责。 驾校学习 哪边宽哪边打方向盘 直线行驶， 雨刷器中心与右侧线条相交，说明笔直行驶。 侧方倒车 看见直角到车中部右一圈， 然后看左侧后视镜第二条虚线不压线（实线压线）， 轮胎位于第二条线头部左打满（一圈半）， 头看前轮进入线，停车离合器踩死，刹车。 （一档挂好才能松刹车） 看车头中部与最左侧线相交回正（左打满一圈半的回正）， 看最左侧线和左车窗相交1/3（一般人一半）右一圈， 看雨刷器中心与右边线相交回正（右一圈的回正。） S弯道（曲线行驶） 雨刷器与右侧车线相交保持直线行驶， 车头中部与右侧车线相交左打一圈， 出头看左侧后轮胎适当调整（合适则不做调整）， 看车头左中部与左线相交多一点点回正（回正左一圈）， 看车头右中部与左线相交右打一圈， 雨刷器与右侧车线相交回正（回正右一圈）保持直线行驶， 开启左转向灯， 看左侧车线直角位于车窗1/3（把手多一丢丢）左打满，关闭转向灯， 看车窗与左侧车线平行迅速回正（回正左一圈） 直角转弯 开左灯直线行驶， 车窗与左车线平行，左车线直角位于左侧车门把手 左打满， 看左后视镜，左侧车门与左车线平行迅速回正 考试科目 科目一 道路交通安全法律、法规和相关知识考试 科目二 场地驾驶技能考试 科目三 道路驾驶技能 科目四 安全文明驾驶常识考试 常见口语 假一吊二撤三醉五逃终生。 没有中心线 城3公4对向行驶双车道 城5公7同向双车道 城6公9 一次超车 两次转向 实车操作 方向盘双手平行握住，大拇指不允许扣进方向盘 起步时离合器重踏缓抬，不允许随意踩踏 疑难问题 驾本等级 字母越靠近 A 准驾车型越多 字母相同 判断数字 数字越小 准驾车型越大 在没有中心线的道路行驶，城市最高30km/h,公路最高40km/h 雾天行车为了提高能见度应该开启雾灯、尾灯、轮廓灯、前照灯（近灯）但是不能开启远光灯 交通肇事致一人以上重伤，负事故全部责任或主要责任，并具有酒后、无证驾驶、严重超载等情形之一的，以交通肇事罪处罚。 离合踏板是手动挡汽车离合器总成的操作装置，影响起步、换挡和倒车。 制动踏板又称刹车，减速停车使用。 考试知识 车管所考试，前40道选择60道判断。]]></content>
      <categories>
        <category>L78Z</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue百度地图使用默认信息框，默认标注]]></title>
    <url>%2F2020%2F04%2F03%2F2020Note%2Fvue%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E4%BF%A1%E6%81%AF%E6%A1%86%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%A0%87%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[项目需求：点击marker会默认弹出一个窗口，我想不点击直接弹出，怎么搞？企业联系我们地址，百度地图页面一打开默认显示标注提示框如图 1. 首先去出vue项目本身引入的vue Baidu Map 的插件2. 在vue-cli 根目录项目中 public&gt;index.html引入百度地图插件123456&lt;!-- 百度地图 --&gt;&lt;script type="text/javascript" src="https://api.map.baidu.com/api?v=3.0&amp;ak=你的百度地图密钥"&gt;&lt;/script&gt;&lt;!-- 百度地图搜索插件js --&gt;&lt;script type="text/javascript" src="//api.map.baidu.com/library/SearchInfoWindow/1.5/src/SearchInfoWindow_min.js"&gt;&lt;/script&gt;&lt;!-- 百度地图搜索插件css --&gt;&lt;link rel="stylesheet" href="//api.map.baidu.com/library/SearchInfoWindow/1.5/src/SearchInfoWindow_min.css" /&gt; 3. 页面中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!-- --&gt;&lt;template&gt; &lt;section class=""&gt; &lt;div class="bdcontainer" id="container" style="width:100%;height:100%;" &gt;&lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;//这里可以导入其他文件（比如：组件，工具js，第三方插件js，json文件，图片文件等等）//例如：import 《组件名称》 from '《组件路径》';export default &#123; //import引入的组件需要注入到对象中才能使用 components: &#123;&#125;, data() &#123; //这里存放数据 return &#123; realcenter: &#123; lng: 121.56887, lat: 31.164583 &#125; // 地图坐标 &#125;; &#125;, //监听属性 类似于data概念 computed: &#123;&#125;, //监控data中的数据变化 watch: &#123;&#125;, //方法集合 methods: &#123; baiduMap() &#123; let map = new BMap.Map("container"); //创建地图实例 let point = new BMap.Point(this.realcenter.lng, this.realcenter.lat); //创建点坐标 map.centerAndZoom(point, 17); // 初始化地图，设置中心点坐标和地图级别 map.enableScrollWheelZoom(true); // 滚轮缩放 let marker = new BMap.Marker(point); // 创建标注 点 // map.addOverlay(marker); // 将标注添加到地图中 // map.addControl(new BMap.NavigationControl(BMAP_ANCHOR_TOP_LEFT)); //控件左上角 //信息窗口内容 let sscontent = '&lt;div style="font-size: 12px; padding: 5px 0px; overflow: hidden;"&gt;&lt;div class="panoInfoBox" id="panoInfoBox" title="BHC中环中心外景"&gt;&lt;img filter="pano_thumnail_img" class="pano_thumnail_img" width="323" height="101" border="0" alt="BHC中环中心外景" src="https://gss0.bdstatic.com/5LUZemba_QUU8t7mm9GUKT-xh_/pr/?qt=poiprv&amp;amp;uid=a797d5e32f8007a9a80dd8ee&amp;amp;width=323&amp;amp;height=101&amp;amp;quality=80&amp;amp;fovx=200" id="pano_a797d5e32f8007a9a80dd8ee"&gt;&lt;div filter="panoInfoBoxTitleBg" class="panoInfoBoxTitleBg"&gt;&lt;/div&gt;&lt;a href="javascript:void(0)" filter="panoInfoBoxTitleContent" class="panoInfoBoxTitleContent"&gt;进入全景&amp;gt;&amp;gt;&lt;/a&gt;&lt;/div&gt;&lt;p style="padding: 0px; margin: 0px; line-height: 18px; font-size: 12px; color: rgb(77, 77, 77);"&gt;地址：沪南路2218号&lt;/p&gt;&lt;p style="padding: 0px; margin: 0px; line-height: 18px; font-size: 12px; color: rgb(127, 127, 127);"&gt;标签：房地产 写字楼&lt;/p&gt;&lt;/div&gt;'; // 这的内容需要你自己F12调试打开你想要的那个提示框，拿出来信息 let ssinfoOptions = &#123; title: '&lt;div class="BMap_bubble_title" style="margin:0 -5px;background:#fff;padding: 0 5px;overflow: hidden; height: auto; line-height: 30px; white-space: nowrap; width: auto;"&gt;&lt;div style="height:26px;" id="detailDiv"&gt;&lt;a filter="detailInfo" href="http://api.map.baidu.com/place/detail?uid=a797d5e32f8007a9a80dd8ee&amp;amp;output=html&amp;amp;source=jsapi&amp;amp;operate=mapclick&amp;amp;clicktype=tile" target="_blank" style="font-size:14px;color:#4d4d4d;font-weight:bold;text-decoration:none;" onmouseover="this.style.textDecoration=&amp;quot;underline&amp;quot;;this.style.color=&amp;quot;#3d6dcc&amp;quot;" onmouseout="this.style.textDecoration=&amp;quot;none&amp;quot;;this.style.color=&amp;quot;#4d4d4d&amp;quot;"&gt;BHC中环中心&lt;/a&gt;&lt;a filter="detailLink" href="http://api.map.baidu.com/place/detail?uid=a797d5e32f8007a9a80dd8ee&amp;amp;output=html&amp;amp;source=jsapi&amp;amp;operate=mapclick&amp;amp;clicktype=tile" target="_blank" style="font-size:12px;color:#3d6dcc;margin-left:5px;text-decoration:none;" onmouseover="this.style.textDecoration=&amp;quot;underline&amp;quot;" onmouseout="this.style.textDecoration=&amp;quot;none&amp;quot;"&gt;详情»&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;', //标题 width: 322, //宽度 height: 150, //高度 panel: "panel", //检索结果面板 offset: &#123; width: 0, height: -25 &#125;, enableAutoPan: true, //自动平移 enableSendToPhone: false, // 是否在信息显示短信发送按钮 searchTypes: [ BMAPLIB_TAB_TO_HERE, //到这里去 BMAPLIB_TAB_FROM_HERE, //从这里出发 BMAPLIB_TAB_SEARCH //周边检索 ] &#125;; // var infoWindow = new BMap.InfoWindow(content, infoOptions); // 创建信息窗口对象 // map.openInfoWindow(infoWindow, point); // 打开信息窗口 // //点击红点弹出信息窗口 // marker.addEventListener("click", function(e)&#123; // map.openInfoWindow(infoWindow, point); // 打开信息窗口 // &#125;) var searchInfoWindow = new BMapLib.SearchInfoWindow( map, sscontent, ssinfoOptions ); // 创建带搜索得信息窗口对象 searchInfoWindow.open(marker); // 打开带搜索得信息窗口 map.addEventListener("click", function(e) &#123; searchInfoWindow.hide(marker); &#125;); //点击红点弹出信息窗口 marker.addEventListener("click", function(e) &#123; setTimeout(() =&gt; &#123; searchInfoWindow.open(marker); &#125;, 100); &#125;); &#125; &#125;, //生命周期 - 创建完成（可以访问当前this实例） created() &#123;&#125;, //生命周期 - 挂载完成（可以访问DOM元素） mounted() &#123; this.baiduMap(); &#125;, beforeCreate() &#123;&#125;, //生命周期 - 创建之前 beforeMount() &#123;&#125;, //生命周期 - 挂载之前 beforeUpdate() &#123;&#125;, //生命周期 - 更新之前 updated() &#123;&#125;, //生命周期 - 更新之后 beforeDestroy() &#123;&#125;, //生命周期 - 销毁之前 destroyed() &#123;&#125;, //生命周期 - 销毁完成 activated() &#123;&#125;, //如果页面有keep-alive缓存功能，这个函数会触发 deactivated() &#123;&#125; //keep-alive缓存离开之后触发&#125;;&lt;/script&gt;&lt;style lang="less" scoped&gt;//@import url(); 引入公共css类&lt;/style&gt; 成品]]></content>
      <categories>
        <category>2020Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuecli3项目prerender-spa-plugin预渲染]]></title>
    <url>%2F2020%2F04%2F03%2F2020Note%2Fvuecli3%E9%A1%B9%E7%9B%AEprerender-spa-plugin%E9%A2%84%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[==页面预渲染只支持静态内容较多的页面、如果接口多的页面建议使用ssr服务器渲染，例如nuxt== 安装1npm install prerender-spa-plugin --save vue.config.js1234567891011121314151617181920212223242526272829303132// 预渲染配置：在webpack.prod.conf文件中加入const PrerenderSPAPlugin = require('prerender-spa-plugin')const Renderer = PrerenderSPAPlugin.PuppeteerRendererconst path = require("path");module.exports = &#123; configureWebpack: config =&gt; &#123; config.plugins.push( new PrerenderSPAPlugin(&#123; staticDir: path.join(__dirname, './dist'), // 需要进行预渲染的路由路径 我这里做的是首页 routes: ['/', '/aboutview', '/adHome', '/finaHome', '/lawHome', '/capitalHome', '/payFaceSwip', '/payEwm', '/payPos', '/paySweepEwm', '/payCashier','/payCustom'], // html文件压缩 minify: &#123; minifyCSS: true, // css压缩 removeComments: true // 移除注释 &#125;, renderer: new Renderer(&#123; // Optional - The name of the property to add to the window object with the contents of `inject`. injectProperty: '__PRERENDER_INJECTED', // Optional - Any values you'd like your app to have access to via `window.injectProperty`. inject: &#123;&#125;, // 在 main.js 中 new Vue(&#123; mounted () &#123;document.dispatchEvent(new Event('render-event'))&#125;&#125;)，两者的事件名称要对应上。 // renderAfterDocumentEvent: 'render-event' renderer: new PrerenderSPAPlugin.PuppeteerRenderer(&#123;//这样写renderAfterTime生效了 renderAfterTime: 5000 &#125;) &#125;) &#125;) ) &#125;&#125; main.js123456789new Vue(&#123; router, store, render: h =&gt; h(App), // 添加mounted，不然不会执行预编译 mounted() &#123; document.dispatchEvent(new Event('render-event')) &#125;,&#125;).$mount('#app') 参考文档https://blog.csdn.net/u012878818/article/details/90751461https://www.jianshu.com/p/2b0e4754bb07https://www.jianshu.com/p/8cc2f8ed5efdhttps://yehuzi.com/vue-cli-3-0-shi-yong-prerender-spa-plugin-yu-xuan-ran-yu-dao-de-mo-ming-qi-miao-de-keng/https://www.jianshu.com/p/8f82459895c9]]></content>
      <categories>
        <category>2020Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uni-app的使用]]></title>
    <url>%2F2020%2F04%2F03%2F2020Note%2Funi-app%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装https://www.dcloud.io/ 开始介绍 问题：无法运行到微信开发者工具 点击微信开发者工具的设置-&gt;安全-&gt;服务端口设置为开启 问题：怎么把现有项目迁移为uni-app项目 https://uniapp.dcloud.io/translatevue h5项目转换uni-app指南：https://ask.dcloud.net.cn/article/36174微信小程序转换uni-app指南及转换器：https://ask.dcloud.net.cn/article/35786wepy转uni-app转换器：https://github.com/zhangdaren/wepy-to-uniappmpvue 项目（组件）迁移指南、示例及资源汇总： https://ask.dcloud.net.cn/article/34945 问题：注册全局组件 在mian.js12345678910// 引入全局head导航组件import publicHead from './pages/public/Head.vue';let objHead = Vue.component('objhead',publicHead);const app = new Vue(&#123; ...App&#125;)app.$mount()// 追加全局组件document.body.appendChild(new objHead().$mount().$el); 问题：怎么安装npm https://uniapp.dcloud.io/frame?id=npm%e6%94%af%e6%8c%81]]></content>
      <categories>
        <category>2020Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记]]></title>
    <url>%2F2020%2F04%2F03%2F2020Note%2FES6%2F</url>
    <content type="text"><![CDATA[1. var、const、let的区别 var 全局变量 let 局部变量 const 常量 一般用于属性名，用于从常量命名开始的那一刻就不想让改变的属性名。 2. 变量的解构赋值 数组解构 左右两边需要解构相同 123456let [a,b,c] = [1,2,3];console.log(a,b,c)// 1,2,3let [a,[b,c],d]=[1,2,4];console.log(a,b,c,d)// 报错 Uncaught TypeError: [1,2,4] is not iterable at &lt;anonymous&gt;:1:17 默认赋值的写法 123let [a=2,b=3,c=5] = [1];console.log(a,b,c)// 1,3,5 对象解构 根据属性名进行解构 123let &#123;a,b,c&#125; = &#123;a:'sxiaobi',b:25&#125;;console.log(a,b,c)// sxiaobi 25 undefined 默认赋值写法 123let &#123;a,b,c=10&#125; = &#123;a:'sxiaobi',b:25&#125;;console.log(a,b,c)// sxiaobi 25 10 如果变量先声明，再赋值需要使用()包裹起来 12345678910// success let aa;(&#123;aa&#125; = &#123;aa:11&#125;);console.log(aa)// 11// errorlet aa;&#123;aa&#125; = &#123;aa:11&#125;;console.log(aa)// Uncaught SyntaxError: Unexpected token = 字符串解构 123let [a,b,c,d,e,f,g] = 'sxiaobi';console.log(a,b,c,d,e,f,g)// s x i a o b i 何时用单引号，何时用双引号??？虽然在JavaScript当中，双引号和单引号都可以表示字符串, 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号 3. 字符串 字符串模板 ${txt}1234let tt = 123;let aa = `sxiaobi$&#123;tt&#125;`;console.log(aa);// sxiaobi123 支持嵌套html标签、支持简单运算 字符串查找 includesOf 123456let findStr = 'sx';let string = 'sxiaobi'console.log(string.includes(findStr))// true// es5console.log(string.indexOf(findStr)&gt;-1) 查找字符串首 有没有 startsWith 1234let findStr = 'sx';let string = 'sxiaobi'console.log(string.startsWith(findStr))// true 判断字符串尾部是否存在 endsWith 1234let findStr = 'bi';let string = 'sxiaobi'console.log(string.endsWith(findStr))// true 字符串复制 `repeat 1234let str = '1';let strRepeat = str.repeat(5);console.log(strRepeat);// 11111 4. 扩展运算符与剩余运算符 可以很好的为我们解决参数和对象数组未知情况下的编程 扩展运算符号 ...1234567function sxiaobi(...arg)&#123; console.log(arg[0]) console.log(arg[1]) console.log(arg[2])&#125;sxiaobi(1,2,3)// 1,2,3 扩展运算符的用处：我们先用一个例子说明，我们声明两个数组arr1和arr2，然后我们把arr1赋值给arr2，然后我们改变arr2的值，你会发现arr1的值也改变了，因为我们这是对内存堆栈的引用，而不是真正的赋值。12345let arr1 = [1,2,3];let arr2 = arr1;arr2.push(4)console.log(arr1)// 1,2,3,4 12345let arr1 = [1,2,3];let arr2 = [...arr1];arr2.push(4)console.log(arr1)// 1,2,3 rest运算符 12345function sxiaobi(first,...arg)&#123; console.log(arg.length);&#125;sxiaobi(0,1,2,3,4,5,6,7);// 1,2,3,4,5,6,7 5. 数字的操作 判断是否是NaN isNaN 1234console.log(Number.isNaN(1))// falseconsole.log(Number.isNaN(NaN))// true 判断是否是整数 isInteger 123456console.log(Number.isInteger('a')) // falseconsole.log(Number.isInteger(1.1))// falseconsole.log(Number.isInteger(1))// true 整数转换 parseInt 和 浮点型转换 parseFloat 12345let a='9.18';console.log(Number.parseInt(a)); console.log(Number.parseFloat(a));// 9// 9.18 整数取值范围 2的53次方 123let a = Math.pow(2,53)-1;console.log(a)// 9007199254740991 最大安全整数 MAX_SAFE_INTEGER 12console.log(Number.MAX_SAFE_INTEGER)// 9007199254740991 最小安全整数 MIN_SAFE_INTEGE 12console.log(Number.MIN_SAFE_INTEGER)// -9007199254740991 安全整数判断 isSafeInteger( ) 12console.log(Number.isSafeInteger(11110))// true 6. 数组的方法 Array.from() JOSN对象转数组 12345678let obj = &#123; '0':'sun', '1':'xiao', '2':'bi', length:3&#125;console.log(Array.from(obj))// ['sun','xiao','bi'] Array.of() 类数组对象转为数据，支持数字、字符串 12345console.log(Array.of(1,2,3,4))// [1,2,3,4]let str = 'sun,xiao,bi';console.log(Array.of(str));// ['sun','xiao','bi'] 实例方法 arr.find() 从数组中查找一个值 123456// 查找一个大于2的值let arr = [1,2,3];console.log(arr.find((val,startIndex,endIndex)=&gt;&#123; return val&gt;2;&#125;))// 3 for of 循环数组 12345678910111213141516171819202122232425262728// 常规写法let arr = [1,2,3,4];for(let val of arr)&#123; console.log(val)&#125;// 1 2 3 4// 获取下标let arr = [1,2,3,4];for(let val of arr.keys())&#123; console.log(val)&#125;// 0 1 2 3// 同时输出内容和下标let arr = [1,2,3,4];for(let [index,val] of arr.entries())&#123; console.log(index,val)&#125;// 0 1 、1 2 、2 3 、3 4// 一般直接使用`for in`,`forEach`let arr = [1,2,3,4];arr.forEach((index,val)=&gt;&#123; console.log(index,val)&#125;)let arr = [1,2,3,4];for(let i in arr)&#123; console.log(i,arr[i]) // 这的i的类型是字符串&#125; 数组的去重==filter - 无法识别NaN== 123var arr=[1,2,1,'1',null,null,undefined,undefined,NaN,NaN]var arr2 = arr.filter((x,index,self)=&gt;self.indexOf(x)===index);console.log(arr2) // [1, 2, "1", null, undefined] 12345var arr=[1,2,1,'1',null,null,undefined,undefined,NaN,NaN]var res=Array.from(new Set(arr));//&#123;1,2,"1",null,undefined,NaN&#125;console.log(res) // [1, 2, "1", null, undefined,NaN]var newarr=[...new Set(arr)]console.log(newarr) // [1, 2, "1", null, undefined,NaN] 数组对象的去重 reduce reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce() 可以作为一个高阶函数，用于函数的 compose。注意: reduce() 对于空数组是不会执行回调函数的。 1234567891011121314let person = [ &#123;id: 0, name: "小明"&#125;, &#123;id: 1, name: "小张"&#125;, &#123;id: 2, name: "小李"&#125;, &#123;id: 3, name: "小孙"&#125;, &#123;id: 1, name: "小周"&#125;, &#123;id: 2, name: "小陈"&#125;, ];let obj = &#123;&#125;;let peon = person.reduce((cur,next)=&gt;&#123; obj[next.id]? "":obj[next.id] = true&amp;&amp; cur.push(next); return cur;&#125;,[]) // 设置cur的默认类型为初始值空的数组console.log(peon) 7. 箭头函数和扩展 默认值 12345function add(a,b=1)&#123; return a+b; &#125;add(1)// 2 主动抛出异常 throw new Error() 12345678910function add(a,b=1)&#123; if( a == 1)&#123; throw new Error('主动抛出了异常错误') &#125; return a+b; &#125;add(1)// Uncaught Error: 主动抛出了异常错误// at add (&lt;anonymous&gt;:3:14)// at &lt;anonymous&gt;:7:1 严格模式可以在函数体内使用 use strict es5 中严格模式必须声明在页面头部 123456function add(a,b)&#123; `use strict` return a+b;&#125;console.log(add(1,2));// 3 箭头函数 ()=&gt;{} 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象)严格模式下 this 指向 undefined一般 全局下 指向 window对象的方法中调用指向 调用该方法的对象构造函数里的this 指向创建出来的实例 改变this指向的方法call， call(thisScope, arg1, arg2, arg3…) 传入多个参数 立即执行apply， apply(thisScope,[arg1,arg2,arg3]) 传入一个数组 立即执行bind， bind(thisScope,arg1,arg2,arg3) 返回一个函数，需要自己执行 123add = (a,b) =&gt; a+b;add(1,2)// 3 8. ES6中的函数解构和数组补漏 函数对象解构 123456789let obj = &#123; name:'sxiaobi', age: 26&#125;function jg(&#123;name,age&#125;)&#123; console.log(name,age)&#125;// 'sxiaobi' 26jg(obj) 函数数组解构 123456let arr = [1,2,3];function jg(a,b,c)&#123; console.log(a,b,c)&#125;// 1 2 3jg(...arr) in的用法 判断对象或者数组是否有某个值 123456let obj = &#123; name:'sxiaobi', age: 26&#125;console.log('name' in obj) // true 数组的遍历方法 forEach1234let arr = ['sxiaobi','男','中国'];arr.forEach((val,index)=&gt;&#123; console.log(index,val)&#125;) map1234let arr = ['sxiaobi','男','中国'];arr.map((val,index)=&gt;&#123; console.log(index,val)&#125;) filter 数组过滤 循环1234let arr = ['sxiaobi','男','中国'];arr.filter((val,index)=&gt;&#123; console.log(index,val)&#125;) 判断数组是否存在某个值，存在返回当前值，不存在返回空数组12345var newarr = [ &#123; num: 1, val: 'ceshi', flag: 'aa' &#125;, &#123; num: 2, val: 'ceshi2', flag: 'aa2' &#125;]console.log(newarr.filter(item=&gt;item.num===1)) 去除空、undefined、null12var newArr = [1,2,3,4,null,'',undefined,5,6,7,8];console.log(newArr.filter(item=&gt;item)); // [1, 2, 3, 4, 5, 6, 7, 8] 去除不符合规则的数据12var newArr = [1,2,3,4,5,6];console.log(newArr.filter(item=&gt;item&lt;4)); // [1,2,3] some1234let arr = ['sxiaobi','男','中国'];arr.some((val,index)=&gt;&#123; console.log(index,val)&#125;) for of1234let arr = ['sxiaobi','男','中国'];for( let [index,val] of arr.entries())&#123; console.log(index,val)&#125; for in12345let arr = ['sxiaobi','男','中国'];for( let index in arr)&#123; console.log(index) console.log(arr[index])&#125; for 循环12345let arr = ['sxiaobi','男','中国'];for( let i=0;i&lt;arr.length;i++)&#123; console.log(i) console.log(arr[i])&#125; 9. ES6中的对象 key值的使用，用于对象未知键名处理 123456let keyName = "name";let obj = &#123; [key]:'sxiaobi'&#125;console.log(obj)// &#123; name:'sxiaobi'&#125; Object.is() 对比两个类型 1234let objOne = &#123;name:'sun'&#125;;let objTwo = &#123;name:'wei'&#125;;console.log(objOne.name===objTwo.name);console.log(Object.is(objOne.name,objTwo.name)) is 与 === 的区别is 是严格比较，===是同值比较1234console.log(-0===+0) // trueconsole.log(Object.is(-0,+0)) // falseconsole.log(NaN===NaN); // falseconsole.log(Object.is(NaN,NaN)); // true Object.assign(target, …sources) target: 目标对象,sources: 源对象。 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。12345678var aa = &#123;aa:'sun'&#125;;var bb = &#123;bb:'xiao'&#125;;var cc = &#123;cc:'bi'&#125;;let dd = Object.assign(aa,bb,cc)console.log(aa) // &#123;aa: "sun", bb: "xiao", cc: "bi"&#125;console.log(bb) // &#123;bb: "xiao"&#125;console.log(cc) // &#123;cc: "bi"&#125;console.log(dd) // &#123;aa: "sun", bb: "xiao", cc: "bi"&#125; 10. Symbol() 基本数据类型：String、Boolean、Number、undefined、null、Symbol引用数据类型：Object、Array、Function Symbol的打印123var txt = Symbol('sxiaobi');console.log(txt);console.log(txt.toString()); 这时候我们仔细看控制台是有区别的，没有toString的是红字，toString的是黑字。 Symbol在对象中的应用1234567var jspang = Symbol();var obj=&#123; [jspang]:'sxiaobi'&#125;console.log(obj[jspang]);obj[jspang]='web';console.log(obj[jspang]); Symbol对象元素的保护作用在对象中有很多值，但是循环输出时，并不希望全部输出，那我们就可以使用Symbol进行保护。没有进行保护的写法：12345var obj = &#123;name:'sxiaobi',age:'28',sex:'男'&#125;;for( let item in obj )&#123; console.log(obj[item])&#125;// sxiaobi 28 男 现在我不想别人知道我的年龄，这时候我就可以使用Symbol来进行循环保护。1234567var obj = &#123;name:'sxiaobi',sex:'男'&#125;;var age = Symbol();obj[age] = '28';for( let item in obj )&#123; console.log(obj[item])&#125;// sxiaobi 男 11. Set和weakSet数据结构es6新增的数据结构 数据结构是计算机存储、组织数据的方式，是相互之间存在一种或多种特定关系的数据元素的集合，包括逻辑结构和物理结构。数据类型是指数据的类型，是一个值的集合和定义在这个值集上的一组操作的总称。 set 去重，返回一个set对象123let arr = [...new Set([1,2,3,4,1,2,3,4])]console.log(arr)// [1,2,3,4] 但是不支持重复的object. 基本使用 12345678let arr = new Set([1,2,3]);arr.add(4);console.log(arr); // 1,2,3,4console.log(arr.has(4)); // truearr.delete(4);console.log(arr); // 1,2,3console.log(arr.has(4)); // falsearr.clear(); // undefined 实际例子 1234567891011121314151617181920let myArray=[1,2,2,3,3,4] let mySet=new Set(myArray); myArray=[...mySet]; console.log("---数组去重---"); console.log(myArray);//(4) [1, 2, 3, 4] let s1=new Set([1,2,3]); let s2=new Set([2,3,4,5]); console.log("---并集---"); let unionSet=new Set([...s1,...s2]); console.log(unionSet); console.log("---交集---"); let intersect=new Set([...s1].filter(x=&gt;s2.has(x))); console.log(intersect);//Set(2) &#123;2, 3&#125; console.log("---差集---"); let difference=new Set([...s1].filter(x=&gt;!s2.has(x))); console.log(difference);//Set(1) &#123;1&#125; 12. map数据结构 基本使用 12345678let mapJg = new Map();mapJg.set('key','val');console.log(mapJg) // Map(1) &#123;"key" =&gt; "value"&#125;console.log(mapJg.has('key')) // trueconsole.log(mapJg.size) // 1mapJg.delete('key');console.log(mapJg.has('key')) // falsemapJg.clear(); // undefined map结构和数组结构的转换 123456789let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],])[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 实际例子 123456789101112131415var errors = new Map([ [400, 'InvalidParameter'], [404, 'Not found'], [500, 'InternalError']]);for( let [val,index] of errors.entries())&#123; console.log(val) console.log(index)&#125;// 400// InvalidParameter// 404// Not found// 500// InternalError 13. Proxy函数预处理 类似vue的生命周期、钩子函数，就是指操作一个对象或方法的时候，运行之前操作一些数据，运行完成操作一些数据。Proxy的存在就是为了让我们为函数加上这样的钩子函数，所以我们可以简单的理解为函数或对象的生命周期。==需要重点学习、此处先简单记录一些== 基本用法此处第一个括号是原数据、方法的主体，后者是预处理函数get,set.写钩子函数的地方。1let proxyTest = new Proxy(&#123;&#125;,&#123;&#125;); get(target,key,property) target得到的目标值，key目标的键名值，property这个不常用。 set(target,key,value,reciver); target得到的目标值，key目标的键名值，value的要改变的值，receiver改变的原始值。 123456789101112131415161718192021let obj = &#123; name: 'test'&#125;let proxyTest = new Proxy(obj,&#123; get:function(target,key,property)&#123; console.log(target); console.log(key); console.log(property); return target[key]; &#125;, set:function(target,key,value,reciver)&#123; console.log(target); console.log(key); console.log(value); console.log(reciver); return target[key] = value; &#125;&#125;);console.log(proxyTest.name,'第一次'); // test 第一次proxyTest.name='change';console.log(proxyTest.name,'第二次') // change 第二次 apply的使用，apply的作用是调用内部的方法。它使用在方法体是一个匿名函数时 1234567891011121314let target = function () &#123; return 'I am sxiaobi';&#125;;var handler = &#123; apply(target, ctx, args) &#123; console.log('do apply'); return Reflect.apply(...arguments); &#125;&#125;var pro = new Proxy(target, handler);console.log(pro()); // do apply// I am sxiaobi 14. promise对象的使用 解决了回调地狱的问题。多层代码嵌套回调，不利于维护和二次开发。 多层嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273let state = 1;function step1(resolve,reject)&#123; console.log('相亲'); if( state == 1 )&#123; resolve('相亲成功--约会') &#125;else&#123; reject('相亲失败--跳河') &#125;&#125;function step2(resolve,reject)&#123; console.log('恋爱'); if( state == 1 )&#123; resolve('恋爱成功--见家长') &#125;else&#123; reject('恋爱失败--重新相亲') &#125;&#125;function step3(resolve,reject)&#123; console.log('结婚'); if( state == 1 )&#123; resolve('结婚成功--生子') &#125;else&#123; reject('结婚失败--离婚') &#125;&#125;new Promise(step1).then((val)=&gt;&#123; console.log(val); return new Promise(step2)&#125;).then((val)=&gt;&#123; console.log(val); return new Promise(step3)&#125;).then((val)=&gt;&#123; console.log(val);&#125;).catch((val)=&gt;&#123; console.log(val); console.log('第一步就死求了')&#125;)let state = 1;function step1(resolve,reject)&#123; console.log('相亲'); if( state == 1 )&#123; resolve('相亲成功--约会') &#125;else&#123; reject('相亲失败--跳河') &#125;&#125;function step2(resolve,reject)&#123; console.log('恋爱'); if( state == 1 )&#123; resolve('恋爱成功--见家长') &#125;else&#123; reject('恋爱失败--重新相亲') &#125;&#125;function step3(resolve,reject)&#123; console.log('结婚'); if( state == 1 )&#123; resolve('结婚成功--生子') &#125;else&#123; reject('结婚失败--离婚') &#125;&#125;new Promise(step1).then((val)=&gt;&#123; console.log(val); return new Promise(step2)&#125;).then((val)=&gt;&#123; console.log(val); return new Promise(step3)&#125;).then((val)=&gt;&#123; console.log(val);&#125;).catch((val)=&gt;&#123; console.log(val); console.log('有出错就死求了')&#125;) 15. class类的使用 我们经常使用对象或者方法模拟类的使用。为了优雅，es6之后为我们引入了类。 基本使用123456789101112class apiList&#123; getInfo(val)&#123; console.log(val); return val; &#125; getReadList(val)&#123; console.log(this.getInfo(val)+':'+'阅读历史') &#125;&#125;let api = new apiList;api.getInfo('account:347363545') // account:347363545api.getReadList('account:347363545') // account:347363545:阅读历史 这里需要注意的是两个方法中间不要写逗号了，还有这里的this指类本身，还有要注意return 的用法。 类的传参 constructor() 1234567891011class apiList&#123; constructor(a,b)&#123; this.a=a; this.b=b; &#125; add()&#123; return this.a+this.b; &#125;&#125;let api = new apiList(1,2);console.log(api.add()); // 3 class的继承 extends 123456789101112class apiList&#123; constructor(a,b)&#123; this.a=a; this.b=b; &#125; add()&#123; return this.a+this.b; &#125;&#125;class newApiList extends apiList&#123;&#125;let newApi = new newApiList(6,8);console.log(newApi.add()) // 14 16.模块化操作 export 模块化的输出 import 模块化的引入 export可以让我们把变量，函数，对象进行模块话，提供外部调用接口，让外部进行引用。先来看个最简单的例子，把一个变量模块化。我们新建一个temp.js文件，然后在文件中输出一个模块变量。1export var a = 'jspang'; 然后可以在index.js中以import的形式引入。12import &#123;a&#125; from './temp.js';console.log(a); 多变量的输出1234567var a = 'one';var b = 'two';var c = 'three';export &#123;a,b,c&#125;;export function add(a,b)&#123; return a+b;&#125; as的用法 有些时候我们并不想暴露模块里边的变量名称，而给模块起一个更语义话的名称，这时候我们就可以使用as来操作。12345678var a = 'one';var b = 'two';var c = 'three';export &#123; x as a, y as b, z as c&#125; 12import &#123;x,y,z&#125; from './temp.js';console.log(x,y,z); export default的使用 加上default相当是一个默认的入口。在一个文件里export default只能有一个,而export可以有多个。我们来对比一下export和export default的区别 export 1234export var a ='test';export function add(a,b)&#123; return a+b;&#125; 1import &#123;a,add&#125; from './temp.js'; exprot default123export default function add(a,b)&#123; return a+b;&#125; 1import api from './temp.js';]]></content>
      <categories>
        <category>2020Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2020%2F03%2F20%2Fvue%2F</url>
    <content type="text"><![CDATA[为什么要用vue? 渐进式、轻量、声明式、高效、易用、响应式 什么是渐进式？可以部分使用vue,也可以使用vue的一部分.声明式渲染 - 组件系统 - 客户端路由 - 大规模状态管理 - 构建工具 vue语法vue实例常用选项var vm = new Vue({ // 1. 实例挂载目标 el: ‘#app’, // 2. 设置数据对象 data: {}, // 3. 计算属性 computed: {}, // 4. 过滤器 filters:{}, // 5. 方法 methods:{}, // 6. 监听器 watch:{}, // 7. 局部注册组件(子组件) components:{}}) 文件说明dev-server.js 里面 的 port变量 就是可以修改的端口号assets 文件中 放 css 图片素材componentsmain.js 当前文件的逻辑入口app.vue 根组件 里面有 三个部分和小程序很像 逻辑语法1234567891011121314export default &#123; 给外部使用 name: &apos;test&apos; 当前组件的名字 data()&#123; return &#123; title : &apos;Hellow Vue.js!&apos; &#125; &#125;&#125;import test form &apos;./components/test&apos; 引入&lt;style lang=&quot;css&quot; scoped&gt; 设置 scoped 只会影响当前内容的属性&lt;/style&gt; 获取数据的方法12模板绑定 &lt;p&gt;&#123;&#123;title&#125;&#125;&lt;/p&gt;指令获取 &lt;p v-text=&quot;titile&quot;&gt;&lt;/p&gt; 模板语法123v-ifv-elsev-for=&quot;item in items&quot; 前面是变量 后面是数组 事件绑定1234v-on 包含很多个事件 js有的 都可以v-on:click=&quot;&quot;v-on:keyup v-on:keyup.entercomputed 计算属性 常用插件axios // axios的http请求模块https://www.npmjs.com/package/axiosvue-scroller //滚动组件（下拉加载）https://www.npmjs.com/package/vue-scrollervue-awesome-swiper // 轮播图安装地址 https://www.npmjs.com/package/vue-awesome-swiper演示地址 https://surmon-china.github.io/vue-awesome-swiper/博客 https://segmentfault.com/a/1190000010142118npm install less less-loader –save-devhttps://www.cnblogs.com/zhuzhenwei918/p/6870340.html?utm_source=itdadao&amp;utm_medium=referralhttp://www.jb51.net/article/112143.htm 环境安装 必须拥有node 和 npm -v查看版本号 全局安装 vue-cli $ npm install -g vue-cli $ vue init webpack vuecliTest $ npm install $ npm run dev 启用一个server http://www.runoob.com/vue2/vue-install.html 1）安装淘宝cnpm镜像$ npm install -g cnpm –registry=http://registry.npm.taobao.org 2）安装vue-cli$ cnpm install -g vue-cli测试安装：$ vue -V2.9.3 12345678$ vue init webpack test 初始化第一个项目（webpack方式） (项目名称不能包含大写字母)$ cd test$ cnpm install 生成node-modules: 因为各个模板间都是相互依赖的，所以要安装依赖，在命令行输入cnpm install ,你会发现在已经创建的项目结构里面会多出一个node_modules的文件夹，里面就是刚才安装的所有依赖。$ cnpm run dev 运行第一个程序:运行成功后会在浏览器中直接打开 DONE Compiled successfully in 4388ms&gt; Listening at http://localhost:8080 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061? Project name (test) 0327? Project name 0327? Project description (A Vue.js project)? Project description A Vue.js project? Author (sywsywsyw &lt;347363545@qq.com&gt;)? Author sywsywsyw &lt;347363545@qq.com&gt;? Vue build standalone? Install vue-router? (Y/n) y 路由? Install vue-router? Yes ? Use ESLint to lint your code? (Y/n) no ESlint规范 ? Use ESLint to lint your code? no ? Pick an ESLint preset (Use arrow keys) no? Pick an ESLint preset Standard? Set up unit tests (Y/n) no? Set up unit tests no? Pick a test runner (Use arrow keys)? Pick a test runner jest? Setup e2e tests with Nightwatch? (Y/n) no 单元测试? Setup e2e tests with Nightwatch? no? Should we run `npm install` for you after the project has been created? (reco? Should we run `npm install` for you after the project has been created? (recommended) npmRunning eslint --fix to comply with chosen preset rules...# ========================&gt; 0327@1.0.0 lint F:\vue0326\test&gt; eslint --ext .js,.vue src test/unit test/e2e/specs &quot;--fix&quot;# Project initialization finished!# ========================To get started: cd test npm run devDocumentation can be found at https://vuejs-templates.github.io/webpack？项目名称（测试）0327？项目名称0327？项目描述（一vue.js项目）？项目描述一vue.js项目？作者（sywsywsyw＜347363545 @ QQ。COM &gt;）？作者sywsywsyw 347363545@qq.com &gt; &lt;？Vue公司建立独立？安装Vue路由器？（y／n）y？安装Vue路由器？是的？使用ESLint皮棉代码？（y／n）y？使用ESLint皮棉代码？是的？选择一个ESLint预设（使用箭头键）？选择预先设定的标准？设置单元测试（y / n）y？设置单元测试是？选择测试运行器（使用箭头键）？选择一个测试跑步者的笑话？Nightwatch建立端到端的测试？（y／n）y？Nightwatch建立端到端的测试？是的？我们应该运行` NPM安装`您后，项目被创建？（Reco？我们应该运行` NPM安装`您后，项目被创建？（Reco新公共管理的介绍） build 文件夹 webpack配置文件config 文件夹 项目开发配置node_modules 文件夹 npm包管理src 文件夹 源代码static 文件夹 静态文件目录 .|– build // 项目构建(webpack)相关代码| |– build.js // 生产环境构建代码| |– check-version.js // 检查node、npm等版本| |– dev-client.js // 热重载相关| |– dev-server.js // 构建本地服务器| |– utils.js // 构建工具相关| |– webpack.base.conf.js // webpack基础配置| |– webpack.dev.conf.js // webpack开发环境配置| |– webpack.prod.conf.js // webpack生产环境配置|– config // 项目开发环境配置| |– dev.env.js // 开发环境变量| |– index.js // 项目一些配置变量| |– prod.env.js // 生产环境变量| |– test.env.js // 测试环境变量|– src // 源码目录| |– components // vue公共组件| |– store // vuex的状态管理| |– App.vue // 页面入口文件| |– main.js // 程序入口文件，加载各种公共组件|– static // 静态文件，比如一些图片，json数据等| |– data // 群聊分析得到的数据用于数据可视化|– .babelrc // ES6语法编译配置|– .editorconfig // 定义代码格式|– .gitignore // git上传需要忽略的文件格式|– README.md // 项目说明|– favicon.ico|– index.html // 入口页面|– package.json // 项目基本信息. vue问题这个傻逼问题的出现是什么呢？1234567vue.esm.js?efeb:591 [Vue warn]: Unknown custom element: &lt;m&gt; - did you register the component correctly? For recursive components, make sure to provide the &quot;name&quot; option.found in---&gt; &lt;Ranklist&gt; at src\components\Ranklist.vue &lt;App&gt; at src\App.vue &lt;Root&gt; 看这 不规范的html标签直接报错！！！！！ 还是要规范写代码啊 出现报错123456789101112131415&gt; onevue@1.0.0 dev C:\Users\SUI\Desktop\vue0307\onevue&gt; webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&apos;webpack-dev-server&apos; ▒▒▒▒▒ڲ▒▒▒▒ⲿ▒▒▒Ҳ▒▒▒ǿ▒▒▒▒еĳ▒▒▒▒▒▒▒▒▒▒▒▒ļ▒▒▒npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! onevue@1.0.0 dev: `webpack-dev-server --inline --progress --config build/webpack.dev.conf.js`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the onevue@1.0.0 dev script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\SUI\AppData\Roaming\npm-cache\_logs\2018-03-07T12_22_01_319Z-debug.log 你这是由于8080端口被占用了。你可以通过如下方式解决。1 按下Windows键。输出cmd。点击cmd.exe.打开该程序。2 输入 netstat -ano|findstr 8080 ，找到占用进程的pid.3 输入命令taskkill /pid 4708 /f ，结束该进程。//假如 4708是查询到的pid 报错 eslint 检查出错 在vue项目中关闭ESLint方法：找到build文件夹—&gt;webpack.base.conf.js—-&gt;module 12345678Failed to load the ESLint library for the document c:\Users\SUI\Desktop\vue0307\qqmiuscvue\menu\src\main.jsTo use ESLint please install eslint by running 'npm install eslint' in the workspace folder menuor globally using 'npm install -g eslint'. You need to reopen the workspace after installing eslint.If you are using yarn instead of npm set the setting `"eslint.packageManager": "yarn"`Alternatively you can disable ESLint for the workspace folder menu by executing the 'Disable ESLint' command. http://blog.csdn.net/wdy_2099/article/details/76997888?locationNum=5&amp;fps=1]]></content>
      <categories>
        <category>环境框架语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json]]></title>
    <url>%2F2020%2F03%2F20%2FME-JS%2CJQ%2FJS-json%2F</url>
    <content type="text"><![CDATA[parse用于从一个字符串中解析出json对象,12var str = '&#123;"name":"huangxiaojian","age":"23"&#125;'JSON.parse(str) 1234//结果：Objectage: "23"name: "huangxiaojian"__proto__: Object 注意：单引号写在{}外，每个属性名都必须用双引号，否则会抛出异常。 stringify()用于从一个对象解析出字符串，如12var a = &#123;a:1,b:2&#125;JSON.stringify(a) 12结果："&#123;"a":1,"b":2&#125;" //数组按照对象排序var compare = function (prop) { return function (obj1, obj2) { var val1 = obj1[prop]; var val2 = obj2[prop]; if (val1 &lt; val2) { return -1; } else if (val1 &gt; val2) { return 1; } else { return 0; } }}datajs.sort(compare(‘agent_id’));]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npm部分插件安装.]]></title>
    <url>%2F2020%2F03%2F07%2F2020Note%2Fnpm%E9%83%A8%E5%88%86%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.%2F</url>
    <content type="text"><![CDATA[1. 安装yarn1npm install -g yarn --registry=https://registry.npm.taobao.org]]></content>
      <categories>
        <category>2020Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack3.X版笔记]]></title>
    <url>%2F2020%2F03%2F06%2F2020Note%2FWebpack3.X%E7%89%88%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[webpack官网webpack文档 1. 认识Webpack的作用 打包：可以把多个javascript文件打包成一个文件，减少服务器压力和下载带宽 转换：把扩展语言转换成普通的javascript，让浏览器顺利运行。 优化：前端复杂性的提高，开始肩负起优化和提升性能的责任。 12345678910111. `win+R` 进入对话框输入`cmd`进入命令行模式。2. 输入`f： `进入f盘3. `mkdir webpack_demo` 生成webpack_demo文件夹4. `cd webpack_demo` 进入当前文件夹5. 需要安装`node`6. `npm install -g webpack` 全局安装webpack， 注意：全局安装是可以的，但是webpack官方是不推荐的。 这会将您项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。 7. 对项目目录安装，npm初始化。`npm init`8. `npm install --save-dev webpack` 安装到开发环境9. `webpack -v` 检查版本号 2.配置文件配置出口和入口文件1234567891011121314151617181920const path = require('path');moduel.exports = &#123; // 入口文件配置项 entry:&#123; './entry.js' &#125;, // 出口文件配置项 output:&#123; // 打包文件的出口路径 path: path_resolve(__dirname,'dist'), // 获取项目的绝对路径 // 输出文件名称 filename: 'bundle.js' &#125;, // 模块，用于解析css,图片转换，压缩 module:&#123;&#125;, // 插件，用于生产模板和各项功能 plugins:[], // 配置webpack开发服务功能 devServer:&#123;&#125;&#125; 服务和热更新 webpack-dev-server 安装1npm install webpack-dev-server --save-dev webpack.config.js中123456789101112moduel.exports = &#123; devServer:&#123; // 设置基本目录接口 contentBase: path_resolve(__dirname:'dist'); // 用于找到程序打包地址 // 服务 IP 地址 host: 'localhost', // 服务是否开启压缩 compress: true, // 配置服务端口号 port: 8888 &#125;&#125; package.json中123"script":&#123; "server":"webpack-dev-server"&#125; 3. 模块css打包loaders 可以把sass、less文件转为css 可以把es6及以上的代码转为大多浏览器兼容的js代码 可以把React的JSX转为javascript代码 所有的解析器都需要使用npm安装然后在进行使用。 建立index.css文件引入到入口文件夹main.js中1import i_css from './css/index.js' CSS和引入做好后，我们就需要使用loader来解析CSS文件了，这里我们需要两个解析用的loader，分别是style-loader和css-loader。 style-loader用于处理css中的url(), https://www.npmjs.com/package/style-loader1npm install style-loader --save-dev css-loader用来将css插入到页面的style的标签。https://www.npmjs.com/package/css-loader1npm install css-loader --save-dev 修改webpack.config.js中的module12345678910111213141516module.exports = &#123; module:&#123; rules:[ &#123; test: /\.css$/, use:['style-loader','css-loader'], // 第一种 loader:['style-loader','css-loader'], // 第二种 use:[&#123; // 第三种 loader: 'style-loader' &#125;,&#123; loader: 'css-loader' &#125;] &#125; ] &#125;&#125; 4.插件配置==需要注意的压缩需要在生产环境下配置，因为开发环境为了方便调试压缩个棒棒== js压缩uglifyjs-webpack-plugin 这个小瘪三插件默认集成进了webpack 所以不用安装了 引入webpack.config.js引入123456const uglify = require('uglifyjs-webpack-plugin');moduel.exports = &#123; plugin:[ new uglify() ]&#125; html文件的发布 打包html文件html-webpack-plugin 插件1const htmlPlugin = require('html-webpack-plugin'); 引入npm 安装1npm install html-webpack-plugin --save-dev webpack.config.js进行配置1234567891011module.exports = &#123; plugin:[ new htmlPlugin(&#123; minify:&#123; removeAttributeQuotes:true &#125;, hash:true, template:'./src/index.html' &#125;) ]&#125; minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。 hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。 template：是要打包的html模版路径和文件名称。 总结：html文件的打包可以有效的区分开发目录和生产目录，在webpack的配置中也要搞清楚哪些配置用于生产环境，哪些配置用于开发环境，避免两种环境的配置冲突。 5. 图片迈坑图片处理file-loader 解析背景图片的url，路径url-loader 减少http请求，将图片转为dataUrl，但是如果图片过大，编码会消耗性能，所以有了limit参数进行配置注意： loader使用时不需要require引用，plugins才需要使用require引入url-loader 默认包含了 file-loader所以引入的时候只需要引入url-loader就行了 webpackconfig.js中123456789101112131415moduel.exports = &#123; module:&#123; rules:[ &#123; test:/\.(png|jpg|gif)/ , use: [ loader:'url-loader', options:&#123; limit: 500000 &#125; ] &#125; ] &#125;&#125; test:/.(png|jpg|gif)/是匹配图片文件后缀名称。 use：是指定使用的loader和loader的配置参数。 limit：是把小于500000B的文件打成Base64的格式，写入JScss图片分离和图片路径处理css分离:extract-text-webpack-plugin1npm install --save-dev extract-text-webpack-plugin webpackconfig.js中12345678910const extractCss = require('extract-text-webpack-plugin');module.exports = &#123; module:&#123; test: /\.css$/, use: extractTextPlugin.extract(&#123; fallback: "style-loader", use: "css-loader" &#125;) &#125;&#125; 图片路径问题利用extract-text-webpack-plugin插件很轻松的就把CSS文件分离了出来，但是CSS路径并不正确，很多小伙伴就在这里搞个几天还是没有头绪，网上也给出了很多的解决方案，我觉的最好的解决方案是使用publicPath解决，我也一直在用。publicPath：是在webpack.config.js文件的output选项中，主要作用就是处理静态文件路径的。在处理前，我们在webpack.config.js 上方声明一个对象，叫website。123var website = &#123; publicPath: "http://192.168.1.108:8888/"&#125; 然后在output选项中引用这个对象的publicPath属性。12345module.exports = &#123; output:&#123; publicPath: website.publicPath &#125;&#125; 配置完成后，你再使用webpack命令进行打包，你会发现原来的相对路径改为了绝对路径，这样来讲速度更快。总结：这节课我们实现了CSS的分离，并在分离后处理了图片路径不对的问题。处理路径的方法一定要充分理解，因为这在工作中经常用到。 处理html中的图片html-withimg-loader1npm install html-withimg-loader --save 1234&#123; test: /\.(htm|html)$/i, use:[ 'html-withimg-loader'] &#125; 如何把图片放到指定的文件夹下123456789101112131415module.exports = &#123; rules:[&#123; test: /\.(png|jpg|gif)/, use:[&#123; loader:'style-loader', option:&#123; limit:'url-loader', options:&#123; limit:5000, outputPath:'images/' &#125; &#125; &#125;] &#125;]&#125; 6. Css进阶Less文件的打包和分离12npm install --save-dev lessnpm install --save-dev less-loader webpack.js12345678910&#123; test: /\.less$/, use: [&#123; loader: "style-loader" // creates style nodes from JS strings &#125;, &#123; loader: "css-loader" // translates CSS into CommonJS , &#123; loader: "less-loader" // compiles Less to CSS &#125;]&#125; 把Lees文件分离123456789101112&#123; test: /\.less$/, use: extractTextPlugin.extract(&#123; use: [&#123; loader: "css-loader" &#125;, &#123; loader: "less-loader" &#125;], // use style-loader in development fallback: "style-loader" &#125;) &#125; Sass文件的打包和分离12npm install --save-dev node-sassnpm install --save-dev sass-loader 注意：在用npm安装时，这个loader很容易安装失败，最好使用cnpm来进行安装。如果你安装一直报错，最好是把node_modules文件夹删除后，再重新安装。12345678910&#123; test: /\.scss$/, use: [&#123; loader: "style-loader" // creates style nodes from JS strings &#125;, &#123; loader: "css-loader" // translates CSS into CommonJS &#125;, &#123; loader: "sass-loader" // compiles Sass to CSS &#125;]&#125; 把Lees文件分离123456789101112&#123; test: /\.scss$/, use: extractTextPlugin.extract(&#123; use: [&#123; loader: "css-loader" &#125;, &#123; loader: "sass-loader" &#125;], // use style-loader in development fallback: "style-loader" &#125;) &#125; css3属性前缀处理PostCSS css处理平台需要安装postcss-loader和autoprefixer1npm install --save-dev postcss-loader autoprefixer postcss.config.jspostCSS推荐在项目根目录（和webpack.config.js同级），建立一个postcss.config.js文件。12345module.exports = &#123; plugins: [ require('autoprefixer') ]&#125; 编写loader对postcss.config.js配置完成后，我们还需要编写我们的loader配置。1234567891011121314151617181920module.exports = &#123; module:&#123; rules:[ &#123; test: /\.css$/, use: [ &#123; loader: "style-loader" &#125;, &#123; loader: "css-loader", options: &#123; modules: true &#125; &#125;, &#123; loader: "postcss-loader" &#125; ]&#125;] &#125;&#125; 提取CSS配置提取CSS的loader配置.1234567891011&#123; test: /\.css$/, use: extractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, 'postcss-loader' ] &#125;)&#125; 总结:postcss还有很多功能，我希望小伙伴学会自学。这里给出postcss-loader的github地址：https://github.com/postcss/postcss-loader 消除未使用的css像Bootstrap这样的框架往往会带有很多CSS。在项目中通常我们只使用它的一小部分。就算我们自己写CSS，随着项目的进展，CSS也会越来越多，有时候需求更改，带来了DOM结构的更改，这时候我们可能无暇关注CSS样式，造成很多CSS的冗余。这节课就学习用webpack消除未使用的CSS。 PurifyCSS 使用PurifyCSS可以大大减少CSS冗余，比如我们经常使用的BootStrap(140KB)就可以减少到只有35KB大小。这在实际开发当中是非常有用的。 安装PurifyCSS-webpack 从名字你就可以看出这是一个插件，而不是loader。所以这个需要安装还需要引入。 PurifyCSS-webpack要以来于purify-css这个包，所以这两个都需要安装。1npmn i -D purifycss-webpack purify-css 这里的-D代表的是–save-dev ,只是一个简写。 引入glob 因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。在webpack.config.js文件头部引入glob。12const glob = require(glob);const PurifyCSSPlugin = `require`("purifycss-webpack"); 配置plugins1234567891011121314151617plugins:[ //new uglify() new htmlPlugin(&#123; minify:&#123; removeAttrubuteQuotes:true &#125;, hash:true, template:'./src/index.html' &#125;), new extractTextPlugin("css/index.css"), new PurifyCSSPlugin(&#123; // Give paths to parse for rules. These should be absolute! paths: glob.sync(path.join(__dirname, 'src/*.html')), &#125;)] 这里配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了。 注意：使用这个插件必须配合extract-text-webpack-plugin这个插件，这个插件在前边的课程已经讲解过了。如果你还不会请自学一下。 配置好上边的代码，我们可以故意在css文件里写一些用不到的属性，然后用webpack打包，你会发现没用的CSS已经自动给你删除掉了。在工作中记得一定要配置这个plugins，因为这决定你代码的质量，非常有用。 7. webpack添加babel支持在前端开发中都开始使用ES6的语法了，虽然说webpack3增加了一些ES6的转换支持，但是实际效果不是很好，也可能是本人技术有限，没发挥出真正的功能。所以我在开发中还是喜欢添加Babel-loader的，我也查看了一些别人的webpack配置也都增加了babel-loader，所以这节课我们学习一下如何增加Babel支持。（此节文章部分内容引用了zhangwang大神的文章内容） Babel是什么？ Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过便宜帮你达到以下目的： 使用下一代的javaScript代码(ES6,ES7….)，即使这些标准目前并未被当前的浏览器完全支持。 使用基于JavaScript进行了扩展的语言，比如React的JSX。 Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 我们先一次性安装这些依赖包`Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 我们先一次性安装这些依赖包1cnpm c install --save-dev babel-core babel-loader babel-preset-env babel-preset-react 在webpack中配置Babel的方法如下：123456789101112&#123; test:/\.(jsx|js)$/, use:&#123; loader:'babel-loader', options:&#123; presets:[ "env","react" ] &#125; &#125;, exclude:/node_modules/&#125; 现在你已经可以用webapck转换ES6的语法兼容各个浏览器了，我们可以修改一下entry.js的代码如下：12345import css from './css/index.css';&#123; let jspangString = 'Hello Webpack' document.getElementById('title').innerHTML=jspangString; &#125; 上面的代码使用了ES6的let声明方法。如果你不使用Babel来进行转换，你会发现打包出来的js代码没有作兼容处理，使用了Babel转换的代码是进行处理过的。 .babelrc配置虽然Babel可以直接在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，如果卸载webapck.config.js中会非常的雍长不可阅读，所以我们经常把配置写在.babelrc文件里。 在项目根目录新建.babelrc文件，并把配置写到文件里。.babelrc123&#123; "presets":["react","es2015"]&#125; .webpack.config.js里的loader配置1234567&#123; test:/\.(jsx|js)$/, use:&#123; loader:'babel-loader', &#125;, exclude:/node_modules/&#125; 8.打包之后如何调试作为一个程序员每天的大部分工作就是调试自己写的程序，那我们使用了webpack后，所以代码都打包到了一起，给调试带来了麻烦，但是webpack已经为我们充分考虑好了这点，它支持生产Source Maps来方便我们的调试。（敲黑板，这节可能偏理论一点。） 在使用webpack时只要通过简单的devtool配置，webapck就会自动给我们生产source maps 文件，map文件是一种对应编译文件和源文件的方法，让我们调试起来更简单。 四种选项 在配置devtool时，webpack给我们提供了四种选项。 source-map:在一个单独文件中产生一个完整且功能完全的文件。这个文件具有最好的source map,但是它会减慢打包速度； cheap-module-source-map:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。 eval-source-map:使用eval打包源文件模块，在同一个文件中生产干净的完整版的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。 cheap-module-eval-source-map:这是在打包文件时最快的生产source map的方法，生产的 Source map 会和打包后的JavaScript文件同行显示，没有影射列，和eval-source-map选项具有相似的缺点。 四种打包模式，有上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对执行和调试有一定的影响。 个人意见是，如果大型项目可以使用source-map，如果是中小型项目使用eval-source-map就完全可以应对，需要强调说明的是，source map只适用于开发阶段，上线前记得修改这些调试设置。 简单的配置：12345678module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + "/app/main.js", output: &#123; path: __dirname + "/public", filename: "bundle.js" &#125;&#125; 总结：调试在开发中也是必不可少的，但是一定要记得在上线前一定要修改webpack配置，在打出上线包。 9. 开发和生产并行设置开发生产环境依赖不同一个项目中是有开发环境和生产环境的，这两个环境的依赖也是不同的。 开发依赖：在开发中用来帮助开发、简化代码或者生成兼容设置的依赖包。可以使用package.json来查看，devDependencies的下面的这些包为开发使用的依赖包。在生成环境中并无用处。 生产依赖：比如我们的js使用了jquery，jquery在浏览器端口起作用，也就是说我们最终的程序也需要这个包。这个生产依赖，这些包在dependencies。 npm安装的三种安装方式one1npm install jquery 安装完成后，你会发现在package.json中并不存在这个包的依赖。如果你项目拷贝给别人继续开发，或者别人和你git合作，再次下载项目npm install时就会缺少这个jquery包。项目就会无法正常运行，所以这也是我们最不赞成的安装方法。two1npm install jquery --save 安装完成后，它存在于package.json的dependencies中，也就是说它是生产环境需要依赖的包（上线时需要的依赖包）。three1npm install jquery --save-dev 安装完成后，它存在于package.json的devDependencies中，也就是说它是开发环境中需要的，上线并不需要这个包的依赖。 安装全部依赖包1npm install 安装生产环境依赖包1npm install --production 配置生产和开发并行我们在以前的配置中设置了一个变量website，用于静态资源正确找到路径。那如果生产环境和开发环境不一样，而且我们需要来回切换，这时候我们需要更好的设置方法。123var website=&#123; publicPath:"http://192.168.0.104:1717/"&#125; 修改package.json命令其实就是添加一个dev设置，并通过环境变量来进行区分，下面是package.json里的值。12345"scripts": &#123; "server": "webpack-dev-server --open", "dev":"set type=dev&amp;webapck", "build": "set type=build&amp;webpack" &#125;, 修改webpack.config.js文件可以利用node的语法来读取type的值，然后根据type的值用if–else判断。123456789if(process.env.type== "build")&#123; var website=&#123; publicPath:"http://192.168.0.104:1717/" &#125;&#125;else&#123; var website=&#123; publicPath:"http://cdn.jspang.com/" &#125;&#125; 如果你说我想看一下传过来的值到底是什么？可以用下面的输出语句。1console.log( encodeURIComponent(process.env.type) ); 10. webpack模块化配置为了让大家容易看懂，我把webpack.config.js中的entry入口文件进行模块化设置，单独拿出来制作成一个模块。 首先在根目录，新建一个webpack_config文件夹，然后新建entry_webpack.js文件，代码如下： entry_webpack.js12345678//声明entry变量const entry =&#123;&#125;; //声明路径属性entry.path=&#123; entry:'./src/entry.js' &#125;//进行模块化module.exports =entry; 配置的模块化代码编写好以后，需要在webpack.config.js中引入，注意这里的引入只能使用require的方法。1const entry = require("./webpack_config/entry_webpack.js") webpack.config.js 入口文件中123module.exports = &#123; entry:entry.path&#125; 这时候你可以再次使用npm run dev 进行测试，你会发现模块化成功了。 总结： 模块化在实际工作中是必不可少的操作，但是现在的webpack教程还很少讲到，大家一定要重视这节，因为如果你搞不清这节的内容，可能你看别人的配置也会看不明白。记得一定要动手练习操作，否则你下面的课程也没办法学习。]]></content>
      <categories>
        <category>2020Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020面试]]></title>
    <url>%2F2020%2F03%2F05%2F2020Note%2F2020%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1. 同源策略是什么？1限制一个源从另一个源的交互。需要相同域名，相同协议，相同端口。 2. html块元素、行元素 块元素： 1**行元素：** ```span,a,input,.select,strong,em,i 空元素： 12345##### 3. splice、slice的区别splice: 截取数组，返回被截取的值，改变原数组。```splice(1,3)```第一个参数下标，第二个参数是截取的位数slice: 截取数组、字符串，返回新数组，原数组不动。可以用于字符串。 第二个参数是endIndex ```slice(startIndex,endIndex) 4. vue-router的钩子函数？ 全局钩子函数 123456789101112131415* **组件内钩子函数**````jsbeforeRouteEnter(to, from, next) &#123; // do someting // 在渲染该组件的对应路由被 confirm 前调用&#125;,beforeRouteUpdate(to, from, next) &#123; // do someting // 在当前路由改变，但是依然渲染该组件是调用&#125;,beforeRouteLeave(to, from ,next) &#123; // do someting // 导航离开该组件的对应路由时被调用&#125;` 单独路由独享组件 123456789###### 5. substring，substr的区别**substring：** 如果都是一个参数的时候截取到末尾 第二个参数 endIndex 这个是startIndex,endIndex里找出一个较小的值,然后从字符串的开始位置算起,截取较小值位置和较大值位置之间的字符串,截取出来的字符串的长度为较大值与较小值之间的差。**substr：** 第二个参数是长度 ```jsvar txt = &apos;abcd&apos;;txt.substr(2) &quot;cd&quot;txt.substring(2) &quot;cd&quot;txt.substring(2,1) &quot;b&quot; 6. object.assign() 用于将所有可枚举的值从一个或多个源对象中转移到目标对象。 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。12345var target = [1];var source1 = [2];var source2 = [3];console.log(Object.assign(target,source1,source2))结果: [3] 1234567var target = [1];var source1 = [2];var source2 = [3,4];var source3 = &#123;name:1&#125;var source4 = &#123;name:4&#125;console.log(Object.assign(target,source1,source2,source3,source4))结果：[3, 4, name: 4] 7. new Set() es6去重 之后返回类数组 需要…扩展运算符变为真正的数组123var arr = [1,2,3,4,5,2,3,4];var newArr = [...new Set(arr)].sort((a,b)=&gt;a-b);console.log(newArr) 8. 什么是异步编程？promise、回调函数、时间监听、发布/订阅 9.1234567891011121314151617let arr1 = [1,2,3,4,5];let arr2 = [6,7,8,9,0];arr1.splice(2,1);let arr3 = arr2.map(v=&gt;&#123; return v+1 &#125;);let arr4 = arr3.filter(v=&gt;&#123; if( v &gt; 8)&#123; return v; &#125;&#125;)console.log(arr1);console.log(arr2);console.log(arr3);console.log(arr4);VM4848:10 (4) [1, 2, 4, 5]VM4848:11 (5) [6, 7, 8, 9, 0]VM4848:12 (5) [7, 8, 9, 10, 1]VM4848:13 (2) [9, 10]]]></content>
      <categories>
        <category>2020Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Jenkins自动化]]></title>
    <url>%2F2020%2F03%2F04%2F2020Note%2F%E5%85%B3%E4%BA%8EJenkins%E8%87%AA%E5%8A%A8%E5%8C%96%2F</url>
    <content type="text"><![CDATA[笨鸟贤妃，用了两天终于搞好了jenkins+coding的vue项目自动化打包。 1.windows下的安装。下载官网实在太慢了https://jenkins.io/zh/download/通过三方链接进行下载 https://mirrors.tuna.tsinghua.edu.cn/jenkins/windows/ 2.解压安装包之后就默认打开了，请耐心等待配置https://www.cnblogs.com/longpizi/p/10690781.html 1、net start jenkins 开启服务2、net stop jenkins 关闭服务我们可以在Windows10系统的开始菜单上，单击鼠标右键，这时候出现的菜单中，我们选择命令提示符（管理员）或 http://localhost:8080/exit 会提示你是否关闭服务http://localhost:8080/restart重启jenkins C:\Program Files (x86)\Jenkins\secrets\initialAdminPassword1d9ad2e761a045b78b52a994d4df2a6d 3. 插件下载过慢https://blog.csdn.net/u013788943/article/details/103822785 4.(修改Jenkins访问端口)到Jenkins安装目录找到jenkins.xml 打开里面有个–httpPort=8080 直接修改它就可以了 5.创建第一个管理员用户 s18334787934 sx…4s6.jenkins汉化 jenkins转换显示语言为中文简体（jenkins汉化）https://blog.csdn.net/u013053075/article/details/101770152 7. 账号密码使用admin或者自己注册的账号。如果用admin账号，初始密码在这里 cat /Users/chenpeisong/.jenkins/secrets/initialAdminPassword 8. jenkins自动化部署vuehttps://e.coding.net/s18334787934/jenkinsdemo.gitcd /var/jenkins_home/workspace/test #进入test项目目录1234567npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedrivernpm installnpm run buildcd distrm -rf test.tar.gz #删除上次打包生成的压缩文件tar -zcvf test.tar.gz * #把生成的项目打包成test方便传输到远程服务器cd ../ https://blog.csdn.net/jonsonler/article/details/81317352https://blog.csdn.net/ansu2009/article/details/83584796 9.使用 Jenkins 构建 Coding 项目https://blog.csdn.net/zxb730916/article/details/80913579 10.本机Jenkins实现外网访问 外网访问内网Jenkins 用于设置coding WebHook需要下载java环境https://www.cnblogs.com/wisdom-projects/p/11184983.html本机访问链接http://holer.org:65530/job/test/configure]]></content>
      <categories>
        <category>2020Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一个vue-cli3项目的搭建]]></title>
    <url>%2F2019%2F04%2F01%2F2019Note%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAvue-cli3%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[vue-cli3快速创建项目 https://www.jianshu.com/p/5e13bc2eb97c1. 安装axios请求处理 vue中Axios的封装与API接口的管理详解 https://www.jb51.net/article/145341.htm1npm install axios 2. vue-cli里面.和@的区别 https://segmentfault.com/q/1010000009800289https://blog.csdn.net/qq_35366269/article/details/85232899 3. vue-cli3 安装sass12npm install node-sass --save-devnpm install sass-loader --save-dev ==安装完 切记 重新开启 npm run serve 服务== 4. vue-cli 3 关闭 eslinthttps://blog.51cto.com/zhuxianzhong/2311226?source=dra 5. 安装 babel-polyfill1npm install --save babel-polyfill 6. 基于vue仿淘宝滑动验证码https://www.jianshu.com/p/f5bf9ba0b27e 7. Vue-cli3.0怎么配置在打包时候去掉console打印的信息https://forum.vuejs.org/t/vue-cli3-0-console/43788https://www.npmjs.com/package/babel-plugin-transform-remove-console 1npm install babel-plugin-transform-remove-console --save 1234567891011const plugins = []if (process.env.NODE_ENV === 'production') &#123; plugins.push('transform-remove-console')&#125;module.exports = &#123; presets: [ '@vue/app' ], plugins&#125; 8. 如何自如地使用npm在项目中安装、删除模块包https://blog.csdn.net/xum222222/article/details/81560809 9. vue-waterfall2 图片布局自适应插件https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FRise-Devin%2Fvue-waterfall2 10. vue在data引入本地图片的两种方法https://blog.csdn.net/Ajaxguan/article/details/81948829 11. css3 动画http://www.w3school.com.cn/cssref/pr_keyframes.asp1234567891011121314151617181920212223@keyframes mymove&#123;from &#123;top:0px;&#125;to &#123;top:200px;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123;from &#123;top:0px;&#125;to &#123;top:200px;&#125;&#125;@-webkit-keyframes mymove /* Safari 和 Chrome */&#123;from &#123;top:0px;&#125;to &#123;top:200px;&#125;&#125;@-o-keyframes mymove /* Opera */&#123;from &#123;top:0px;&#125;to &#123;top:200px;&#125;&#125; 12. js判断是否存在当前元素得classname123456789 if( obj.className.includes('active') )&#123; // 存在 &#125;else&#123; // 不存在 obj.classList.add('active'); setTimeout(()=&gt;&#123; obj.classList.remove('active'); &#125;,1500)&#125; 13. vue router-link返回上一页https://router.vuejs.org/zh/guide/#javascript1234567&lt;span @click=&quot;this.$router.go(-1)&quot;&gt;返回&lt;/span&gt;&lt;span @click=&quot;goBack()&quot;&gt;返回&lt;/span&gt;goBack () &#123; window.history.length &gt; 1 ? this.$router.go(-1) : this.$router.push(&apos;/&apos;)&#125; 上面的代码其实就可以满足我们返回上一页面的需求，但是如果我们是从别的地方打开此链接的时候事实上是没有上一页的，为了提升用户的体验，我们可以使用js来控制当我们点击返回按钮时所进行的操作，https://www.cnblogs.com/daikefeng/p/6946517.html12345678// 退出 goBack () &#123; if (document.referrer === &apos;&apos;) &#123; this.$router.push(&apos;/&apos;) &#125;else&#123; this.$router.go(-1) &#125; &#125;, 上面的意思是当我们点击的时候进行判断，如果document.referrer为空字符串，它就会返回首页,这样对用户的体验来说也比较好。referrer:referrer 属性可返回载入当前文档的文档的 URL，其实就是上一个页面。 14. mock模拟数据https://www.cnblogs.com/jasonwang2y60/p/7302449.htmlhttps://linjinze999.github.io/vue-llplatform/login.html#%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A31npm install mockjs --save-dev 15. input写法必须使用padding width 100%;不许使用margin 错误正确// 兼容 1600900 1368768版本尺寸@media screen and (max-height: 900px) { 16. 安装qrcodehttps://github.com/scopewu/qrcode.vue/blob/HEAD/README-zh_cn.md 17. 路由懒加载写法普通写法12import ArtWorkInfo from &apos;@/views/artwork/ArtWorkInfo.vue&apos;component: ArtWorkClassIfy, 懒加载写法1component:()=&gt;import(/* webpackChunkName:&apos;打包文件得名字&apos; */ &apos;@/views/artwork/ArtWorkClassIfy&apos;),]]></content>
      <categories>
        <category>2019Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目目录文件说明(自己项目)]]></title>
    <url>%2F2019%2F04%2F01%2F2019Note%2Fvue%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E(%E8%87%AA%E5%B7%B1%E9%A1%B9%E7%9B%AE)%2F</url>
    <content type="text"><![CDATA[https://www.jianshu.com/p/dcde5ab4cfd9 使用dos的tree命令输出文件夹树 http://www.cnblogs.com/dkplus/p/8487330.html用dos的tree命令就可以实现文件夹树状图的输出，不过目前仅能输出为.txt文件 方法如下：开始-&gt;运行 输入cmd打开命令控制台切换到你要显示的列表文件夹 比如 输入 d: 切换到d盘输入 tree &gt;c:\dirlist.txt就可以生成文件夹的树型列表tree /f &gt;c:\dirlist.txt 可以生成文件夹和文件的树型列表这个时候就可以在c盘生成你要的文本了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960目录文件说明 ├─dist 生产环境打包目录`npm run buil`├─test 预发布环境（测试）打包目录`npm run test`├─public 项目根目录 vuecli3构建基础模块--public favicon.ico index.html 入口页面├─src 项目源码目录 vuecli3构建基础模块--src │ App.vue 根组件 │ main.js 入口js │ ├─assets 项目公用资源目录（图片，ico） ├─config 项目公用配置目录 │ api.js 接口文档合集 │ axios.js axios请求配置 │ mock.js mock数据 │ reg.js 项目正则整理 │ storage.js cookie.storage方法整理 ├─router 项目路由目录 │ │ index.js 路由主入口文件 │ │ │ └─modules 路由模块 │ artist.js 艺术家路由.js │ artwork.js 艺术品路由.js │ loginres.js 登录注册路由.js │ ├─store 项目vuex目录 │ index.js vuex主文件 │ └─views 项目页面模块目录 ├─common 公用组件模块 │ │ 404.vue 公用组件404页面 │ │ DywASearch.vue │ │ DywPage.vue │ │ Footer.vue 公用组件页面尾部 │ │ Header.vue 公用组件页面头部 │ │ │ └─images 公用组件图片存放 │ ├─index 页面主模块 │ Index.vue index.vue │ ├─home 首页模块 │ └─模块name 模块 │ ├─comments 模块组件 │ ├─css 模块样式 │ ├─js 模块逻辑js │ └─images 模块图片 │ └─ ├ .editorconfig ├ .env 配置生产环境 ├ .env.test 配置测试环境├ .gitignore├ babel.config.js babel ├ package-lock.json ├ package.json npm包配置文件，里面定义了项目的npm脚本，依赖包等信息├ README.md├ vue.config.js 本地跨域代理]]></content>
      <categories>
        <category>2019Note</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序笔记]]></title>
    <url>%2F2018%2F09%2F14%2FME-%E7%AC%94%E8%AE%B0%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[https://www.baidufe.com/item/f07a3be0b23b4c9606bb.html https://www.cnblogs.com/tiggerinchengdu/p/4511989.html /*点击体验评价里的图片查看大图*/ $(document).on(&apos;click&apos;,&apos;.goods-details-evaluate-con-bottom img&apos;,function () { var imgs = new Array(); $.each($(this).parents(&apos;.goods-details-evaluate-con-bottom&apos;).find(&apos;img&apos;),function(i,v){ imgs.push($(v).attr(&apos;src&apos;)); }); WeixinJSBridge.invoke(&apos;imagePreview&apos;, { &apos;current&apos;: $(this).attr(&apos;src&apos;), &apos;urls&apos;: imgs }); }); 1：引入外部css1@import &quot;../ship/ship.wxss&quot;; 2：无法使用背景图片，需要使用线上资源。 3：保存数据123this.setData(&#123; num : 2&#125;) 4：尽量避免在小地方用ID名称 因为id可以随着数据的 e.currentTarget.id或者直接在标签里面写 data-id = “xx” 原型链（结构树）中会出现一个datatest的对象 5：block操作属性元素之间没办法嵌套 block 6：获取链接中id参数12345onload:function(options)&#123;this.setData(&#123; channel_id: options.id &#125;)&#125; 商城测试id wx24ab9d9446d62d40 飞鸟测试id wxf5b29fa90a095773 771142016 商城正式id wxc018da54aac7ea29 809279228]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css笔记]]></title>
    <url>%2F2018%2F03%2F01%2FME-%E7%AC%94%E8%AE%B0%2Fcss%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[CSS1.字体换行 12word-break: break-all; //包括数字word-break: break-word; //不包括数字 2.下划线 1text-decoration: line-through; 3.控制文字在一行并且出现… 一行变省略 1234overflow: hidden;text-overflow: ellipsis;white-space: nowrap;display: block; 4.控制文字在多行显示并且出现… 多行变二条字体的省略 123456display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2;overflow: hidden;word-break: break-all;text-overflow: ellipsis; 5.去除重复的线条 123.nolayer &#123;margin-bottom: -1px;&#125; 6.不知道盒子的宽高怎么让他垂直居中 12345678910111213父元素&#123;text-align:center&#125;元素本身&#123;vertical-align:middledisplay:inline-block&#125;元素本身::after&#123;vertical-align:middledisplay:inline-blockheight:100%content:''&#125; 7.清除浮动的要点： 12345678.outer &#123;zoom:1;&#125; /*==for IE6/7 Maxthon2==*/.outer :after &#123;clear:both;content:'.';display:block;width: 0;height: 0;visibility:hidden;&#125;::after&#123;content:"";clear:both;display:table;&#125;/*其中clear:both;指清除所有浮动；content: '.'; display:block;对于FF/chrome/opera/IE8不能缺少，其中content（）可以取值也可以为空。visibility:hidden;的作用是允许浏览器渲染它，但是不显示出来，这样才能实现清除浮动。*/ 8.垂直居中 123456789.center &#123;position: absolute;top: 50%;left: 50%;-ms-transform: translate(-50%,-50%);-moz-transform: translate(-50%,-50%);-o-transform: translate(-50%,-50%);transform: translate(-50%,-50%);&#125; 9.去除input type=number的上下箭头样式 12345678/*在chrome下：*/input::-webkit-outer-spin-button,input::-webkit-inner-spin-button&#123;-webkit-appearance: none !important;margin: 0;&#125;/*Firefox下：*/input[type="number"]&#123;-moz-appearance:textfield;&#125; 10.一个1920_900的大图，在1024_768的分辨率只能显示一部分，希望仍居中显示 1234.bg&#123;width: 100%;background-position: 50% 50%;&#125; 11.剪裁图像： 1234img&#123;position:absolute;clip:rect(0px,60px,200px,0px);&#125; 12.实现div两端对齐 12345678910div&#123;display: -webkit-box;display: -webkit-flex;display: -ms-flexbox;display: flex;-webkit-box-pack: justify;-webkit-justify-content: space-between;-ms-flex-pack: justify;justify-content: space-between;&#125; 13.如何透过CSS控制文章内的标点符号位置 1234.article&#123;text-align: justify; /*两端对齐*/word-break: break-all; /*控制标点不在第一个字显示*/&#125; 14.滚动条样式修改 12345678910111213*::-webkit-scrollbar-track //轨道部分；&#123; background-color: white;&#125;*::-webkit-scrollbar //定义了滚动条整体的样式；&#123; width: 0; background-color: rgba(0,0,0,0.3);&#125;*::-webkit-scrollbar-thumb //滑块部分；&#123; background-color: #e4e4e4;&#125; 15.图片居中 123456789101112131415161718192021/*如果是正方形*/.wrap&#123;width: 70px;height: 70px;overflow: hidden;border-radius: 50%position:relative;&#125;;/*适用于图片为长方形 使用*/.wrap img &#123;display: block;position: absolute;top: 50%;left: 50%;width: 100%;height: 100%;-ms-transform: translate(-50%,-50%);-moz-transform: translate(-50%,-50%);-o-transform: translate(-50%,-50%);transform: translate(-50%,-50%);&#125; 16.网页在Safari快速滚动和回弹的原理： -webkit-overflow-scrolling : touch;的实现 现在很多for Mobile的HTML5网页内都有快速滚动和回弹的效果，看上去和原生app的效率都有得一拼。 http://blog.csdn.net/hursing/article/details/9186199 17.今天发现移动端点击事件无法生效，但是滑动可以 然后就查一些资料，得到了一些理论知识。最重要的一个就是事件流的概念，点击事件可以分解成多个事件。 在移动端，手指点击一个元素，会经过：touchstart –&gt; touchmove -&gt; touchend –》click。 事件流本身会持续进行下去的。 http://www.myexception.cn/web/1600832.html 18.网页宽高clientWidth clientHeight获得数值不对的问题 当网页内容撑不满一屏时，通过以下代码获得整个网页高度会有问题 document.body.clientHeight; document.body.clientWidth; 得到的宽高不对，可能是因为html与body标签缺一个样式：height:100% 12345678html&#123;height: 100%;overflow: hidden;//overflow去掉滚动条&#125;body&#123;height: 100%;&#125; 19.手机浏览器上，给body增加overflow:hidden;width:100%;height:100% 无效的问题 1231、body加position:fixed;2、给要滚动的元素添加一个父级，设定高度，overflow：auto；3、html,body&#123;height:100%;overflow:hidden&#125; 20.css修改input、textarea标签placeholder属性默认文字颜色 123456789101112131415161718192021222324input::-webkit-input-placeholder &#123; /* WebKit browsers */ color: #fff;&#125;input:-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */ color: #fff;&#125;input::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ color: #fff;&#125;input::-ms-input-placeholder &#123; /* Internet Explorer 10+ */ color: #fff;&#125;input::-webkit-input-placeholder &#123; /* placeholder颜色 */ color: #aab2bd; /* placeholder字体大小 */ font-size: 14px; /* placeholder位置 */ /* text-align: right; */&#125; 21.四周阴影 123-webkit-box-shadow: #c5c5c5 0px 0px 10px; -moz-box-shadow: #c5c5c5 0px 0px 10px; box-shadow: #c5c5c5 0px 0px 10px; 22.一个base64图片的微信加载样式 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class="weui-loadmore"&gt;&lt;i class="weui-loading"&gt;&lt;/i&gt;&lt;span class="weui-loadmore__tips"&gt;正在加载&lt;/span&gt;&lt;/div&gt;.weui-loading &#123; width:20px; height:20px; display: inline-block; vertical-align: middle; animation: weuiLoading 1s steps(12, end) infinite; background: transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHBhdGggZmlsbD0ibm9uZSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTlFOUU5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgLTMwKSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iIzk4OTY5NyIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzMCAxMDUuOTggNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjOUI5OTlBIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDYwIDc1Ljk4IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0EzQTFBMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSg5MCA2NSA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNBQkE5QUEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDU4LjY2IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0IyQjJCMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgxNTAgNTQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjQkFCOEI5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDE4MCA1MCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDMkMwQzEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTE1MCA0NS45OCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDQkNCQ0IiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTEyMCA0MS4zNCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNEMkQyRDIiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTkwIDM1IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0RBREFEQSIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgtNjAgMjQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTJFMkUyIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKC0zMCAtNS45OCA2NSkiLz48L3N2Zz4=) no-repeat; background-size: 100%; &amp;.weui-loading_transparent&#123; background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 100 100'%3E%3Cpath fill='none' d='M0 0h100v100H0z'/%3E%3Crect xmlns='http://www.w3.org/2000/svg' width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.56)' rx='5' ry='5' transform='translate(0 -30)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.5)' rx='5' ry='5' transform='rotate(30 105.98 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.43)' rx='5' ry='5' transform='rotate(60 75.98 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.38)' rx='5' ry='5' transform='rotate(90 65 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.32)' rx='5' ry='5' transform='rotate(120 58.66 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.28)' rx='5' ry='5' transform='rotate(150 54.02 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.25)' rx='5' ry='5' transform='rotate(180 50 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.2)' rx='5' ry='5' transform='rotate(-150 45.98 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.17)' rx='5' ry='5' transform='rotate(-120 41.34 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.14)' rx='5' ry='5' transform='rotate(-90 35 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.1)' rx='5' ry='5' transform='rotate(-60 24.02 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='rgba(255,255,255,.03)' rx='5' ry='5' transform='rotate(-30 -5.98 65)'/%3E%3C/svg%3E"); &#125;&#125;@-webkit-keyframes weuiLoading &#123; 0% &#123; transform: rotate3d(0, 0, 1, 0deg); &#125; 100% &#123; transform: rotate3d(0, 0, 1, 360deg); &#125;&#125;@keyframes weuiLoading &#123; 0% &#123; transform: rotate3d(0, 0, 1, 0deg); &#125; 100% &#123; transform: rotate3d(0, 0, 1, 360deg); &#125;&#125; 23、去除table表格的间隙 1border-collapse: collapse; 24、CSS3 filter(滤镜) 属性 修改所有图片的颜色为黑白 (100% 灰度): 1234img &#123; -webkit-filter: grayscale(100%); /* Chrome, Safari, Opera */ filter: grayscale(100%);&#125; 25、vertical-align: 属性值 12345678910baseline 默认。元素放在父元素的基线上。sub 垂直对齐文本的下标super 垂直对齐文本的上标top 把元素的顶端与行内最高元素的顶端对齐text-top 把元素的顶端与父元素字体的顶端对齐middle 把元素放在父元素的中部bottom 把元素的顶端与父元素字体的底端对齐length% 使用line-height属性的百分比来排列此元素，允许使用负值inherit 规定从父元素vertical-align继承 26、pointer-events: none; 12345auto：与pointer-events属性未指定时的表现效果相同。在svg内容上与visiblepainted值相同none：元素永远不会成为鼠标事件的target。但是，当其后代元素的pointer-events属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶触发父元素的事件侦听器。其他值只能应用在SVG上。 27、怎麼让一个未知宽高元素变为正方形1234567891011父元素:&#123; width:x; height:y; position:relative;&#125;子元素:&#123; position:absolute; width:20%; padding-top:20%; border-radius:50%;&#125; 28、一个阴影效果 适用于图片底部需要放置内容的地方12background: linear-gradient(bottom, rgba(0,0,0,0.7), rgba(255,255,255,0));background: -webkit-linear-gradient(bottom, rgba(0,0,0,0.7), rgba(255,255,255,0)); 29、js获取上传图片真实的尺寸大小和存储大小12http://blog.csdn.net/u014236259/article/details/52885591让图片按比例缩放 30、输入框类型123456789101112131415textarea:focus, input[type=&quot;text&quot;]:focus, input[type=&quot;password&quot;]:focus, input[type=&quot;datetime&quot;]:focus, input[type=&quot;datetime-local&quot;]:focus, input[type=&quot;date&quot;]:focus, input[type=&quot;month&quot;]:focus, input[type=&quot;time&quot;]:focus, input[type=&quot;week&quot;]:focus, input[type=&quot;number&quot;]:focus, input[type=&quot;email&quot;]:focus, input[type=&quot;url&quot;]:focus, input[type=&quot;search&quot;]:focus, input[type=&quot;tel&quot;]:focus, input[type=&quot;color&quot;]:focus, 31、div模拟input输入框 contenteditable=”true”123456789101112&lt;!-- html --&gt;&lt;div class=&quot;test&quot; contenteditable=&quot;true&quot; data-text=&quot;和主播一起聊天-.-&quot;&gt;&lt;/div&gt;&lt;!-- 模拟 placeholder --&gt;&lt;style&gt;.test:before &#123; content: attr(data-text);&#125;.input_mnzz:empty:before &#123; content: attr(data-text); color: #bbb;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js日常笔记]]></title>
    <url>%2F2018%2F03%2F01%2FME-%E7%AC%94%E8%AE%B0%2Fjs%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,minimal-ui&quot;&gt;注意：viewport 后面加上 minimal-ui 在safri 体现效果&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- UC强制全屏 --&gt; &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;!-- UC应用模式 --&gt; &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; JS、JQ1.https转为http 1234var targetProtocol = "http:";if (window.location.protocol != targetProtocol)window.location.href = targetProtocol +window.location.href.substring(window.location.protocol.length) 2.不同HTML层都被使用不同的颜色添加了一个高亮的边框 123转载自&lt;http://buluo.qq.com/p/detail.html?bid=314687&amp;pid=3951568-1476250690&gt;调试高亮[].forEach.call($$("*"),function(a)&#123;a.style.outline="1px solid #"+(~~(Math.random()*(1&lt;&lt;24))).toString(16) &#125;) 3.两种ajax请求方式 (已放入别的文章) 4.测试一段代码的执行时间 12console.timeEnd('aa')console.time('aa') 5.判断是iOS手机还是andorid手机 进行控制”关注按钮”的位置 解决安卓手机视频最优先 123456var ua = navigator.userAgent.toLowerCase();if(/iphone|ipad|ipod/.test(ua))&#123; alert("iphone");&#125;else if(/android/.test(ua))&#123; alert("android");&#125;; 6.日历计算 输出2017-06-01 - 2018-12-01的值 123456789101112131415161718date=new Date();var year=date.getFullYear();var month=date.getMonth()+1;function cc()&#123;for(var i=year; i&lt;2099; i++)&#123; if(i===year)&#123; var j=month; &#125;else&#123; var j=1; &#125; for( j; j&lt;13;j++)&#123; if( $('.dataselect li').length &lt; 13)&#123; $('.dataselect').append('&lt;li&gt;'+i+'-'+j+'&lt;/li&gt;') &#125; &#125;&#125;&#125;cc(); 7.// js判断滚动条是否停止状态 123456789101112131415161718//根据上一秒的值去对比当前时间的scrollTop如果没变则设置为0var pl_Top = 0; // 上次滚动条到顶部的距离 var interval = null; // 定时器 // 设置评论区的高度每隔1秒设置scollTop为0$('.pilun').scroll(function()&#123;if(interval == null) &#123; // 未发起时，启动定时器，1秒1执行 interval = setInterval('pl_Topjs()',1000)&#125; &#125;)function pl_Topjs()&#123;if( $('.pilun').scrollTop() == pl_Top) &#123; clearInterval(interval) $('.pilun').scrollTop(0) interval = null&#125; else &#123;pl_Top = $('.pilun').scrollTop()&#125;&#125; 1234567891011121314151617181920212223242526&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;&lt;title&gt;下拉滚动条滚到底部了吗？&lt;/title&gt;&lt;script src="http://cdn.bootcss.com/jquery/2.2.3/jquery.min.js"&gt;&lt;/script&gt;&lt;script language="javascript"&gt;$(document).ready(function ()&#123; var nScrollHight = 0; //滚动距离总长(注意不是滚动条的长度) var nScrollTop = 0; //滚动到的当前位置 var nDivHight = $("#div1").height(); $("#div1").scroll(function()&#123; nScrollHight = $(this)[0].scrollHeight; nScrollTop = $(this)[0].scrollTop; var paddingBottom = parseInt( $(this).css('padding-bottom') ),paddingTop = parseInt( $(this).css('padding-top') ); if(nScrollTop + paddingBottom + paddingTop + nDivHight &gt;= nScrollHight) alert("滚动条到底部了"); &#125;);&#125;);&lt;/script&gt;&lt;body&gt;&lt;div id="div1" style="overflow-y:auto; overflow-x:hidden; height:500px;"&gt;&lt;div style="background-color:#ccc; height:750px;"&gt;IE 和 FF 下测试通过&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8.判断网络连接 123456789if(window.navigator.onLine==true) &#123; alert("首次 -- 已连接");&#125;else &#123; alert("首次 -- 未连接");&#125;window.addEventListener("online", online, false);window.addEventListener("offline", offline, false);function online() &#123; alert("重新连接"); &#125;function offline() &#123; alert("连接断开"); &#125; 9.传一个对象给php1234567var student = &#123; 'info': []&#125;;$("input[name='student']:checked").each(function (i, n) &#123; student['info'].push(n.value);&#125;);console.log(student) 10.原生提示框 // 判断刷新页面 123456789101112131415161718 if (confirm("确定删除视频吗 ?"))&#123; //给出一个警告框，点确定时就执行里面的代码 add_attr('del',vid,src) &#125; window.onbeforeunload = function()&#123;...&#125; Onunload，onbeforeunload都是在刷新或关闭时调用，可以在'&lt;script&gt;&lt;/script&gt;script&gt;'脚本中通过window.onunload来指定或者在&lt;body&gt;里指定。区别在于onbeforeunload在onunload之前执行，它还可以阻止onunload的执行。Onbeforeunload也是在页面刷新或关闭时调用，Onbeforeunload是正要去服务器读取新的页面时调用，此时还没开始读取；而onunload则已经从服务器上读到了需要加载的新的页面，在即将替换掉当前页面时调用。Onunload是无法阻止页面的更新和关闭的。而 Onbeforeunload 可以做到。页面加载时只执行onload页面关闭时先执行onbeforeunload，最后onunload页面刷新时先执行onbeforeunload，然后onunload，最后onload。一个判断页面是否真的关闭和刷新的好方法：window.onbeforeunload=function ()&#123;alert("===onbeforeunload===");if(event.clientX&gt;document.body.clientWidth &amp;&amp; event.clientY &lt; 0 || event.altKey)&#123; alert("你关闭了浏览器");&#125;else&#123; alert("你正在刷新页面");&#125;&#125; 12&lt;a href="javascript:if(confirm('确定删除视频吗'))window.location = 'index.php?app=gcategory;"&gt;&lt;/a&gt; 11.根据窗口大小调整视图 1$(window).resize(function () &#123;&#125;) 12.用 Unicode字符范围判断字节 1234567891011121314151617以下方法是用于统计输入字符串的长度，如果是汉字，则字符串长度加2 ；否则字符串长度加1。function chkstrlen(str)&#123;console.log(str)var strlen = 0;for(var i = 0;i &lt; str.length; i++)&#123;if(str.charCodeAt(i) &gt; 255) &#123;//如果是汉字，则字符串长度加2 strlen += 2;&#125; else &#123; strlen++; &#125;&#125;console.log(strlen)return strlen;&#125;var cc ='1111你好444'chkstrlen(cc) 13.是否是图片 123456789101112function checkPhoto(str)&#123;console.log(str)var type="";if( str !='')&#123;type= str.match(/^(.*)(\.)(.&#123;1,8&#125;)$/)[3];type= type.toUpperCase();&#125;if( type!="JPEG" &amp;&amp; type!="PNG" &amp;&amp; type!="JPG" &amp;&amp; type!="GIF")&#123;zeroModal.error('上传图片类型错误');return false;&#125;&#125; 14.js获取当前日期时间 转为”yyyy-MM-dd HH:MM:SS” 1234567891011121314151617function getNowFormatDate() &#123;var date = new Date();var seperator1 = "-";var seperator2 = ":";var month = date.getMonth() + 1;var strDate = date.getDate();if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123;month = "0" + month;&#125;if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123;strDate = "0" + strDate;&#125;var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate + " " + date.getHours() + seperator2 + date.getMinutes() + seperator2 + date.getSeconds();return currentdate;&#125; 15.监控回车发送消息 123456789101112131415161718192021222324//控制输入框 textarea 回车不换行&lt;textarea class="test" id="test"&gt;&lt;/textarea&gt; &lt;script type="text/javascript"&gt; // var test= document.getElementById("test");var test1 = $('.test').get(0);console.log(test,test1)test1.onkeydown = function(e)&#123; send(e); &#125;// test.onkeydown = function(e)&#123; // send(e); // &#125; function send(e)&#123; var code;if (!e) var e = window.event; if (e.keyCode) code = e.keyCode; else if (e.which) code = e.which; if(code==13 &amp;&amp; window.event)&#123; e.returnValue = false; &#125;else if(code==13)&#123; e.preventDefault(); &#125; &#125; &lt;/script&gt; 16.网页调用qq 1http://wpa.qq.com/msgrd?v=3&amp;uin=3314523834&amp;site=qq&amp;menu=yes 17.textarea中屏蔽回车默认换行 多行文本框textarea.清除默认回车事件 12345678910111213141516171819&lt;textarea id= "test"&gt;&lt;/textarea&gt; &lt;script type="text/javascript"&gt; var test= document.getElementById("test"); test.onkeydown = function(e)&#123; send(e); &#125; function send(e)&#123; var code; if (!e) var e = window.event; if (e.keyCode) code = e.keyCode; else if (e.which) code = e.which; if(code==13 &amp;&amp; window.event)&#123; e.returnValue = false; &#125;else if(code==13)&#123; e.preventDefault(); &#125; &#125; &lt;/script&gt; 18.页面刷新 1234window.location.reload()刷新当前页面.parent.location.reload()刷新父亲对象（用于框架）opener.location.reload()刷新父窗口对象（用于单开窗口）top.location.reload()刷新最顶端对象（用于多开窗口） 20.关于日期 不明白 为什么不用getDay表示日子 getweek表示星期哦 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var 日期 = new Date();var 年 = 日期.getFullYear();var 月 = 日期.getMonth();var 日 = 日期.getDate();var 星期 = 日期.getDay(); var 小时 = 日期.getHours();var 分 = 日期.getSeconds();var 毫秒 = 日期.getMillSeconds();Date() 返回当日的日期和时间。getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。getMonth() 从 Date 对象返回月份 (0 ~ 11)。getFullYear() 从 Date 对象以四位数字返回年份。getYear() 请使用 getFullYear() 方法代替。getHours() 返回 Date 对象的小时 (0 ~ 23)。getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。getTime() 返回 1970 年 1 月 1 日至今的毫秒数。getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。parse() 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。setMonth() 设置 Date 对象中月份 (0 ~ 11)。setFullYear() 设置 Date 对象中的年份（四位数字）。setYear() 请使用 setFullYear() 方法代替。setHours() 设置 Date 对象中的小时 (0 ~ 23)。setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。setTime() 以毫秒设置 Date 对象。setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。toSource() 返回该对象的源代码。toString() 把 Date 对象转换为字符串。toTimeString() 把 Date 对象的时间部分转换为字符串。toDateString() 把 Date 对象的日期部分转换为字符串。toGMTString() 请使用 toUTCString() 方法代替。toUTCString() 根据世界时，把 Date 对象转换为字符串。toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。valueOf() 返回 Date 对象的原始值。 21: json数据可视化 123456789101112131415161718JSON.parse用于从一个字符串中解析出json对象,如var str = &apos;&#123;&quot;name&quot;:&quot;huangxiaojian&quot;,&quot;age&quot;:&quot;23&quot;&#125;&apos;结果：JSON.parse(str)Objectage: &quot;23&quot;name: &quot;huangxiaojian&quot;__proto__: ObjectJSON.stringify()用于从一个对象解析出字符串，如var a = &#123;a:1,b:2&#125;结果：JSON.stringify(a)&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&quot; 22: 清除所有cookie 123456789function clearAllCookie() &#123; var date=new Date(); date.setTime(date.getTime()-10000); var keys=document.cookie.match(/[^ =;]+(?=\=)/g); if (keys) &#123; for (var i = keys.length; i--;) document.cookie=keys[i]+&quot;=0; expire=&quot;+date.toGMTString()+&quot;; path=/&quot;; &#125; &#125; 23：按enter键禁止换行 123456789ue.addListener(&quot;keydown&quot;, function (type, event) &#123; if (event.ctrlKey &amp;&amp; event.which == 13) &#123; // 判断ctrl 回车 发送 if (event.which == 13) &#123; // 禁止换行 event.cancelBubble = true; event.preventDefault(); event.stopPropagation(); &#125; &#125;&#125;) 24：一个简单的倒计时 123456789101112131415161718192021222324// 一天 = 24 h = 1440 m = 86400 s = 86400 000ms // 一小时 // 一分钟 // 秒var millseconds = 97879;function timeCom(times) &#123; var _day = 00; var _hour = 00; var _seconds = 00; var _millseconds = 00; var val = times; setInterval(function () &#123; if (val &gt; 0) &#123; _day = parseInt(val / 86400); _hour = parseInt((val / 3600) - (24__day)); _seconds = parseInt((val / 60) - (_day_1440) - (_hour_60)); _millseconds = parseInt(val - (_day_86400) - (_hour_3600) - (_seconds_60)); (_day &lt; 10) ? _day = &apos;0&apos; + _day : _day; (_hour &lt; 10) ? _hour = &apos;0&apos; + _hour : _hour; (_seconds &lt; 10) ? _seconds = &apos;0&apos; + _seconds : _seconds; (_millseconds &lt; 10) ? _millseconds = &apos;0&apos; + _millseconds : _millseconds; console.log(_day, _hour, _seconds, _millseconds); val--; &#125; &#125;, 1000)&#125;timeCom(millseconds) 25：JQUERY操作CHECKBOX 第二次无法选中的问题 用JQuery做CheckBox全选和反选的时候，遇到一个问题。当用JQ控制全选，全取消一次以后，再次点击全选，发现代码变了，但是CheckBox没有处于选中状态。 百度后得知： 我使用的方法是 $(“#id”).attr(“checked”,true); 方式，jQuery API明确说明，1.6+的jQuery要用prop，尤其是checkBox的checked的属性的判断。因此修改为 123$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;);$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;disabled&quot;, false);$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;, true); 26：js unicode转中文 1unescape(str.replace(/\u/g, &apos;%u&apos;)) 27： JS格式化 Thu Dec 07 2017 14:00:43 GMT+0800 (中国标准时间) 转为 2017-12-07 1234567891011121314//2017-6-13 14:35:31var d = new Date(&apos;Thu Dec 07 2017 14:00:43 GMT+0800 (中国标准时间)&apos;);youWant=d.getFullYear() + &apos;-&apos; + (d.getMonth() + 1) + &apos;-&apos; + d.getDate() + &apos; &apos; + d.getHours() + &apos;:&apos; + d.getMinutes() + &apos;:&apos; + d.getSeconds();//2017-06-13 14:35:31var date_time = new Date(&apos;Thu Dec 07 2017 14:00:43 GMT+0800 (中国标准时间)&apos;);var month = parseInt(date_time.getMonth() + 1);( month &lt; 10)? month = &apos;0&apos;+month:month; var day = parseInt(date_time.getDate());(day &lt; 10)?day = &apos;0&apos;+day:day; var hours = parseInt(date_time.getHours());(hours &lt; 10)?hours = &apos;0&apos;+hours:hours;var minutes = parseInt(date_time.getMinutes());(minutes &lt; 10)?minutes = &apos;0&apos;+minutes:minutes;var seconds = parseInt(date_time.getSeconds());(seconds &lt; 10)?seconds = &apos;0&apos;+seconds:seconds;date = date_time.getFullYear() + &apos;-&apos; + month + &apos;-&apos; + day + &apos; &apos; + hours + &apos;:&apos; + minutes + &apos;:&apos; + seconds; 28：for 循环 和 each跳出循环的区别 each中要实现break和continue的功能的话，要使用其它的方式 break—用return false; continue –用return ture; break和continue的区别和作用 break和continue都是用来控制循环结构的，主要是停止循环。 1.break 有时候我们想在某种条件出现的时候终止循环而不是等到循环条件为false才终止。 这是我们可以使用break来完成。break用于完全结束一个循环，跳出循环体执行循环后面的语句。 2.continue continue和break有点类似，区别在于continue只是终止本次循环，接着还执行后面的循环，break则完全终止循环。 可以理解为continue是跳过当次循环中剩下的语句，执行下一次循环。 29：数组中对象遍历不能直接赋值给另一个v 1234567891011正确var _new_data = &#123; &apos;spec_id&apos;: v.spec_id, &apos;spec_name&apos;: v.spec_name, &apos;spec_nature_array&apos;: [], &apos;spec_type&apos;: v.spec_type&#125;;不正确var _new_data = v;var _new_data = spec_nature[i];这样会改变原数组内容 30： 限制只能输入数字 onkeyup=”inputKeyUpNumberValue(this);” 键盘按下之后触发 onafterpaste=”inputAfterPasteNumberValue(this);” 粘贴之后触发 123456789101112131415161718/** * input 只能输入数字 */ function inputKeyUpNumberValue(event) &#123; if (event.value.length == 1) &#123; event.value = event.value.replace(/[^0-9]/g, ''); &#125; else &#123; event.value = event.value.replace(/\D/g, ''); &#125; &#125; function inputAfterPasteNumberValue(event) &#123; if (event.value.length == 1) &#123; event.value = event.value.replace(/[^0-9]/g, ''); &#125; else &#123; event.value = event.value.replace(/\D/g, ''); &#125; &#125; 31、定位元素在鼠标指向元素的上方 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748网页被卷起来的高度/宽度（即浏览器滚动条滚动后隐藏的页面内容高度）(javascript) document.documentElement.scrollTop //firefox(javascript) document.documentElement.scrollLeft //firefox(javascript) document.body.scrollTop //IE(javascript) document.body.scrollLeft //IE(jqurey) $(window).scrollTop()(jqurey) $(window).scrollLeft()网页工作区域的高度和宽度 (javascript) document.documentElement.clientHeight// IE firefox (jqurey) $(window).height()元素距离文档顶端和左边的偏移值 (javascript) DOM元素对象.offsetTop //IE firefox(javascript) DOM元素对象.offsetLeft //IE firefox(jqurey) jq对象.offset().top(jqurey) jq对象.offset().left获取页面元素距离浏览器工作区顶端的距离 页面元素距离浏览器工作区顶端的距离 = 元素距离文档顶端偏移值 - 网页被卷起来的高度 即： 页面元素距离浏览器工作区顶端的距离 = DOM元素对象.offsetTop - document.documentElement.scrollTop /** * 鼠标浮上图片，显示 */ $(document).on(&quot;mouseenter&quot;, &apos;#sui-spec-details-list .det-spec-nav-img&apos;, function() &#123; var src = $(this).attr(&quot;src&quot;); var top = $(this).offset().top - $(window).scrollTop(); var left = $(this).offset().left - $(window).scrollLeft(); $(&apos;.popover-content img&apos;).attr(&apos;src&apos;, src); var height = $(&apos;.popover&apos;).height(); var width = $(&apos;.popover&apos;).width(); $(&apos;.popover&apos;).css(&#123; &apos;top&apos;: top - height - 30, &apos;left&apos;: left - width / 2, &apos;opacity&apos;: 1, &apos;display&apos;: &apos;block&apos; &#125;); &#125;); /** * 鼠标离开图片时，隐藏 */ $(document).on(&quot;mouseleave&quot;, &apos;#sui-spec-details-list .det-spec-nav-img&apos;, function() &#123; $(&apos;.popover-content img&apos;).attr(&apos;src&apos;, &apos;&apos;); $(&apos;.popover&apos;).css(&#123; &apos;top&apos;: 0, &apos;left&apos;: 0, &apos;opacity&apos;: 0, &apos;display&apos;: &apos;none&apos; &#125;); &#125;); 32、 打印内容的时候有可能会出现报错，项目上线请关闭自己的console.调试内容 12var aa = null;aa.length 会直接阻止js代码的执行 33、判断undefinded null NaN 123456789101112&gt; 判断undefined:&gt; var str = undefined;if (typeof(str) == &quot;undefined&quot;)&#123; alert(&quot;undefined&quot;); &#125;&gt; 说明：typeof 返回的是字符串，有六种可能：&quot;number&quot;、&quot;string&quot;、&quot;boolean&quot;、&quot;object&quot;、&quot;function&quot;、&quot;undefined&quot;&gt; 判断null&gt; var str = null; if (!str &amp;&amp; typeof(str)!=&quot;undefined&quot; &amp;&amp; str!=0)&#123; alert(&quot;null&quot;); &#125;&gt; 判断NaN&gt; var str = 0/0; if(isNaN(str))&#123; alert(&quot;NaN&quot;); &#125;&gt; 说明：如果把 NaN 与任何值（包括其自身）相比得到的结果均是 false，所以要判断某个值是否是 NaN，不能使用 == 或 === 运算符。 提示：isNaN() 函数通常用于检测 parseFloat() 和 parseInt() 的结果，以判断它们表示的是否是合法的数字。当然也可以用 isNaN() 函数来检测算数错误，比如用 0 作除数的情况。 判断undefined和null:var str = undefined; if (str== undefined) &#123; alert(&quot;null or undefined&quot;); &#125; var str = undefined; if (str== null) &#123; alert(&quot;null or undefined&quot;); &#125;&gt; 说明：null==undefined&gt; 判断undefined、null与NaN:&gt; var str = null; if (!str) &#123; alert(&quot;null or undefined or NaN&quot;); &#125; 34、视频下载12&gt; var $a = $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).attr(&quot;href&quot;, req.url).attr(&quot;download&quot;, req.filename);&gt; $a[0].click(); 35、replace() 方法可用一个新文档取代当前文档。1location.replace(newURL) 36、两个对象合并123var a =&#123;&quot;name&quot;:&quot;SUI&quot;&#125;;var b= &#123;&quot;age&quot;:24&#125;;Object.assign(a,b) 37、对象添加属性123var obj = &#123;&#125;;var a=&quot;newKey&quot;;obj[a]=&apos;1&apos;; 38、http接口必须用http,不允许出现https1今天和后台对接，他给了个https接口放入了http资源导致表单提交出错。 39、swiper 文字 和图片模糊1roundLengths : true, //防止文字模糊 40、限制数字1!/^[0-9]*$/.test(verifyhightValue)]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[html笔记]]></title>
    <url>%2F2018%2F03%2F01%2FME-%E7%AC%94%E8%AE%B0%2Fhtml%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTML1.取消浏览器拖动的蓝色选择区 12&lt;body onselectstart="return false"&gt;&lt;/body&gt;&lt;!-- 别的标签也可以使用 --&gt; 2.在进行CSS网页布局的时候，我们经遇到刷新要保留表单里内容的时候，习惯的做法使用cookie，但是那样做实在是很麻烦，css中的behavior就为我们很好的解决了这个问题。今天就向大家介绍CSS属性behavior的语法。只兼容IE 哈哈 是不是很气愤呢 3.手机号电话号 1&lt;input type="tel" placeholder="手机号或固定电话" name="tel" pattern="[0-9]*" maxlength="11" class="adphone_tel srfonchang"&gt; 4.表格 1234567891011121314151617181920212223242526&lt;table border="1"&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Month&lt;/th&gt;&lt;th&gt;Savings&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tfoot&gt;&lt;tr&gt;&lt;td&gt;Sum&lt;/td&gt;&lt;td&gt;$180&lt;/td&gt;&lt;/tr&gt;&lt;/tfoot&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;January&lt;/td&gt;&lt;td&gt;$100&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;February&lt;/td&gt;&lt;td&gt;$80&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt; 5.禁止浏览器记录 文本框之前输入过的内容 autocomplete=”off” 1&lt;input type="text" autocomplete="off"&gt; 6.HTML给视频截图 123456&lt;!-- 一定要在服务器环境下运行否则会出现跨域报错 --&gt;&lt;video id="video" controls="controls"&gt; &lt;source src="（4）金沙漂流直播_20170715142115_5475_超清.mp4" /&gt; &lt;/video&gt;&lt;button id="capture"&gt;截图&lt;/button&gt;&lt;div id="output"&gt;&lt;/div&gt; 1234567891011121314151617181920(function() &#123; var video, $output; var scale = 0.25; //截图的大小 var initialize = function() &#123; //定义一些属性 $output = $("#output"); video = $("#video").get(0); $("#capture").click(captureImage); &#125;; function captureImage() &#123; var canvas = document.createElement("canvas"); canvas.width = video.videoWidth * scale; canvas.height = video.videoHeight * scale; console.log(video.videoHeight) canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height); var img = document.createElement("img"); img.src= canvas.toDataURL(); //截图的方法 $output.prepend(img); &#125;; $(initialize); &#125;()) 7.怎么打出来© 1&lt;a href=""&gt;©&lt;/a&gt; 8.img的src如果加载失败，在chrome会有一个边框？可以在src为空的时候隐藏，动态添加以后img就会出现。123img[src=""]&#123; opacity: 0;&#125; 9.如何设置textarea光标默认为第一行第一个字符?1&lt;textarea name="textareaname" rows="XX" cols="XX" &gt;&lt;/textarea&gt; 这样就ok了，&lt;textarea&gt;&lt;/textarea&gt;这两个中间不要有空格或是其他的字符]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则笔记]]></title>
    <url>%2F2018%2F03%2F01%2FME-%E7%AC%94%E8%AE%B0%2F%E6%AD%A3%E5%88%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[获取字符串第一个字符：var str = “Hello World”; // Halert(str.substr(0, 1)); // dalert(str.substr(-1));获取字符串最后一个字符：var str = “Hello World”; // Halert(str.charAt(0)); // dalert(str.charAt(str.length - 1)); 今天遇见一个群友需要过滤一个正则问题。把 &#39;^11^&#39;过滤为 &lt;span&gt;11&lt;/span&gt;; 第一种 js + 正则 123456789var test = &apos;^11^&apos;;var text = test.replace(/\^/g,&apos;&apos;);var span1 = &apos;&lt;span&gt;&apos;;var span2 = &apos;&lt;/span&gt;&apos;;var real = &apos;&apos;;if( test.substr(0, 1) == &apos;^&apos; &amp;&amp; test.substr(-1) == &apos;^&apos; )&#123; real = span1 + text + span2 &#125;console.log(real); 第二种 正则123var test11 = &apos;^11^&apos;;var text11 = test11.replace(/\^(.*?)\^/,&apos;&lt;span&gt;$1&lt;/span&gt;&apos;);console.log(text11) 接着群里有小伙伴说，没事尽量别用正则，因为用了正则会有问题，然后还会内存泄露什么的，在上面的两种方法里面能明显看出 ，第二种更加简便效率更高。但是假如数据变为了 &#39;^1^1^&#39; 可以看出来两种方法都会出问题123456789var test = &apos;^11^&apos;;var text = test.replace(/\^/g,&apos;&apos;);var span1 = &apos;&lt;span&gt;&apos;;var span2 = &apos;&lt;/span&gt;&apos;;var real = &apos;&apos;;if( test.substr(0, 1) == &apos;^&apos; &amp;&amp; test.substr(-1) == &apos;^&apos; )&#123; real = span1 + text + span2 &#125;console.log(real); 第二种 正则123var test11 = &apos;^11^&apos;;var text11 = test11.replace(/\^(.*?)\^/,&apos;&lt;span&gt;$1&lt;/span&gt;&apos;);console.log(text11)]]></content>
      <categories>
        <category>环境框架语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js验证代码]]></title>
    <url>%2F2018%2F03%2F01%2FME-%E7%AC%94%E8%AE%B0%2Fjs%E9%AA%8C%E8%AF%81%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[判断字节长度 12345678910111213/* 判断字节长度 */function computeStrlen(str) &#123;var strlen = 0;for (var i = 0; i &lt; str.length; i++) &#123;if (str.charCodeAt(i) &gt; 255) &#123;//如果是汉字，则字符串长度加2strlen += 2;&#125; else &#123;strlen++; &#125;&#125;return strlen;&#125; 判断图片类型 1234567891011121314/** 判断图片类型* str 图片名称 img.name*/function checkPhoto(str) &#123;var type = "";if (str != '') &#123;type = str.match(/^(.*)(\.)(.&#123;1,8&#125;)$/)[3];type = type.toUpperCase();&#125;if (type != "JPEG" &amp;&amp; type != "PNG" &amp;&amp; type != "JPG" &amp;&amp; type != "GIF") &#123;return false;&#125;&#125; 判断图片大小 12345678910/** 判断图片大小* data 图片数据* spec 最大数量 1 2 3 4 5*/function imgSize(data, spec) &#123;if (data &gt; (spec * 1024) * 1024) &#123;return false;&#125;&#125; 简单的验证正则 1234567891011/* 验证正则 */var dataRegex = &#123;"verify": &#123;"required": [/[\S]+/,'必填项不能为空'],"phone": [/^1\d&#123;10&#125;$/, '请输入正确的手机号'],"email": [ /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]&#123;2,4&#125;)+$/, '邮箱格式不正确'],"url": [ /(^#)|(^http(s*):\/\/[^\s]+\.[^\s]+)/, '链接格式不正确'],"date": [ /^(\d&#123;4&#125;)[-\/](\d&#123;1&#125;|0\d&#123;1&#125;|1[0-2])([-\/](\d&#123;1&#125;|0\d&#123;1&#125;|[1-2][0-9]|3[0-1]))*$/, '日期格式不正确'],"identity": [ /(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(x|X|\d)$)/, '请输入正确的身份证号'],&#125;&#125; 密码只允许用户输入 字母（不区分大小写）数字 . 123456789101112131415161718// 密码特殊字符匹配正则function stripscript(val) &#123;var pattern = new RegExp("[`~!@#$^&amp;*()=|&#123;&#125;':;',\\[\\].&lt;&gt;/?~！@#￥……&amp;*（）——|&#123;&#125;【】‘；：”“'。，、？]")// var rs = "";var flag = true;for (var i = 0; i &lt; val.length; i++) &#123; if( pattern.test(val[i]) )&#123; flag = false; // rs = rs+val.substr(i, 1).replace(pattern, ''); &#125;&#125;// return rs;return flag;&#125;使用上面这个方法之后出现一个问题 如果强行比对数据中的特殊符号有可能会出现程序出错如输入 / 之后 代码会爆红转换思路 只允许用户输入 数字 字母 加 ./^[a-zA-Z\d.]+$/.test(_onewordval) 将 广西壮族自治区/防城港市/防城区 按照规则变为 广西 防城港 12345var str = '广西壮族自治区/防城港市/防城区';var data = str.split('/')var str1 = data[0].substr('0','2');var str2 = data[1].split('市')[0];console.log(data,str1,str2); 图片转base64 12345678910111213141516document.getElementById("upload_file").onchange = function () &#123; gen_base64();&#125;; function $_(id) &#123; return document.getElementById(id);&#125; function gen_base64() &#123; var file = $_('upload_file').files[0]; r = new FileReader(); //本地预览 r.onload=function() &#123; $_('base64_output').value = r.result; &#125; r.readAsDataURL(file); //Base64&#125;]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以更高的速度和效率调试JavaScript]]></title>
    <url>%2F2017%2F11%2F08%2FME-JS%2CJQ%2FJavaScript%E8%B0%83%E8%AF%95%E6%8F%90%E7%A4%BA%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%2F</url>
    <content type="text"><![CDATA[转载项目地址: [https://blog.fundebug.com/2017/11/08/14-javascript-debugging-tips/)项目地址: [https://raygun.com/javascript-debugging-tips) 了解你的工具的时候，做事情有显著差异。尽管JavaScript的声誉作为调试困难，如果你把一些你的袖子的错误和缺陷需要解决的时间少。 我们列出了14个调试技巧，你可能不知道，但要记住下一次你发现自己需要调试你的JavaScript代码！ 让我们开始吧 大多数这些提示是Chrome和Firefox的督察，虽然许多还将与其他人员的工作。 1。“调试器；”console.log”后，调试器；&#39;是我最喜欢的快速和肮脏的调试工具。一旦你的代码，浏览器会自动停止执行时。你甚至可以把它包在条件句，所以它只会在你需要它。 123if (thisThing) &#123; debugger;&#125; 2。显示对象表有时候，你有一套复杂的对象，你想看。你可以console.log和滚动列表，或打破console.table帮手。使得它更容易看到你在做什么！ 123456var animals = [ &#123; animal: 'Horse', name: 'Henry', age: 43 &#125;, &#123; animal: 'Dog', name: 'Fred', age: 13 &#125;, &#123; animal: 'Cat', name: 'Frodo', age: 18 &#125;]; console.table(animals);` 将输出： 三.尝试所有的尺寸在每一个移动设备在你的桌子上会很棒的，在现实世界中是不可行的。如何调整你的视图来代替呢？Chrome提供了你所需要的一切。跳进你的检验员和点击“模式”切换装置按钮看你的媒体查询来生活！ 4。如何快速找到你的DOM元素马克在元素面板一个DOM元素和使用它在您的控制台。铬检查员保持最后的五个元素在其历史上，最终的标记元素显示为0美元，第二个标记元1美元等。 如果你标记以下为“item-4′项目，“item-3 &#39;、&#39; ITEM-2 &#39;，&#39; item-1 &#39;，&#39; item-0 &#39;然后你可以访问DOM节点这样的控制台： 5。基准循环使用控制台。time() timeEnd()和控制台。它可以是超级有用，知道长的东西已经执行，尤其是当调试慢回路。你甚至可以设置多个定时器的方法分配一个标签。让我们看看它是如何工作的： 123456console.time('Timer1');var items = [];for(var i = 0; i &lt; 100000; i++)&#123; items.push(&#123;index: i&#125;);&#125; console.timeEnd('Timer1'); 这就产生了以下结果： 6。得到一个函数的堆栈跟踪你可能知道的JavaScript框架，产生大量的代码–快。 它创建视图和触发器的事件，所以你会想知道是什么引起的函数调用。 由于JavaScript不是一个结构化语言，它有时是很难得到的概述什么发生什么时候。这是当console.trace（或只是微量的控制台）来方便，能够调试JavaScript。 想象你想看到的函数调用funcz在汽车实例33线整个堆栈跟踪： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var car;var func1 = function() &#123; func2();&#125;var func2 = function() &#123; func4();&#125;var func3 = function() &#123;&#125;var func4 = function() &#123; car = new Car(); car.funcX();&#125;var Car = function() &#123; this.brand = ‘volvo’; this.color = ‘red’; this.funcX = function() &#123; this.funcY(); &#125; this.funcY = function() &#123; this.funcZ(); &#125; this.funcZ = function() &#123; console.trace(‘trace car’) &#125;&#125; func1();var car;var func1 = function() &#123; func2();&#125;var func2 = function() &#123; func4();&#125;var func3 = function() &#123;&#125;var func4 = function() &#123; car = new Car(); car.funcX();&#125;var Car = function() &#123; this.brand = ‘volvo’; this.color = ‘red’; this.funcX = function() &#123; this.funcY(); &#125; this.funcY = function() &#123; this.funcZ(); &#125; this.funcZ = function() &#123; console.trace(‘trace car’) &#125;&#125; func1();将输出线：33 现在我们可以看到，func1打电话还是一样的，这被称为func4**func4然后创建一个实例车然后调用的函数car.funcx**，等等 即使你认为你很了解你的脚本可以很方便的。比方说，你想提高你的代码。让你的大所有相关功能列表的痕迹。每一个人都是可点击的，你现在可以去它们之间来回。它就像一个菜单只为你。 7。unminify调试JavaScript代码是一个简单的方法有时你可能在生产上有问题，和你的源地图没能到服务器。不要害怕。铬可以unminify JavaScript文件更可读的格式。代码不会为你真正的代码–有用，但至少你可以看到发生了什么。单击{ }很打印按钮下面的检查源代码查看器。 8。快速查找功能调试比方说，你想在一个函数中设置断点。 最常见的两种方式就是： 1。找到你的线和添加断点检验2。添加在你的脚本调试器 在这些解决方案，你必须点击在你的文件中找到你想调试一行 什么可能是不太常见的是使用控制台。使用调试（funcname）在控制台和脚本将停止它达到的功能时，你通过了。 很快，但缺点是它不在私人或匿名函数的工作。但如果不是这样的话，很可能找到一个功能调试的最快方式。（注：有一个功能叫做console.debug这不是一回事。） 1234567891011121314var func1 = function() &#123; func2();&#125;;var Car = function() &#123; this.funcX = function() &#123; this.funcY(); &#125; this.funcY = function() &#123; this.funcZ(); &#125;&#125;var car = new Car(); 型调试（汽车节）在控制台和脚本将停止在调试模式时，它会调用一个函数来car.funcy： 9。黑盒子脚本不相关今天我们经常有几个库和框架在Web应用程序。他们中的大多数都是测试和相对无缺陷。但是，调试器仍然进入了所有的文件，有没有相关的调试任务。解决的办法是黑盒子，你不该脚本需要调试。这也包括你自己的脚本。阅读更多关于本文调试黑盒。 10。在调试复杂找到重要的东西在更复杂的调试，我们有时想输出多行。你能做的一件事保持较好的结构你的输出是使用更多的控制台的功能，例如，console.log，console.debug，console.warn，console.info，console.error等等。然后你可以过滤你的检查员。但有时这真的不是你想要的东西的时候，你需要调试JavaScript。现在，你可以得到创意和风格你的消息。使用CSS和使你自己的结构化控制台消息当你想调试JavaScript： 123console.todo = function(msg) &#123; console.log(‘ % c % s % s % s‘, ‘color: yellow; background - color: black;’, ‘–‘, msg, ‘–‘);&#125; console.important = function(msg) &#123; console.log(‘ % c % s % s % s’, ‘color: brown; font - weight: bold; text - decoration: underline;’, ‘–‘, msg, ‘–‘);&#125; console.todo(“This is something that’ s need to be fixed”); console.important(‘This is an important message’); 将输出： 例如： 在控制台。log()可以设置%s字符串，整数和% %我C自定义风格。你或许能找到更好的方法来使用这。如果你使用一个单一的网页框架，你也许想要查看消息和另一个模型，集合的一种类型，控制器等。也许也叫短像wlog，堵塞和MLOG运用你的想象力！ 11。看具体的函数调用和参数在Chrome的控制台，你可以监视特定的功能。每次调用函数时，它将是传入的值记录。123var func1 = function(x, y, z) &#123;//....&#125;; 将输出： 这是一个伟大的方式，看看哪个参数传递给函数。但我要说它会好的如果控制台可以告诉多少参数的期望。在上面的例子中，func1期望3个参数，但只有2是通过。如果不是在处理代码可能会导致一个可能的错误。 12。快速访问控制台中的元素一个更快的方式在控制台做queryselector与美元符号。$（&#39;css-selector”）将返回第一个匹配的CSS选择器。$（&#39;css-selector”）将返回所有的人。如果您使用的是一元一次以上，值得保存为一个变量。 13。邮递员是伟大的（但火狐更快）许多开发商利用邮递员玩Ajax请求。邮递员是优秀的，但它可以打开一个新的浏览器窗口有点烦人，写新的请求对象，然后测试他们。 有时很容易使用你的浏览器。 当你这样做时，你不再需要担心身份验证Cookie如果您发送一个密码安全的网页。这是你如何将编辑和发送请求在Firefox。 打开检查员去网络标签。右键单击所需的请求并选择编辑和发送。现在你可以改变任何你想要的。更改标题和编辑你的参数和打重发。 下面我提出一个请求，两次不同性质： 14。突破节点上的变化DOM是一件有趣的事。有时事情的变化，你不知道为什么。然而，当你需要调试JavaScript，浏览器可以让你暂停的时候，一个DOM元素的变化。你甚至可以监测它的属性。在Chrome的督察，右键单击元件选择打破设置使用：]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS]]></title>
    <url>%2F2017%2F10%2F09%2FME-MOB%2FIOS%2F</url>
    <content type="text"><![CDATA[关于和 iOS android 对接 字符问题必须使用字符 不可以使用字节进行判断 因为iOS 和 android 都把数字 统一当成一个字来判断 所以不能使用字节。 关于 iOS input内阴影123input,textarea&#123; -webkit-appearance: none;&#125; 关于 iOS Safari 浏览器的input点击选中时候有高亮边框 safari CSS:-webkit-tap-highlight-color 属性 作用：改写iOS Safari中可点击元素的高亮颜色。 该属性可以只设置透明度。如果未设置透明度，iOS Safari使用默认的透明度。当透明度设为0，则会禁用此属性；当透明度设为1，元素在点击时不可见。 兼容性：除了iOS Safari，大部分android手机也是支持的，只是显示效果有所不同。 关于 iOS input设置readonly之后点击出现光标和输入法http://www.bubuko.com/infodetail-2044502.html 12345678910111213141516第一种方式：&lt;input disalbed/&gt;，添加disabled，禁用输入框。可能会造成数据上传出错可以查看；http://sxiaobiblog.com/2016/01/26/HTML/HTML-form/第二种方式：不使用input,使用其他非焦点获取的标签来代替，比如div ！！！！！建议使用这个；第三种方式：通过js控制，&lt;input readonly retype="text" style="-webkit-user-select:none;" onfocus="this.blur();"&gt; &lt;!-- css --&gt; 禁止出现光标 style="-webkit-user-select:none;" &lt;!-- js --&gt; 禁止出现输入法 onfocus="this.blur();" 禁止 iOS input标签自动调用输入法 &gt; 今天做了一个关于移动端时间日期的插件，必须使用input为载体，然后设置了 readonly="readonly" 不能输入 但iOS微信端出现 ‘确定取消’ 两个输入框按键，经过测试发现当input获得焦点的时候就会触发iOS输入法失去焦点就会关闭iOS输入法所以做了下面的操作.&lt;input value="2017-07-22 23:31" readonly="readonly" id="appDateTime" type="text"&gt;$('#appDateTime').focus(function()&#123; $('#appDateTime').blur();&#125;); 关于 iOS 引用聊天室出现的兼容性问题 当iOS锁屏之后会默认关掉后台运行程序，估计微信网页进程的websocket进程被强制关闭，然后解锁之后云信聊天室自动发送了重连请求，然后从新下载了一遍历史消息。 解决方法，每次获取历史消息的时候去清空文档。 关于 iOS 的点击事件绑定无效的处理方法之前做过一个项目，元素是动态加载的，于是将点击事件绑定到document上，结果在安卓手机上点击没问题，来到iPhone就不行，后来查资料，得出结果，要在绑定的元素上加一个属性：cursor:pointer;才会有效。暂时还没找到原因，是iOS的bug？另外再记录一个点击后消除背景闪一下的css：-webkit-tap-highlight-color:transparent;http://blog.csdn.net/u014477038/article/details/52527194]]></content>
      <categories>
        <category>MOB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http和https以及跨域]]></title>
    <url>%2F2017%2F08%2F23%2FME-JS%2CJQ%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[httphttpshttps 会阻挡别的域名调用该连接的图片资源 跨域https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000 1234567// 转为http;var targetProtocol = "http:";// 转为https;var targetProtocol = "https:";if (window.location.protocol != targetProtocol) window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length);]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组根据对象排序]]></title>
    <url>%2F2017%2F08%2F20%2FME-JS%2CJQ%2F%E6%95%B0%E7%BB%84%E6%A0%B9%E6%8D%AE%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[数组按照对象排序1234567891011121314var compare = function (prop) &#123; return function (obj1, obj2) &#123; var val1 = obj1[prop]; var val2 = obj2[prop]; if (val1 &lt; val2) &#123; return -1; &#125; else if (val1 &gt; val2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;datajs.sort(compare('agent_id'));]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用名]]></title>
    <url>%2F2017%2F08%2F18%2FME-%E8%A7%84%E8%8C%83%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%2F</url>
    <content type="text"><![CDATA[常用单词年：age 月：month 日：day 时：hour 分：minute 秒：second 描述：description 常用的CSS命名头：header 内容：content/container 尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体佈局宽度：wrapper 左右中：left right center 登录条：loginbar 标志：logo 广告：banner 页面主体：main 热点：hot 新闻：news 下载：download 子导航：subnav 菜单：menu 子菜单：submenu 搜索：search 友情链接：friendlink 页脚：footer 版权：copyright 滚动：scroll 内容：content 标签：tags 文章列表：list 提示信息：msg 小技巧：tips 栏目标题：title 加入：joinus 指南：guide 服务：service 注册：regsiter 状态：status 投票：vote 合作伙伴：partner 注释的写法123/* Header */内容区/* End Header */ 页面结构命名容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体佈局宽度：wrapper 左右中：left right center 导航命名导航：nav 主导航：mainnav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能命名标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：register 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright 留言：guestbook 联系：contact 文章：article CSS样式表文件命名基本共用 global.css base.css 主页面 index.css 子页面 sub.css 模块 module.css 主题 themes.css 专栏 columns.css 文字 font.css 表单 forms.css 打印 print.css php常用代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php//设置字符集header("content-type:text/html;charset=utf8");//连接数据库并判断成功与否$link=mysql_connect('localhost','root','root')or die ('连接失败');//选择数据库mysql_select_db('数据库名');//设置字符集mysql_set_charset('utf8');//准备sql语句$sql="select * from user";//发送sql语句$result=mysql_query($sql);//判断执行的sql语句是否成功if($result &amp;&amp; mysql_affected_rows()&gt;0)&#123; echo '查询成功';&#125;else&#123; echo '查询失败';&#125;//关闭数据库连接mysql_close();//PHP数据库操作常用命令require ,include//使用 函数将某个文件包含进来mysql_connect('localhost','root','root')//连接数据库mysql_select_db('数据库名')//选择数据库mysql_set_charset('utf8')//设置字符集mysql_errno()//错误号mysql_error()//错误信息mysql_query('sql语句')//执行sql语句成功返回资源,失败返回falsemysql_free_result($result)//释放资源mysql_close()//关闭数据库mysql_affected_rows($link)//返回受影响行数 一般 添加 修改 删除的时候进行判断mysql_insert_id($link)//如果表中有自增id 添加成功将通过此函数返回自增idmysql_num_rows($result)//只用于查询 返回结果集中的记录数mysql_fetch_array($result)//将结果集中的记录以数组的形式返回 混合数组 了解即可mysql_fetch_row($result)//将结果集中的记录以数组的形式返回 索引数组 了解即可mysql_fetch_assoc($result)//将结果集中的记录以数组的形式返回 关联数组 推荐使用并且掌握]]></content>
      <categories>
        <category>SPEC</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 服务]]></title>
    <url>%2F2017%2F08%2F15%2FME-%E6%A1%86%E6%9E%B6%E7%8E%AF%E5%A2%83%2FNode-node%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[node Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。 验证 12node -v 得到版本号npm -v 得到版本号 git https://sxiaobiblog.com2016/07/17/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-git%E5%91%BD%E4%BB%A4/ 安装服务(如果npm无法使用可以用cnpm代理)http-server http-server 是一个简单的零配置命令行HTTP服务器, 基于 nodeJs. 1npm install -g http-server 命令 http://www.cnblogs.com/lucker/p/4108838.html cnpm cnpm - 淘宝NPM 镜像 你可以使用我们定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm: 1npm install -g cnpm 验证 1cnpm -v cnpm文档 http://npm.taobao.org/ sass CSS 的预处理程序 世界上最成熟、最稳定、最强大的专业级CSS扩展语言！ 。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。著作权归作者所有。 商业转载请联系作者获得授权,非商业转载请注明出处。 1cnpm install -g node-sass 验证 1node-sass -v 使用 12node-sass -w index.scss index.css --output-style expandednode-sass -w index.scss index.css --output--style expanded --source-map map //最后的map是自定义的文件 sass官方 https://www.sass.hk/ sass文档 http://sass.bootcss.com/docs/sass-reference/ sass学习 http://www.w3cplus.com/sassguide/ bower 是一个客户端技术的软件包管理器,它可用于搜索、安装和卸载如JavaScript、HTML、CSS之类的网络资源. 1npm install -g bower 验证 1bower -v 使用 123456&lt;!-- bower:css --&gt;&lt;!-- endbower --&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- bower:js --&gt;&lt;!-- endbower --&gt; 123456789101112131415161718192021222324252627bower initname jd 项目名字description jd index for weixinmain file index.html 主要文件keywords mobile.jingdongauthors 作者license wiThomcapgescl currcntly installed componcnts as dcpcndcncies NO 如果项目中有了 就yesynybower install jquery --savebower install bootstrap --savebower install touch --savenpm install wiredep --savenode出来一个&gt; require('wiredep')(&#123; src: 'index.html' &#125;);拿到别人的index.html bower.json运行bower installbower install 在官网注册的库(jqery) --save安装一个库，把库作为依赖项写入bower.jsonhttp://www.wangzhi.com --save引入一个bower库中没有的别的地方的库 bower文档 https://bower.io/ wiredep 执行grunt wiredep命令 在index.html文件会把默认dependencies依赖中的组件自动注入到下面标签中去。 1npm install wiredep --save wiredep文档 http://blog.csdn.net/itpinpai/article/details/48269825 gulp Gulp.js 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的. 1npm install -g gulp-cli 验证 1gulp -v gulp文档 http://www.gulpjs.com.cn/ grunt Grunt是基于Node.js的项目构建工具。它可以自动运行你所设定的任务。 1npm install -g gulp-cli yo1npm install -g yo 验证 1yo -v yo1npm install -g yo 验证 1yo -v generator-webapp1npm install -g generator-webapp ffmpeg FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。 使用 用cmd切换到qqmuic/musics node test.js 歌曲 名字不能有空格 ffprobe -v quiet -print_format json -show_format 1.mp3]]></content>
      <categories>
        <category>环境框架语言</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node安装]]></title>
    <url>%2F2017%2F08%2F15%2FME-%E5%B7%A5%E5%85%B7%2FNode-node%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[node Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。 验证 12node -v 得到版本号npm -v 得到版本号 git https://sxiaobiblog.com2016/07/17/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-git%E5%91%BD%E4%BB%A4/ 安装服务(如果npm无法使用可以用cnpm代理)http-server http-server 是一个简单的零配置命令行HTTP服务器, 基于 nodeJs. 1npm install -g http-server 命令 http://www.cnblogs.com/lucker/p/4108838.html cnpm cnpm - 淘宝NPM 镜像 你可以使用我们定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm: 1npm install -g cnpm 验证 1cnpm -v cnpm文档 http://npm.taobao.org/ sass CSS 的预处理程序 世界上最成熟、最稳定、最强大的专业级CSS扩展语言！ 。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。著作权归作者所有。 商业转载请联系作者获得授权,非商业转载请注明出处。 1cnpm install -g node-sass 验证 1node-sass -v 使用 12node-sass -w index.scss index.css --output-style expandednode-sass -w index.scss index.css --output--style expanded --source-map map //最后的map是自定义的文件 sass官方 https://www.sass.hk/ sass文档 http://sass.bootcss.com/docs/sass-reference/ sass学习 http://www.w3cplus.com/sassguide/ bower 是一个客户端技术的软件包管理器,它可用于搜索、安装和卸载如JavaScript、HTML、CSS之类的网络资源. 1npm install -g bower 验证 1bower -v 使用 123456&lt;!-- bower:css --&gt;&lt;!-- endbower --&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- bower:js --&gt;&lt;!-- endbower --&gt; 123456789101112131415161718192021222324252627bower initname jd 项目名字description jd index for weixinmain file index.html 主要文件keywords mobile.jingdongauthors 作者license wiThomcapgescl currcntly installed componcnts as dcpcndcncies NO 如果项目中有了 就yesynybower install jquery --savebower install bootstrap --savebower install touch --savenpm install wiredep --savenode出来一个&gt; require('wiredep')(&#123; src: 'index.html' &#125;);拿到别人的index.html bower.json运行bower installbower install 在官网注册的库(jqery) --save安装一个库，把库作为依赖项写入bower.jsonhttp://www.wangzhi.com --save引入一个bower库中没有的别的地方的库 bower文档 https://bower.io/ wiredep 执行grunt wiredep命令 在index.html文件会把默认dependencies依赖中的组件自动注入到下面标签中去。 1npm install wiredep --save wiredep文档 http://blog.csdn.net/itpinpai/article/details/48269825 gulp Gulp.js 是一个自动化构建工具,开发者可以使用它在项目开发过程中自动执行常见任务。Gulp.js 是基于 Node.js 构建的. 1npm install -g gulp-cli 验证 1gulp -v gulp文档 http://www.gulpjs.com.cn/ grunt Grunt是基于Node.js的项目构建工具。它可以自动运行你所设定的任务。 1npm install -g gulp-cli yo1npm install -g yo 验证 1yo -v yo1npm install -g yo 验证 1yo -v generator-webapp1npm install -g generator-webapp ffmpeg FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。 使用 用cmd切换到qqmuic/musics node test.js 歌曲 名字不能有空格 ffprobe -v quiet -print_format json -show_format 1.mp3]]></content>
      <categories>
        <category>框架环境</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass学习]]></title>
    <url>%2F2017%2F08%2F14%2FME-%E5%B7%A5%E5%85%B7%2Fsass%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[nate-river# SassMay 8, 2016## 1. Sass简介Sass 是一种css预处理器,CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。除了sass还有一些其他常见的预处理语言LESSStylusSass 有时候也被称为 SCSS,两者之间不同之处有以下两点：文件扩展名不同，Sass 是以”.sass”后缀为扩展名，而 SCSS 是以”.scss”后缀为扩展名语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。来看一个示例：/ Sass 语法 /$font-stack: Helvetica, sans-serif$primary-color: #333bodyfont: 100% $font-stackcolor: $primary-color/ Scss 语法 /$font-stack: Helvetica, sans-serif;$primary-color: #333;body {font: 100% $font-stack;color: $primary-color;}编译出来的 CSSbody {font: 100% Helvetica, sans-serif;color: #333;}scss文件中可以完全像写正常的css那样去写.## 2. sass安装npm install -g node-sassnode-sass -w xxx.scss xxx.css –style expandednode-sass 参数:-w, –watch Watch a directory or file-r, –recursive Recursively watch directories or files-o, –output Output directory-x, –omit-source-map-url Omit source map URL comment from output-i, –indented-syntax Treat data from stdin as sass code (versus scss)-q, –quiet Suppress log output except on error-v, –version Prints version info–output-style CSS output style (nested | expanded | compact | compressed)–indent-type Indent type for output CSS (space | tab)–indent-width Indent width; number of spaces or tabs (maximum value: 10)–linefeed Linefeed style (cr | crlf | lf | lfcr)–source-comments Include debug info in output–source-map Emit source map–source-map-contents Embed include contents in map–source-map-embed Embed sourceMappingUrl as data URI–source-map-root Base path, will be emitted in source-map as is–include-path Path to look for imported files–follow Follow symlinked directories–precision The amount of precision allowed in decimal numbers–importer Path to .js file containing custom importer–functions Path to .js file containing custom functions–help Print usage info## 3. Sass的基本特性### 变量$brand-primary : darken(#428bca, 6.5%) !default;$btn-primary-color : #fff !default;$btn-primary-bg : $brand-primary !default;$btn-primary-border : darken($btn-primary-bg, 5%) !default;.btn-primary {background-color: $btn-primary-bg;color: $btn-primary-color;border: 1px solid $btn-primary-border;}$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body{1line-height: $baseLineHeight;&#125; / 局部变量 /$color: orange !default;.block { color: $color;}em { $color: red; a { 1color: $color; }}span { color: $color;} 嵌套nav { a { 1234567color: red;header &amp; &#123; color:green;&#125; } } .box { border: { top: 1px solid red; bottom: 1px solid green; }} .clearfix{ &amp;:before, &amp;:after { 123content:&quot;&quot;;display: table; } &amp;:after { 123clear:both;overflow: hidden; }} 不要无节制嵌套,一切都根据实际情况判断 混合宏@mixin border-radius{ -webkit-border-radius: 5px; border-radius: 5px;}button{ @include border-radius;} @mixin border-radius($radius:5px){ -webkit-border-radius: $radius; border-radius: $radius;}.nav{ @include border-radius;}.box{ @include border-radius(3px);} @mixin center($width,$height){ width: $width; height: $height; position: absolute; top: 50%; left: 50%; margin-top: -($height) / 2; margin-left: -($width) / 2;}.box-center { @include center(500px,300px);} @mixin box-shadow($shadows…){ @if length($shadows) &gt;= 1 { 123-webkit-box-shadow: $shadows;box-shadow: $shadows; } @else { 12345$shadows: 0 0 2px rgba(#000,.25);-webkit-box-shadow: $shadow;box-shadow: $shadow; }}.box { @include box-shadow(0 0 1px rgba(#000,.5),0 0 2px rgba(#000,.2));} 混合宏会生成冗余代码 扩展/继承.btn { border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;} .btn-primary { background-color: #f36; color: #fff; @extend .btn;} .btn-second { background-color: orange; color: #fff; @extend .btn;} 不会生成冗余代码 占位符%mt5 { margin-top: 5px;}%pt5{ padding-top: 5px;}.btn { @extend %mt5; @extend %pt5;} mt5 和 pt5 并不会生成最终代码 插值#{}允许在#{}内部解析变量 $properties: (margin, padding);@mixin set-value($side, $value) { @each $prop in $properties { 1#&#123;$prop&#125;-#&#123;$side&#125;: $value; }}.login-box { @include set-value(top, 14px);} 注释类似 CSS 的注释方式，使用 “/ “开头，结属使用 “/ “ 类似 JavaScript 的注释方式，使用”//“ 两者区别，前者会在编译出来的 CSS 显示，后者在编译出来的 CSS 中不会显示 数据类型Sass 和 JavaScript 语言类似，也具有自己的数据类型，在 Sass 中包含以下几种数据类型： 数字: 如，1、 2、 13、 10px； 字符串：有引号字符串或无引号字符串，如，”foo” ‘bar’ baz； 颜色：如，blue, #04a3f9, rgba(255,0,0,0.5); 布尔型：如，true, false； 空值：如，null； 值列表：用空格或者逗号分开，如，1.5em 1em 0 2em , Helvetica, Arial, sans-serif 运算.box { width: 20px + 8in;}$full-width: 960px;$sidebar-width: 200px;.content { width: $full-width - $sidebar-width;}.box { width: 10px * 2;}.box { width: (100px / 2); }p { font: 10px/8px; // 纯 CSS，不是除法运算 $width: 1000px; width: $width/2; // 使用了变量，是除法运算 width: round(1.5)/2; // 使用了函数，是除法运算 height: (500px/2); // 使用了圆括号，是除法运算 margin-left: 5px + 8px/2px; // 使用了加（+）号，是除法运算}.box { width: ((220px + 720px) - 11 * 20 ) / 12 ; }p { color: #010203 + #040506; background-color: #010203 * 2;} $content: “Hello” + “” + “Sass!”;.box:before { content: “ #{$content} “;} 4. Sass高级特性@if@mixin blockOrHidden($boolean:true) { @if $boolean { 1display: block; } @else { 1display: none; }}.block { @include blockOrHidden;}.hidden{ @include blockOrHidden(false);} @for@for $i from through @for $i from to @for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; }}@for $i from 1 to 3 { .item-#{$i} { width: 2em * $i; }} $grid-prefix: span !default;$grid-width: 60px !default;$grid-gutter: 20px !default; %grid { float: left; margin-left: $grid-gutter / 2; margin-right: $grid-gutter / 2;}@for $i from 1 through 12 { .#{$grid-prefix}#{$i}{ 123width: $grid-width * $i + $grid-gutter * ($i - 1);@extend %grid; } } @each$list: adam john wynn mason kuroir; //$list 就是一个列表@mixin author-images { 1234567891011@each $author in $list &#123; .photo-#&#123;$author&#125; &#123; background: url(&quot;/images/avatars/#&#123;$author&#125;.png&quot;) no-repeat; &#125;&#125;&#125;.author-bio &#123;@include author-images;&#125; 5. Sass中的函数@function double($n) { @return $n * 2;}#sidebar { width: double(5px);} 全部的内置函数 字符串函数 unquote quote To-upper-case To-lower-case percentage .footer{ width : percentage(.2)} round ceil floor abs min max random 列表函数 length 取列表数据的长度 nth (10px 20px 30px, 1) 会取值 join join(10px 20px, 30px 40px) append append(10px 20px ,30px) zip zip(1px 2px 3px,solid dashed dotted,green blue red) index index(1px solid red, solid) type-of type-of(100) unit 取单位 unitless 判断一个值是否带有单位 comparable 判断两个数是否可以进行加减合并 if(true,1px,2px) Maps 函数 map-get map-has-key map-keys map-values map-merge map-remove keywords $map: ( $key1: value1, $key2: value2, $key3: value3) $map: ( key1: value1, key2: ( 123key-1: value-1,key-2: value-2, ),key3: value3); $theme-color: ( default: ( 12345bgcolor: #fff,text-color: #444,link-color: #39f ), primary:( 12345bgcolor: #000,text-color:#fff,link-color: #93f ), negative: ( 12345bgcolor: #f36,text-color: #fefefe,link-color: #d4e )); / map-get /$social-colors: ( dribble: #ea4c89, facebook: #3b5998, github: #171515, google: #db4437, twitter: #55acee);.btn-dribble{ color: map-get($social-colors,facebook);}/ 没有值不会报错 /.btn-weibo{ font-size: 12px; color: map-get($social-colors,weibo);} / map中的容错函数 /@function colors($color){ @if not map-has-key($social-colors,$color){ 1@warn &quot;No color found for `#&#123;$color&#125;` in $social-colors map. Property omitted.&quot;; } @return map-get($social-colors,$color);}.btn-dribble { color: colors(dribble);} / each 遍历 map /@each $name in map-keys($social-colors){ .btn-#{$name}{ 1color: colors($name); }}@for $i from 1 through length(map-keys($social-colors)){ .btn-#{nth(map-keys($social-colors),$i)} { 1color: colors(nth(map-keys($social-colors),$i)); }} map-values($social-colors)/得到所有的值/ $color: ( text: #f36, link: #f63, border: #ddd, backround: #fff);$typo:( font-size: 12px, line-height: 1.6);$newcolor = map-merge($color, $typo); / 得到新值 /$map:map-remove($social-colors,dribble); 颜色函数 rgb rgba red green blue mix 混合两种颜色 第三个参数为第一种颜色的比例 mix(blue,red,20%) lighten lighten(red, 20%); darken darken(red,30%); saturate 改变颜色的饱和度参数单位为百分比 saturate(blue,20%) desaturate adjust-hue 通过调整色相 adjust-hue(blue,30deg) grayscale 直接让饱和度为0 grayscale(blue); alpha 获取透明度 opacity 获取透明度 rgba opacify 增加透明度 fade-in 增加透明度 transparentize 减少透明度 fade-out 减少透明度 - …- - … - - … - - … - - … - - … - $redBase: #DC143C;$orangeBase: saturate(lighten(adjust_hue($redBase, 39), 5), 7);//#f37a16$yellowBase: saturate(lighten(adjust_hue($redBase, 64), 6), 13);//#fbdc14$greenBase: desaturate(darken(adjust_hue($redBase, 102), 2), 11);//#73c620$blueBase: saturate(darken(adjust_hue($redBase, 201), 2), 1);//#12b7d4$purpleBase: saturate(darken(adjust_hue($redBase, 296), 2), 1);//#a012d4$blackBase: #777;$bgc: #fff; //定义颜色变暗的 mixin@mixin swatchesDarken($color) { @for $i from 1 through 10 { 123456789101112131415161718192021$x:$i+11;li:nth-child(#&#123;$x&#125;) &#123; $n:$i*5; $bgc:darken($color,$n); //颜色变暗 background-color: $bgc; &amp;:hover:before &#123; //hover状态显示颜色编号 content: &quot;#&#123;$bgc&#125;&quot;; color: lighten($bgc,40); font-family: verdana; font-size: 8px; padding: 2px; &#125;&#125; }}//定义颜色变亮的 mixin@mixin swatchesLighten($color) { @for $i from 1 through 10 { 12345678910111213141516171819202122232425$x:11-$i;li:nth-child(#&#123;$x&#125;) &#123; $n:$i*5; $bgc:lighten($color,$n); background-color: $bgc; &amp;:hover:before &#123; content: &quot;#&#123;$bgc&#125;&quot;; color: darken($bgc,40); font-family: verdana; font-size: 8px; padding: 2px; &#125;&#125; }} .swatches li { width: 4.7619047619%; float: left; height: 60px; list-style: none outside none;} ul.red { @include swatchesLighten($redBase); @include swatchesDarken($redBase); li:nth-child(11) { 1background-color: $redBase; }} ul.orange { @include swatchesLighten($orangeBase); @include swatchesDarken($orangeBase); li:nth-child(11) { 1background-color: $orangeBase; }} ul.yellow { @include swatchesLighten($yellowBase); @include swatchesDarken($yellowBase); li:nth-child(11) { 1background-color: $yellowBase; }} ul.green { @include swatchesLighten($greenBase); @include swatchesDarken($greenBase); li:nth-child(11) { 1background-color: $greenBase; }} ul.blue { @include swatchesLighten($blueBase); @include swatchesDarken($blueBase); li:nth-child(11) { 1background-color: $blueBase; }} ul.purple { @include swatchesLighten($purpleBase); @include swatchesDarken($purpleBase); li:nth-child(11) { 1background-color: $purpleBase; }} ul.black { @include swatchesLighten($blackBase); @include swatchesDarken($blackBase); li:nth-child(11) { 1background-color: $blackBase; }} 6. Sass的@规则@import @media .sidebar { width: 300px; @media screen and (orientation: landscape) { 1width: 500px; }}@media screen { .sidebar { 12345@media (orientation: landscape) &#123; width: 500px;&#125; }} $media: screen;$feature: -webkit-min-device-pixel-ratio;$value: 1.5; @media #{$media} and ($feature: $value) { .sidebar { 1width: 500px; }} @extend @at-root @debug @warn @error nate-river A web fullstack developer]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>图片上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的代码]]></title>
    <url>%2F2017%2F08%2F14%2FME-%E8%A7%84%E8%8C%83%2F%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[移动端兼容12//移动端适配&lt;meta content="width=device-width,height=device-height,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"&gt;]]></content>
      <categories>
        <category>SPEC</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.sessionStorge使用]]></title>
    <url>%2F2017%2F07%2F10%2FME-JS%2CJQ%2FJS-window-sessionStorge%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。 sessionStorage和localStorage区别 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别 Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 html5 web storage的浏览器支持情况 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的UserData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。 要判断浏览器是否支持localStorage可以使用下面的代码： 12345678if (window.localStorage) &#123; alert("浏览支持localStorage")&#125; else &#123; alert("浏览暂不支持localStorage")&#125; //或者if(typeof window.localStorage == 'undefined')&#123; alert("浏览暂不支持localStorage")&#125; localStorage和sessionStorage操作localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 localStorage和sessionStorage的方法setItem存储value用途：将value存储到key字段用法：.setItem( key, value)代码示例： sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;); localStorage.setItem(&quot;site&quot;, &quot;js8.in&quot;); getItem获取value用途：获取指定key本地存储的值用法：.getItem(key)代码示例： var value = sessionStorage.getItem(&quot;key&quot;); var site = localStorage.getItem(&quot;site&quot;); removeItem删除key用途：删除指定key本地存储的值用法：.removeItem(key)代码示例： sessionStorage.removeItem(&quot;key&quot;); localStorage.removeItem(&quot;site&quot;); clear清除所有的key/value用途：清除所有的key/value用法：.clear()代码示例： sessionStorage.clear(); localStorage.clear(); 其他操作方法：点操作和[]web Storage不但可以用自身的setItem,getItem等方便存取，也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储，像如下的代码： var storage = window.localStorage; storage.key1 = “hello”; storage[“key2”] = “world”; console.log(storage.key1); console.log(storage[“key2”]); localStorage和sessionStorage的key和length属性实现遍历sessionStorage和localStorage提供的key()和length可以方便的实现存储的数据遍历，例如下面的代码： var storage = window.localStorage; for (var i=0, len = storage.length; i &lt; len; i++){ var key = storage.key(i); var value = storage.getItem(key); console.log(key + “=” + value); } storage事件storage还提供了storage事件，当键值改变或者clear的时候，就可以触发storage事件，如下面的代码就添加了一个storage事件改变的监听： if(window.addEventListener){ window.addEventListener(“storage”,handle_storage,false); }else if(window.attachEvent){ window.attachEvent(“onstorage”,handle_storage); } function handle_storage(e){ if(!e){e=window.event;} } storage事件对象的具体属性如下表： | Property | Type | Description || key | String | The named key that was added, removed, or moddified || oldValue | Any | The previous value(now overwritten), or null if a new item was added || newValue | Any | The new value, or null if an item was added || url/uri | String | The page that called the method that triggered this change | Web Storage DemoHTML5 Demos: Storage Web Storage Example 转载]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图片上传预览]]></title>
    <url>%2F2017%2F04%2F12%2FME-JS%2CJQ%2F%E5%8A%9F%E8%83%BD-%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%A2%84%E8%A7%88%2F</url>
    <content type="text"><![CDATA[整理一份涵盖图片上传预览验证压缩的文件项目预览：https://sxiaobiblog.comuploadImg/ 项目地址：https://github.com/sywsywsyw/uploadImg HTML部分12345&lt;h1&gt;图片上传预览&lt;/h1&gt;&lt;input type="file" id="img-upload" accept="image/jpg,image/png,image/gif,image/jpeg"&gt;&lt;div class="img-view-wrap"&gt; &lt;img id="img-view" src="" alt="预览图片"&gt;&lt;/div&gt; CSS部分1234567891011121314151617181920.img-view-wrap&#123;width: 200px;height: 200px;line-height: 200px;text-align: center;border: 1px solid #e2e2e2;position:relative;overflow:hidden;&#125;#img-view&#123;display: block;position: absolute;top: 50%;left: 50%;height: 100%;-ms-transform: translate(-50%,-50%);-moz-transform: translate(-50%,-50%);-o-transform: translate(-50%,-50%);transform: translate(-50%,-50%);&#125; HTML部分123456&lt;h1&gt;图片上传预览&lt;/h1&gt;&lt;input type="file" id="img-upload" accept="image/jpg,image/png,image/gif,image/jpeg"&gt;&lt;div class="img-view-wrap"&gt; &lt;img id="img-view" src="" alt="预览图片"&gt;&lt;/div&gt;` JS部分（详情请看备注）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;script&gt; $('#img-upload').change(function()&#123; setImagePreviews('img-upload','img-view');&#125;);//图片预览function setImagePreviews(dval, dimg) &#123; var docObj = document.getElementById(dval); console.log(docObj.files); if ( docObj.files.length &gt; 0) &#123; //判断上传数量大于0 var fileList = docObj.files[0]; var name = fileList.name; var size = fileList.size; var url = window.URL.createObjectURL(fileList); if (checkPhoto(name) == false) &#123; alert('请上传正确的图片格式'); $('#' + dval).val(''); $('#' + dimg).attr('src', ''); return false; &#125;else if (imgSize(size, 3) == false) &#123; alert('请上传小于3M的图片'); $('#' + dval).val(''); $('#' + dimg).attr('src', ''); return false; &#125;else if (url != '' || url != null) &#123; dealImage(url,&#123;'width' : 400&#125;,function(base)&#123; $('#' + dval).text('重新上传'); $('#' + dimg).attr('src', base); // console.log("压缩后：" + base.length / 1024 + " " + base); // var form=document.forms[0];// var formData = new FormData(form); //这里连带form里的其他参数也一起提交了,如果不需要提交其他参数可以直接FormData无参数的构造函数// var formData = new FormData($( "#zhfbForm" )[0]); 上面的form不生效可以使用id取// console.log(formData.get('theme')); 打印获取到的数据// console.log(formData.get('face'));// formData.append("face",document.getElementById('face').files[0]); 上传图片var formData = new FormData();formData.append("imageName",convertBase64UrlToBlob(base));console.log(formData.get('imageName'));$.ajax(&#123; url: "http://192.168.1.120:8080/index.php", //请求的url地址 type: "POST", //请求方式 GET data: formData, //参数值 cache: false, contentType: false, // 告诉jQuery不要去处理发送的数据 processData: false, // 告诉jQuery不要去设置Content-Type请求头 dataType: 'JSON', success: function (req) &#123; //请求成功时处理 console.log(req); &#125;, error: function (req) &#123; //请求出错处理 console.log(req); &#125; &#125;);function convertBase64UrlToBlob(urlData)&#123; var bytes=window.atob(urlData.split(',')[1]); //去掉url的头，并转换为byte //处理异常,将ascii码小于0的转换为大于0 var ab = new ArrayBuffer(bytes.length); var ia = new Uint8Array(ab); for (var i = 0; i &lt; bytes.length; i++) &#123; ia[i] = bytes.charCodeAt(i); &#125; return new Blob( [ab] , &#123;type : 'image/png'&#125;); &#125;&#125;); // $('#' + dval).text('重新上传'); // $('#' + dimg).attr('src', url); &#125; &#125;else&#123; $('#' + dval).val(''); $('#' + dimg).attr('src', ''); &#125; &#125;//判断图片类型//str 图片名称function checkPhoto(str)&#123; var type=""; if( str !='' )&#123; type= str.match(/^(.*)(\.)(.&#123;1,8&#125;)$/)[3]; type= type.toUpperCase(); &#125; if( type!="JPEG" &amp;&amp; type!="PNG" &amp;&amp; type!="JPG" &amp;&amp; type!="GIF")&#123; return false; &#125;&#125;//data 图片数据 spec 最大数量 1 2 3 4 5function imgSize(data,spec)&#123; if( data &gt; (spec*1024)*1024 )&#123; return false; &#125;&#125;/** * 图片压缩，默认同比例压缩 * @param &#123;Object&#125; path * pc端传入的路径可以为相对路径，但是在移动端上必须传入的路径是照相图片储存的绝对路径 * @param &#123;Object&#125; obj * obj 对象 有 width， height， quality(0-1) * @param &#123;Object&#125; callback * 回调函数有一个参数，base64的字符串数据 */ function dealImage(path, obj, callback)&#123; var img = new Image(); img.src = path; img.onload = function()&#123; var that = this; // 默认按比例压缩 var w = that.width, h = that.height, scale = w / h; w = obj.width || w; h = obj.height || (w / scale); var quality = 1; // PC默认图片质量为0.7 // var quality = 0.7; // 移动端默认图片质量为0.7 //生成canvas var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); // 创建属性节点 var anw = document.createAttribute("width"); anw.nodeValue = w; var anh = document.createAttribute("height"); anh.nodeValue = h; canvas.setAttributeNode(anw); canvas.setAttributeNode(anh); ctx.fillStyle = "#fff"; //给png图片 在canvas绘制前填充白色背景 ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.drawImage(that, 0, 0, w, h); // 图像质量 if(obj.quality &amp;&amp; obj.quality &lt;= 1 &amp;&amp; obj.quality &gt; 0)&#123; quality = obj.quality; &#125; // quality值越小，所绘制出的图像越模糊 var base64 = canvas.toDataURL('image/jpeg', quality ); // 回调函数返回base64的值 callback(base64);&#125;&#125;// // 调用函数处理图片 // dealImage("路径", &#123;// // 注意：在pc端可以用绝对路径或相对路径，移动端最好用绝对路径（因为用take photo后的图片路径，我没有试成功（如果有人试成功了可以分享一下经验））// width : 200// &#125;, function(base)&#123;// //直接将获取到的base64的字符串，放到一个image标签中就可看到测试后的压缩之后的样式图了// document.getElementById("transform").src = base;// console.log("压缩后：" + base.length / 1024 + " " + base); // &#125;)&lt;/script&gt; Canvas 在高清屏下绘制图片变模糊的解决方法http://blog.csdn.net/qyaroon/article/details/51916150canvas转base64/jpeg时，透明区域变成黑色背景的解决方案 - 大灰狼的小绵羊哥哥的博客 - CSDN博客http://blog.csdn.net/sinat_17775997/article/details/58708042]]></content>
      <categories>
        <category>功能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网站构成]]></title>
    <url>%2F2017%2F04%2F01%2FME-%E8%A7%84%E8%8C%83%2F%E7%BD%91%E7%AB%99%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[网站构成（PC） website constitute 前言：weui的设计规范，忽然觉得站在了巨人的肩膀。 https://weui.io/ 基础样式字体一套主题颜色一套表单样式input 内边距（padding） 点击输入时获得焦点的颜色（鼠标点击之后给用户的颜色强调） 移动端（mob）可无 数据核验出错样式（如果为空，为假时，进行红色样式强调） 移动端（mob）可无 数据核验成功之后的样式 button 按钮允许操作样式 按钮点击之后 文字前加loading样式 按钮禁止操作样式 鼠标移入之后的样式改变 基础组件 Header（页首） Footer（页脚） 链接、备案信息 Flex（布局） Loadmore（加载样式） icon 正在加载 暂无数据 结束 Article（文章） Badge（徽章） 也就是角标 操作反馈导航相关搜索相关层级规范]]></content>
      <categories>
        <category>SPEC</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断浏览器类型edge]]></title>
    <url>%2F2017%2F03%2F28%2FME-JS%2CJQ%2FJS-js%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%B1%BB%E5%9E%8Bedge%2F</url>
    <content type="text"><![CDATA[JS根据useAgent来判断edge, ie, firefox, chrome, opera, safari 等浏览器的类型及版本 js根据浏览器的useAgent来判断浏览器的类型 userAgent 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。 JavaScript语法：navigator.userAgent PHP语法：$_SERVER[‘HTTP_USER_AGENT’] ASP语法：Request.ServerVariables(“HTTP_USER_AGENT”) ASP.NET语法：HttpContext.Current.Request.UserAgent JSP语法：request.getHeader(“User-Agent”) Chrome: (version: 50.0.2661.102 m) jsp: userAgent :Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/50.0.2661.102 Safari/537.36 js: userAgent : Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36 Firefox: (version: 47.0) jsp: userAgent : Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101Firefox/47.0 js: userAgent : Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101Firefox/47.0 Safari: (version: 5.1.7) jsp: userAgent : Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7Safari/534.57.2 js: userAgent : Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko)Version/5.1.7Safari/534.57.2 IE 8: (version: 8.0.7601.17514, update versions: 0) jsp: userAgent : Mozilla/4.0 (compatible;MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0) js: userAgent : Mozilla/4.0 (compatible;MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0) IE 11: (version: 11.0.9600.18321 update Versions: 11.0.31) jsp: userAgent : Mozilla/5.0 (Windows NT 6.3; WOW64;Trident/7.0; rv:11.0) like Gecko js: userAgent : Mozilla/5.0 (Windows NT 6.3; WOW64;Trident/7.0; .NET4.0E; .NET4.0C; .NET CLR 3.5.30729; .NET CLR 2.0.50727; .NET CLR 3.0.30729; InfoPath.3; rv:11.0) like Gecko Windows Edge: (version: 25.10580.0.0) jsp: userAgent : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586 js: userAgent : Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586 [乐意黎 ] 接下来，如何判断浏览器的类型呢 ？ IE 浏览器 ： | Token | Description || Edge | Windows Edge || Trident/7.0 | IE11 || Trident/6.0 | Internet Explorer 10 || Trident/5.0 | Internet Explorer 9 || Trident/4.0 | Internet Explorer 8 | JS 代码: //返回浏览器的类型: “ie”, “firefox”, “chrome”, “opera”, “safari”, “unknow” // author: aerchi // site:www.aerchi.com // blog: http://blog.csdn.net/aerchi/article/details/51697592 // email: aerchi@gmail.com // date: 2016-06-17 // update: 2016-08-11 00:56:00 // call like: getBrowser(1)// return like “chrome/50.0.2661.102”// call like: getBrowser()// return like “chrome”function getBrowser(getVersion){ //注意关键字大小写 var ua_str = navigator.userAgent.toLowerCase(), ie_Tridents, trident, match_str, ie_aer_rv, browser_chi_Type; console.log(&quot;article url: http://blog.csdn[.net](http://lib.csdn.net/base/dotnet &quot;.NET知识库&quot;)/aerchi/article/details/51697592&quot;); //判断IE 浏览器, //blog: http://blog.csdn[.Net](http://lib.csdn.net/base/dotnet &quot;.NET知识库&quot;)/aerchi/article/details/51697592 if(&quot;ActiveXObject&quot; in self){ // ie_aer_rv: 指示IE 的版本. // It can be affected by the current document mode of IE. ie_aer_rv= (match_str = ua_str.match(/msie ([\d.]+)/)) ?match_str[1] : (match_str = ua_str.match(/rv:([\d.]+)/)) ?match_str[1] : 0; // ie: Indicate the really version of current IE browser. ie_Tridents = {&quot;trident/7.0&quot;: 11, &quot;trident/6.0&quot;: 10, &quot;trident/5.0&quot;: 9, &quot;trident/4.0&quot;: 8}; //匹配 ie8, ie11, edge trident = (match_str = ua_str.match(/(trident\/[\d.]+|edge\/[\d.]+)/)) ?match_str[1] : undefined; browser_chi_Type = (ie_Tridents[trident] || ie_aer_rv) &gt; 0 ? &quot;ie&quot; : undefined; }else{ //判断 windows edge 浏览器 // match_str[1]: 返回浏览器及版本号,如: &quot;edge/13.10586&quot; // match_str[1]: 返回版本号,如: &quot;edge&quot; //若要返回 &quot;edge&quot; 请把下行的 &quot;ie&quot; 换成 &quot;edge&quot;。 注意引号及冒号是英文状态下输入的 browser_chi_Type = (match_str = ua_str.match(/edge\/([\d.]+)/)) ? &quot;ie&quot; : //判断firefox 浏览器 (match_str = ua_str.match(/firefox\/([\d.]+)/)) ? &quot;firefox&quot; : //判断chrome 浏览器 (match_str = ua_str.match(/chrome\/([\d.]+)/)) ? &quot;chrome&quot; : //判断opera 浏览器 (match_str = ua_str.match(/opera.([\d.]+)/)) ? &quot;opera&quot; : //判断safari 浏览器 (match_str = ua_str.match(/version\/([\d.]+).*safari/)) ? &quot;safari&quot; : undefined; } console.log(&quot;author: aerchi, blog: http://blog.csdn.net/aerchi&quot;); //返回浏览器类型和版本号 var verNum, verStr; verNum = trident &amp;&amp; ie_Tridents[trident] ? ie_Tridents[trident] : match_str[1]; verStr = (getVersion != undefined) ? browser_chi_Type+&quot;/&quot;+verNum : browser_chi_Type; return verStr; } 乐意黎原创， 严禁采集或用于个人网站。转载请注明作者及原文地址 本文地址： http://blog.csdn.net/aerchi/article/details/51697592]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[new关键字的用法]]></title>
    <url>%2F2017%2F03%2F15%2FME-JS%2CJQ%2FJS-new%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // javascript中构建一个对象的4种方式 // 1. 字面量的形式 var obj = &#123; "a":12, "b":234 &#125; // 根据字面量的形式创建的对象 // 原型就是 Obj.prototype 这个对象 // 功能性较少 // 2.构造函数 var obj2 = new Object() obj2.a = 12; //一般不用 太麻烦 // 3.利用 Obj.create() 方法 // 从一个已有的对象开始构建新的对象 var mao = &#123; zhuazi:4, erduo:1, nao:function()&#123; &#125; &#125; var bosimao = Object.create(mao); bosimao.dianjiaojian = function()&#123; &#125; // 4. 用new 关键字来构造对象 var mao = function()&#123; this.zhuazi = 4; this.erduo = 1; &#125; // 每个函数对象身上都有一个其他对象不具备的属性，叫做'prototype' var bosimao = new mao() // 1.构建一个空对象() // 2.mao.call(&#123;&#125;) 把mao那个函数作为这个空对象的临时方法调用了一次 // &#123;zhuazi:4,erduo:1&#125; // 3.把mao那个函数对象身上的prototype那个属性拿来，作为自己原型链上的一条 // 4.返回最终的对象 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网页转为MD]]></title>
    <url>%2F2017%2F03%2F06%2FME-%E5%B7%A5%E5%85%B7%2F%E5%B7%A5%E5%85%B7-%E7%BD%91%E9%A1%B5%E8%BD%AC%E4%B8%BAMD%2F</url>
    <content type="text"><![CDATA[转载项目预览: https://phodal.github.io/2md/ 项目地址: https://github.com/phodal/2md 【开源】2md：将复制的内容、网页转成 markdown 如果一个 Markdown 编辑器不能解决问题，那么就用两个编辑器。 作为一个作者、程序员，兼知名的 markdown 程序员，我总是要在 Markdown、HTML、PDF 各种格式之间进行转换。 因为日常工作的一些使用需要，我也创建了各种的轮子： 如 ebook-boilerplate基于 markdown 一步生成电子书: 支持PDF、Mobi、EPUB格式。 如 MDPub，用于微信公众号的 markdown 编辑器，主要是用于提供代码高亮： MDPub 截图 今天，我修复一个 MDPub 的 bug 时，突然意识到我也有将一篇文章转为 Markdown 的需要。 2md 以前，当我需要将 HTML 转为 Markdown 的时候，我会使用 to-markdown 的 Demo 网页，来转换相应的 HTML 为 Markdown。可是，这意味着我需要我复制到 HTML，才能转为 Markdown。 因此，我便想着：如果可以直接用鼠标选中，然后 Ctrl + C、Ctrl + V 的话，就更简单了。 而，实际上，我只需要一个 WYSIWYG 编辑器，然后再将内容转为 Markdown 就可以了。 因此，就有了 2md： 2MD 截图 一如即往的，保持了简洁的风格。并且，它的代码也足够的简单：123456789101112131415161718192021222324&lt;script&gt;tinymce.init(&#123; selector: 'textarea#input', height: 500, menubar: false, statusbar: false, toolbar: ['code'], plugins: [ 'advlist autolink lists link image charmap print preview anchor', 'searchreplace visualblocks code fullscreen', 'insertdatetime media table contextmenu paste code' ], setup: function (editor) &#123; editor.on('change', function (e) &#123; varcontent = tinymce.get('input').getContent(); varmd = toMarkdown(content); $("#output").val(md); &#125;); &#125;&#125;);$('document').ready(function () &#123; newClipboard('.btn');&#125;);&lt;/script&gt; 而，我们所做的便是从网页，或者编辑器里直接复制内容，粘贴到左侧的编辑器里： 如 MacDown 2MD MacDown 又或者是直接对网页进行复制： 2MD WebSite]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信视频安卓全屏怎麼解决]]></title>
    <url>%2F2017%2F01%2F18%2FME-HTML%2FVIDEO-%E5%BE%AE%E4%BF%A1%E8%A7%86%E9%A2%91%E5%AE%89%E5%8D%93%E5%85%A8%E5%B1%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[项目预览：https://sywsywsyw.github.io/Video/项目地址：https://github.com/sywsywsyw/Video 第一种 （不可以在视频层覆盖内容）普通播放模式类似腾讯视频文件：「x5-playsinline」。 123&lt;video id="video" class="video" controls="controls" playsinline webkit-playsinline x5-playsinline &gt; &lt;source src="test.mp4" /&gt;&lt;/video&gt; 第二种（可以在视频层覆盖内容）p移动端浏览器中的video元素是比较特别的，早期无论是在iOS还是Android的浏览器中，它都位于页面的最顶层，无法被遮盖。后来这个问题在iOS下得到了解决，但是Android的浏览器则问题依旧。X5是腾讯基于Webkit开发的渲染引擎，它提供了一种名叫「同层播放器」的特殊video元素以解决遮盖问题。 简单使用同层播放器的使用方式跟普通的video元素差别不大，只是需要加上两个X5的自定义属性：「x5-video-player-type」和「x5-video-player-fullscreen」。 下面做一个测试页面嵌入同层播放器： 12345678910111213body &#123; margin: 0; background: #000; font-size: 0.3rem;&#125;.player &#123; width: 100%; height: 4.22rem;&#125;.player .video &#123; width: 100%; height: 100%;&#125; 123 &lt;video id="video" class="video" controls="controls" playsinline x5-video-player-type="h5" x5-video-player-fullscreen="true"&gt; &lt;source src="test.mp4" /&gt;&lt;/video&gt; 点击播放后，video元素占全屏，视频部分默认居中显示： 调整位置按照官方文档所述，只要修改video元素的「object-position」属性，就可以修改视频部分的显示位置，但实际上还要把video元素的宽高设成屏幕的宽高才行： 123.fullscreen .video &#123; object-position: center top;&#125; 123456789101112var player = document.getElementById('video');player.addEventListener('x5videoenterfullscreen', function() &#123; // 设为屏幕尺寸 player.style.width = window.screen.width + 'px'; player.style.height = window.screen.height + 'px'; // 在body上添加样式类以控制全屏下的展示 document.body.classList.add('fullscreen');&#125;);player.addEventListener('x5videoexitfullscreen', function() &#123; player.style.width = player.style.height = ''; document.body.classList.remove('fullscreen');&#125;, false); 效果如下（右图）： 注意把video元素的高设为屏幕高度时，要用「window.screen.height」而不能用「document.documentElement.clientHeight」，因为后者不包含导航栏高度，将会导致无法满屏（如上方左图所示）。 全屏状态下的布局下面加上标题栏：123456789.header &#123; width: 100%; height: 1.14rem; line-height: 1.14rem; background: #fff; font-size: 0.36rem; text-align: center; color: #000;&#125; 123456&lt;header id=&quot;header&quot; class=&quot;header&quot;&gt;标题栏&lt;/header&gt;&lt;div class=&quot;player&quot;&gt; &lt;video id=&quot;video&quot; class=&quot;video&quot; controls=&quot;controls&quot; playsinline x5-video-player-type=&quot;h5&quot; x5-video-player-fullscreen=&quot;true&quot;&gt; &lt;source src=&quot;http://sywsywsyw.github.io/Video/test.mp4&quot; /&gt; &lt;/video&gt;&lt;/div&gt; 然而，点击播放进入全屏状态后，标题栏就消失不见了。既然同层播放器是可以被遮盖的，那就试试绝对定位吧： 123456.fullscreen .header &#123; position: absolute; top: 0; left: 0; z-index: 9999;&#125; 标题栏确实遮挡住视频了，但是就多了一层黑色的渐变以及左右两个按钮（下方左图）。据官方文档所述，这些都是无法移除的。 接下来要做的是把视频下移，使整体UI与进入全屏前保持一致（上方右图）： 123.fullscreen .player .video &#123; object-position: center 1.14rem;&#125; 下一步是在video元素后面添加其他内容：1234567.main &#123; height: 5rem; background: #fff;&#125;.main .inner &#123; padding: 0.3rem;&#125; 123456789&lt;header id="header" class="header"&gt;标题栏&lt;/header&gt;&lt;div class="player"&gt; &lt;video id="video" class="video" controls="controls" playsinline x5-video-player-type="h5" x5-video-player-fullscreen="true"&gt; &lt;source src="test.mp4" /&gt; &lt;/video&gt;&lt;/div&gt;&lt;div id="main" class="main"&gt; &lt;div class="inner"&gt;这里是其他内容&lt;/div&gt;&lt;/div&gt; 然而，进入全屏状态后，内容元素向上偏移了（下方左图）。 明显地，该元素的位置也要下移标题栏的高度：123.fullscreen .main &#123; margin-top: 1.14rem;&#125; 接下来尝试简单的点击事件响应：1234var main = document.getElementById('main');main.addEventListener('click', function() &#123; this.querySelector('.inner').innerHTML = Date.now();&#125;, false); 此时进入全屏状态后点击内容元素是没有任何反应的，因为video元素占满屏，而它的层级偏高，把内容元素挡住了。知道问题之后，解决方案也很简单，只要把main元素的层级调高就好了：123.fullscreen .main &#123; position: relative;&#125; 横屏状态下进入全屏因为同层播放器的全屏状态只能指定一个方向（默认为竖屏），所以播放后还是会强制竖屏。此时整体效果都不太对劲： 因为横屏状态的宽高与竖屏状态下的刚好相反，所以才导致恢复竖屏时的UI异常。因此，进入全屏时要判断一下宽高，如果宽大于高，则将其交换： 1234567891011player.addEventListener('x5videoenterfullscreen', function() &#123; var width = window.screen.width; var height = window.screen.height; if (width &gt; height) &#123; width = [height, height = width][0]; &#125; player.style.width = width + 'px'; player.style.height = height + 'px'; document.body.classList.add('fullscreen');&#125;, false); 其他问题如果播放前页面有滚动条，进入全屏状态下可以滚动吗？答案是确实可以滚动，但是与其叫滚动，不如叫抖动，具体效果可以自己尝试。总之进入全屏状态后就不要用页面的滚动了，而是用局部滚动。此外还应注意，因为调高了层级，如果内容元素太高，就会挡住视频的控制条。 最后一个问题是，播放某些格式的视频时，进度条会出现错乱，即使返回非全屏模式时也还是错乱。 总结 关于同层播放器的支持情况，官方文档有详细描述，最新的微信、QQ以及QQ浏览器都能支持，但是仅限Android平台。 虽然同层播放器可以解决遮盖video元素的问题，但这毕竟还是X5 Only的技术。如果页面要在非腾讯系的产品中打开，那就要注意处理兼容问题。 同层播放器之前的元素，要用绝对定位或固定定位才能展示出来；而其后的元素，只要往下偏移（播放器元素「object-position」指定的偏移）并且提高层级，就与未播放时无异了。 华为手机微信端播放视频使用同层播放画面黑屏怎么解决？问题反馈：http://bbs.mb.qq.com/thread-1524201-1-1.html#2155836 华为机先点击了input框然后再点击播放视频，黑屏的bug，有没有解决方案?解决方案：http://res.imtt.qq.com/qqbrowser/js/test-x5-video-player-type.html早已解决 代码里加canvas标签就可以了 之前没发现同层的例子里就加了canvas 但是还不知道原理。。。 同类文章https://zzx18023.github.io/x5VideoDemo/https://x5.tencent.com/tbs/guide/video.htmlhttps://aotu.io/notes/2017/01/11/mobile-video/https://zhuanlan.zhihu.com/p/27559167https://segmentfault.com/a/1190000010377156?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.iohttps://segmentfault.com/a/1190000008782550http://taobaofed.org/blog/2016/05/23/video-player/http://blog.csdn.net/wqs977/article/details/53166887http://leonshi.com/2015/09/06/mobile-video-play/https://segmentfault.com/a/1190000006857675]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[video在iOS和安卓的属性]]></title>
    <url>%2F2017%2F01%2F17%2FME-HTML%2FVIDEO-%E8%A7%86%E9%A2%91%E5%9C%A8IOS%E5%92%8C%E5%AE%89%E5%8D%93%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[项目预览：https://sywsywsyw.github.io/Video/ 项目地址：https://github.com/sywsywsyw/Video VIDEO-video标签使用 “controls”: true， //是否显示控制条“autoplay”: true， //是否自动播放(iOS不支持自动播放) /预加载选项/“preload”: “auto”,/‘auto’预加载视频（需要浏览器允许）;‘metadata’仅预加载视频meta信息;‘none’不预加载; / “poster”: “myPoster.jpg”, //视频播放前显示的图片“loop”: true, //是否循环播放“width”: 640, //设置播放器宽度“height”: 480, //设置播放器高度 “techOrder”: [“flash”, “html5”], //优先使用的播放模式“streamTimeoutTime”: 30 * 1000, //拉流超时时间，默认30s 1. 视频标签里的内联播放相关属性微信在video标签上新增了一些x5的私有属性，分别是： x5-video-player-type 启用同层播放。取值固定为&#39;h5&#39;。 x5-video-player-fullscreen 是否全屏。取值为&#39;true&#39;或&#39;false&#39;。 x5-video-orientation 视频方向。取值分别为&#39;landscape&#39;、&#39;portrait&#39;或者&#39;landscape|portrait&#39;，分别对应横屏、竖屏及自动旋转（这个应该用的少）。 x5-playsinline 类似iOS播放但是不能覆盖内容 不过有一点需要注意的是，这些都是x5的私有属性，仅适用于Android平台。而跟iOS平台相关的，则是这几个属性： airplay x-webkit-airplay playsinline webkit-playsinline 其中最后两个是iOS平台下的内联播放属性，都是布尔属性，不需要赋值（存在即是true）；前两个是iOS平台下airplay的相关属性（说实话我现在也没搞明白为什么网页需要airplay属性），取值为&#39;allow&#39;或&#39;deny&#39;，通常保险起见用&#39;allow&#39;就可以。 2. CSS的属性选择及取值微信在同层接入规范中提到了object-position这个属性，用于设置视频出现的位置。实际在尝试的过程中，搭配object-fit属性同时使用的效果会比较好。但这两个属性并不是x5私有属性，而是原生的，所以它们同时适用于Android和iOS两个平台。 object-position和object-fit这两个元素主要的作用是为”可替换元素”设置位置和大小。这里的”可替换元素”，指的是内容不受CSS显式控制的元素，比如比较典型的就是&lt;img&gt;、&lt;object&gt;、&lt;video&gt;和表单元素等。 说回视频播放。微信官方的同层接入规范中推荐的做法，是用js动态计算需要的像素值，然后给object-position属性赋值。而我自己尝试了一圈下来，发现object-position这个属性本身支持百分比取值，通常视频默认的值是&#39;50% 50%&#39;，也就是居中；全屏视频一般情况下需要贴底放，所以要把取值改成&#39;0 100%&#39;。 另一个属性object-fit，有点类似background-size属性，用来设置视频在容器内的填充方式，平时用只需要取值&#39;contain&#39;（保持宽高比填满容器）就可以了。不过这里需要留意的是，全屏下，由于视频一般都不会正好填满屏幕（宽高比差异以及输出分辨率没算顶部标题栏），会在顶部留下一条空隙。这条空隙通常是默认黑色的，如果需要更改颜色，首先要加上个&#39;display:block;&#39;（因为video默认是inline的），然后直接改background-color就OK~ 3. 视频封面&lt;video&gt;标签里有一个与视频封面相关的属性poster，但是在使用中发现性能存在一些问题，在Android端打开视频时（加载），会有跳动的感觉，但是如果去掉，在视频加载时（preload取值&#39;auto&#39;，且未用预加载）则会显示空白页面。目前换用了背景图片的方式，但由于视频全屏播放时顶部会有空隙，所以额外加了个background-position: bottom;以及background-size: contain;（取值和视频保持一致），这样设置好的背景在播放视频时就不会漏边了。 4. 设置视频视口大小同层接入规范里推荐在resize事件回调里设置视频视口大小，我习惯直接设置&lt;video&gt;标签的width和height，所以在resize回调里加入： $(&#39;video&#39;) .attr({ &#39;width&#39;: window.innerWidth + &#39;px&#39;, &#39;height&#39;: window.innerHeight + &#39;px&#39; }); 就可以了。 5. UA特性探测同层接入规范里给的，判断是否是同层播放器方法： 在微信等TBS里通过UA判断X5内核版本来区分,当版版本号&gt;036849表示支持 UA示例: Mozilla/5.0 (Linux; Android 4.4.4; OPPO R7 Build/KTU84P) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/37.0.0.0 Mobile MQQBrowser/6.8 TBS/036849 Safari/537.36 MicroMessenger/6.3.27.861 NetType/WIFI Language/zh_CN 在QQ浏览器Android版本中,当浏览器版本&gt;=7.1时开始支持 UA示例：User­Agent: Mozilla/5.0 (Linux; U; Android 4.4.4; zh­cn; OPPO R7 Build/KTU84P) AppleWebKit/537.36 (KHTML, like Gecko)Version/4.0 Chrome/37.0.0.0 MQQBrowser/7.1 Mobile Safari/537.36 在iOS和安卓手机里的微信下播放视频时，会遇到不少问题，例如需要手动点击，视频才会播放，并且视频会跳出微信框，出现控制条，如果视频不是腾讯视频，播放完毕会出现腾讯视频的广告推送等问题 解决办法：给video标签加一些属性，调用h5原生video。 6. 详细解释12345678910111213141516&lt;video id="videoALL" src="video/01.mp4" poster="images/1.jpg" /*视频封面*/ preload="auto" webkit-playsinline="true" /*这个属性是iOS 10中设置可以 让视频在小窗内播放，也就是不是全屏播放*/ playsinline="true" /*iOS微信浏览器支持小窗内播放*/ x-webkit-airplay="allow" x5-video-player-type="h5" /*启用H5播放器,是wechat安卓版特性*/ x5-video-player-fullscreen="true" /*全屏设置， 设置为 true 是防止横屏*/&gt; x5-video-orientation="portraint" /*播放器支付的方向， landscape横屏，portraint竖屏，默认值为竖屏*/ style="object-fit:fill"&gt;&lt;/video&gt; poster=”images/1.jpg”:属性规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。如果未设置该属性，则使用视频的第一帧来代替。 preload=”auto” ：属性规定在页面加载后载入视频。 webkit-playsinline**和playsinline：**视频播放时局域播放，不脱离文档流 。但是这个属性比较特别， 需要嵌入网页的APP比如WeChat中UIwebview 的allowsInlineMediaPlayback = YES webview.allowsInlineMediaPlayback = YES，才能生效。换句话说，如果APP不设置，你页面中加了这标签也无效，这也就是为什么安卓手机WeChat 播放视频总是全屏，因为APP不支持playsinline，而ISO的WeChat却支持。 这里就要补充下，如果是想做全屏直播或者全屏H5体验的用户，ISO需要设置删除 webkit-playsinline 标签，因为你设置 false 是不支持的 ，安卓则不需要，因为默认全屏。但这时候全屏是有播放控件的，无论你有没有设置control。 做直播的可能用得着播放控件，但是全屏H5是不需要的，那么去除全屏播放时候的控件，需要以下设置：同层播放。 x-webkit-airplay=”allow”暂时无法确切的知道其作用，但是小编猜测，这个属性应该是使此视频支持iOS的AirPlay功能。使用AirPlay可以直接从使用iOS的设备上的不同位置播放视频、音乐还有照片文件，也就是说通过AirPlay功能可以实现影音文件的无线播放，当然前提是播放的终端设备也要支持相应的功能。 x5-video-player-type**：**启用同层H5播放器，就是在视频全屏的时候，div可以呈现在视频层上，也是WeChat安卓版特有的属性。同层播放别名也叫做沉浸式播放，播放的时候看似全屏，但是已经除去了control和微信的导航栏，只留下”X”和”&lt;”两键。目前的同层播放器只在Android（包括微信）上生效，暂时不支持iOS。至于为什么同层播放只对安卓开放，是因为安卓不能像ISO一样局域播放，默认的全屏会使得一些界面操作被阻拦，如果是全屏H5还好，但是做直播的话，诸如弹幕那样的功能就无法实现了，所以这时候同层播放的概念就解决了这个问题。不过在测试的过程中发现，不同版本的ISO和安卓效果略有不同。 x5-video-orientation**：**声明播放器支持的方向，可选值landscape 横屏, portraint竖屏。默认值portraint。无论是直播还是全屏H5一般都是竖屏播放，但是这个属性需要x5-video-player-type开启H5模式 x5­-video­-player­-fullscreen**：**全屏设置。它又两个属性值，ture和false，true支持全屏播放，false不支持全屏播放。 其实，ISO 微信浏览器是Chrome的内核，相关的属性都支持，也是为什么X5同层播放不支持的原因。安卓微信浏览器是X5内核，一些属性标签比如playsinline就不支持，所以始终全屏。 还有个问题，在Android的微信里面，就算加上了上面的属性，还会出现上下有黑边，不能全屏的问题。 解决办法：给video加上object-fit: fill;的style属性。如果还是有黑边有可能是视频尺寸不合适。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑、手机常用分辨率]]></title>
    <url>%2F2016%2F09%2F27%2FME-%E8%A7%84%E8%8C%83%2F%E7%94%B5%E8%84%91%E3%80%81%E6%89%8B%E6%9C%BA%E5%B8%B8%E7%94%A8%E5%88%86%E8%BE%A8%E7%8E%87%2F</url>
    <content type="text"><![CDATA[电脑分辨率 分辨率 比例 是否淘汰 1920 * 1080 16:9 主流 1366 * 768 16:9 主流 1600 * 900 16:9 非主流 2560 * 1600 16:10 非主流 1920 * 1200 16:10 非主流 1440 * 900 16:10 非主流 1680 * 1050 16:10 非主流 1024 * 768 4:3 非主流 800 * 600 4:3 非主流 比例 = 高度/宽度 手机分辨率iOS 型号 分辨率 像素密度（ppi） iphonex 2436 * 1125 458 iphone8p 1920 * 1080 401 iphone8 1334 * 750 326 iphone7p 1920 * 1080 401 iphone7 1334 * 750 326 iphone6p 1920 * 1080 401 iphone6s 1334 * 750 326 iphonese 1136 x 640 326 以上数据来源于苹果公司20180327最新数据 android 分辨率 2960 * 1440 2040 * 1080 1280 * 720 2560 * 1440 1920 * 1080 1280 x 720 安卓：2k 2560 x 14401080p 1920 x 1080(华为旗舰，小米旗舰，大多数国产旗舰都采用这一分辨率，国产千元机也采用这一分辨率)720p 1280 x 720(三星低端，国产百元机基本采用这一分辨率)目前鉴于手机功耗控制，手机屏幕分辨率基本都在1080P这一段位，所以安卓主流目前还是1080p，主要还是看产品定位，定位高端就要适配2K 1080P，如果产品是大众软件就不仅是这几种。 Android：主流机型主要为 480x800, 480x854, 540x960, 720x1280, 800x1280 这五种。（非主流机型还包括：240x320, 320x480, 640x960 这三种，其中两种都与 iPhone 一致。）iOS: 主流机型主要为 320x480, 640x960, 640x1136, 1024x768, 2048x1536, 这五种。WP：主流机型主要为 480x800，720x1280, 768x1280 这三种。 以上数据来源于知乎相关问答详细数据]]></content>
      <categories>
        <category>SPEC</category>
      </categories>
      <tags>
        <tag>spec</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信X5]]></title>
    <url>%2F2016%2F09%2F20%2FME-MOB%2F%E5%BE%AE%E4%BF%A1X5%2F</url>
    <content type="text"><![CDATA[关于2018新版微信点击img出现弹出层效果 直接img标签会出现类似朋友弹出层效果，如果不想要则用div包裹起来。 如果是类似于映客直播之类的请使用背景图片做为封面图片1234567891011121314151617&lt;div class=&quot;poster&quot; style=&quot;background-image: url(https://file.feiniaolive.com/fc5026378c1b5540aa7085ab68ce5858?imageView2/1/w/480/h/270/format/png/interlace/1/q/75|imageslim)&quot;&gt;&lt;/div&gt;&lt;style&gt;.poster &#123; width: 100%; height: 100%; position: fixed; top: 0; bottom: 0; left: 0; bottom: 0; background: rgba(0,0,0.7); background-size: cover; background-position: center center; background-repeat: no-repeat;&#125;&lt;/style&gt; 关于微信浏览器中 高度问题导航栏+iphone状态栏高度： 64px = 导航栏44+状态栏20 http://www.25xt.com/allcode/9581.htmlhttp://www.25xt.com/html5css3/14584.html 判断是iOS手机还是andorid手机 进行控制”关注按钮”的位置 解决安卓手机视频最优先123456var ua = navigator.userAgent.toLowerCase();if(/iphone|ipad|ipod/.test(ua))&#123; alert("iphone");&#125;else if(/android/.test(ua))&#123; alert("android");&#125;; 判断微信浏览器内核 手机打开网址 http://debugx5.qq.com/ android是腾讯x5 iOS不是腾讯x5 微信分享今天遇到微信分享输入了””，而在页面中直接用php模板语言输出进js中报错. 123输入: titlte &quot;天空之城&quot;梦想起航js: var title = &apos;&#123;$info.title&#125;&apos;; 但是微信自动把””闭合，不允许这样输出导致js出错，进而微信分享报错 解决: 在页面中输出出来所有的php模板语言然后js获取 html 123&lt;!-- 微信分享 --&gt;&lt;div id="wx-share" wx-title="&#123;$info.chan_name&#125;" wx-desc="&#123;$info.affiche&#125;" wx-link="&#123;$info.redirect_url&#125;" wx-imgUrl="&#123;$info.face_url&#125;"&gt;&lt;/div&gt; js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!-- 配置微信 --&gt;&lt;script src="https://res.wx.qq.com/open/js/jweixin-1.2.0.js"&gt;&lt;/script&gt;wx.config(&#123; debug: false, appId: "&#123;$signPackage.appId&#125;", timestamp: "&#123;$signPackage.timestamp&#125;", nonceStr: "&#123;$signPackage.nonceStr&#125;", signature: "&#123;$signPackage.signature&#125;", jsApiList: ["onMenuShareTimeline", "onMenuShareAppMessage", "onMenuShareQQ", "chooseImage", "uploadImage"]&#125;);wx.ready(function () &#123; var title = $("#wx-share").attr("wx-title") || ""; title = title.replace(/\s/, "").replace(" ", ""); var descript = $("#wx-share").attr("wx-desc"); var shareurl = $("#wx-share").attr("wx-link"); var imgurl = $("#wx-share").attr("wx-imgUrl"); if (descript == '') &#123; descript = title; &#125; //分享给朋友 wx.onMenuShareAppMessage(&#123; title: title, // 分享标题 desc: descript, // 分享链接 link: shareurl, // 分享图标 imgUrl: imgurl, type: 'link', dataUrl: '', success: function () &#123; $(this).minTipsBox(&#123; tipsContent: "分享成功", tipsTime: 1 &#125;); // 用户确认分享后执行的回调函数 //window.location.reload(true); &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); //分享到朋友圈 wx.onMenuShareTimeline(&#123; title: title, // 分享标题 link: shareurl, // 分享链接 imgUrl: imgurl, // 分享图标 success: function () &#123; $(this).minTipsBox(&#123; tipsContent: "分享成功", tipsTime: 1 &#125;); // 用户确认分享后执行的回调函数 //window.location.reload(true); &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); //分享到QQ wx.onMenuShareQQ(&#123; title: title, // 分享标题 desc: descript, // 分享描述 link: shareurl, // 分享链接 imgUrl: imgurl, // 分享图标 success: function () &#123; $(this).minTipsBox(&#123; tipsContent: "分享成功", tipsTime: 1 &#125;); // 用户确认分享后执行的回调函数 //window.location.reload(true); &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); //分享到腾讯微博 wx.onMenuShareWeibo(&#123; title: title, // 分享标题 desc: descript, // 分享描述 link: shareurl, // 分享链接 imgUrl: imgurl, // 分享图标 success: function () &#123; $(this).minTipsBox(&#123; tipsContent: "分享成功", tipsTime: 1 &#125;); // 用户确认分享后执行的回调函数 //window.location.reload(true); &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); //分享到QQ空间 wx.onMenuShareQZone(&#123; title: title, // 分享标题 desc: descript, // 分享描述 link: shareurl, // 分享链接 imgUrl: imgurl, // 分享图标 success: function () &#123; $(this).minTipsBox(&#123; tipsContent: "分享成功", tipsTime: 1 &#125;); // 用户确认分享后执行的回调函数 //window.location.reload(true); &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); wx.hideMenuItems(&#123; menuList: ["menuItem:share:qq", "menuItem:share:weiboApp", "menuItem:favorite", "menuItem:share:facebook", "menuItem:share:QZone", "menuItem:editTag", "menuItem:delete", "menuItem:copyUrl", "menuItem:originPage", "menuItem:readMode", "menuItem:openWithQQBrowser", "menuItem:openWithSafari", "menuItem:share:email", ] // 要隐藏的菜单项，只能隐藏“传播类”和“保护类”按钮，所有menu项见附录3 &#125;); &#125;);wx.error(function(res) &#123; console.log(res.errMsg);&#125;); 微信支付123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 支付$('.xx').click(function(event) &#123; $.ajax(&#123; url: "", type: "POST", //请求方式 GET async: false, data: &#123; 'id': '111' &#125;, dataType: "json", success: function(req) &#123; if (req.zt == 'ok') &#123; jsApiParameters = JSON.parse(req.jsApiParameters); alert(JSON.stringify(jsApiParameters)); callpay(); &#125; else &#123; ok_tips(req.err); &#125; &#125;, error: function(req) &#123; console.log(req); &#125; &#125;);&#125;);//调用微信JS api 支付// 接受一个jsApiParameters的参数对象function jsApiCall() &#123; WeixinJSBridge.invoke( 'getBrandWCPayRequest', jsApiParameters, function(res) &#123; if (res.err_msg == "get_brand_wcpay_request:ok") &#123; ok_tips('支付成功'); $('.ex-paytrue').text('已报名').css('background', '#a6a6a6'); &#125; else &#123; ok_tips('支付失败'); &#125; &#125; );&#125;function callpay() &#123; if (typeof WeixinJSBridge == "undefined") &#123; if (document.addEventListener) &#123; document.addEventListener('WeixinJSBridgeReady', jsApiCall, false); &#125; else if (document.attachEvent) &#123; document.attachEvent('WeixinJSBridgeReady', jsApiCall); document.attachEvent('onWeixinJSBridgeReady', jsApiCall); &#125; &#125; else &#123; jsApiCall(); &#125;&#125;]]></content>
      <categories>
        <category>MOB</category>
      </categories>
      <tags>
        <tag>mob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js截取url参数]]></title>
    <url>%2F2016%2F09%2F09%2FME-JS%2CJQ%2FJS-js%E6%88%AA%E5%8F%96url%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题有个url如下：”http://www.baidu.com/index.php?app=shangpin&amp;act=goodsindex&amp;id=12&quot;,我们该如何获取&quot;id&quot;这个参数的值呢？ 方法很简单，如下，第一种是通过正则，第二种通过切串放进数组的方式： 12345678910111213141516171819202122232425// 第一种正则function getQueryString(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)", "i"); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null; &#125; var app = getQueryString("app"); console.log(app);// 第二种字符串function GetRequest() &#123; var url = location.search; //获取url中"?"符后的字串 var theRequest = new Object(); if (url.indexOf("?") != -1) &#123; var str = url.substr(1); strs = str.split("&amp;"); for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split("=")[0]]=unescape(strs[i].split("=")[1]); &#125; &#125; return theRequest; &#125; var req = GetRequest(); var app = req['app']; console.log(app);]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客]]></title>
    <url>%2F2016%2F08%2F13%2FME-%E6%A1%86%E6%9E%B6%E7%8E%AF%E5%A2%83%2FHexo%2F</url>
    <content type="text"><![CDATA[hexo博客搭建 ##如果是小小白，可以先花时间去了解下： Git GitHub GitHub Pages Hexo Markdown 二、必要配置2.1 GitHub Pages仓库。2.1.1 在Github中创建一个仓库命名为blog。2.2 Git在windows下安装git比较常用的有两种方式。 Git 官方版本的安装 GitHub for Windows 2.2.2 配置Git安装Git之后设置用户名和邮件地址。这样很重要，因为每一个Git的提交都会使用这些信息，并且它会写入你的每一次提交中。 12$ git config --global user.name "username"$ git config --global user.email "username@example.com" 2.2.3相关资料 安装 Git 配置 Git 2.3 Git 与 GitHub2.3.1 Git与GitHub的区别git 是一个版本控制工具，github累死一个远程仓库，用于存放用git指令管理的各种项目。 2.3.2 与github建立联系为了能够在本地使用git管理github上的项目，需要进行一些必要的配置：例如SSH的方法。 2.3.2.1 检查电脑是否已经有SSH keys.12$ ls -al ~/.ssh# Lists the files in you .ssh directory, if they exist() 默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。 2.3.2.2 如果没有SSH key，则生成新的SSH key。12$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"# Creates a new ssh key, using the provided email as a label 之后一路回车即可。 2.3.2.3 向ssh-agent添加key。首先确保ssh-agent可运行：12# start the ssh-agent in the background$ ssh-agent -s 然后添加SSH key：1$ ssh-add ~/.ssh/id_rsa 2.3.2.4 在GitHub添加SSH key。首先，拷贝key：12clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your cllipboard 然后，在GitHub右上方点击头像，选择”Settings”，在左边的”SSH and GPG keys”侧边栏选择”New SSH key”。接着粘贴key，点击”Add key”按钮。最后，测试链接：12$ ssh -T git@github.com# Attempts to ssh to GitHub 如果你看到：123The authenticity of host 'github.com (207.97.227.239)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 就键入：yes。之后将会看到如下信息：12Hi username! You've successfully authenticated, but GitHub does notprovide shell access. 如果报错1connect to host github.com port 22: Connection timed out 解决方法：在.ssh文件夹下，新建一个config文件，记住把扩展名去掉。另注：.ssh文件夹，在你的个人目录下：C–&gt;用户–&gt;登录用户名文件夹下。在config文件夹内写入以下内容：123456Host github.comUser 个人邮箱Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 User 代表你的登录邮箱此时再执行1$ ssh -T git@github.com 如果不成功 请重启gitbash 2.3.3 相关资料 Generating SSH keys 2.4 Hexo2.4.1 安装Hexo安装Hexo相当简单。在安装之前，必须检查电脑中是否已经安装下列应用程序： Node.js Git如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 2.4.2 使用Hexo建站安装完后，在你喜欢的文件夹内（例如f：\Blog），点击鼠标右键选择Git bash，输入以下指令： 1$ hexo init 该命令会在目标文件夹内建立网站所需要的所有文件。接下来是安装依赖包：如果报错1bash: hexo: command not found 则代表没有配置环境变量 请去 node.js 执行 npm install -g hexo-cli 如果已经安装成功会提示出来路径 C:\Users\SUI\AppData\Roaming\npm\node_modules\hexo-cli\bin\然后右键我的电脑 把路径填入环境变量——&gt;用户——&gt;path然后重新在gitbash执行 hexo init 如果不行 请重启电脑再次执行 1$ npm install 这样，我们就已经搭建起本地的Hexo博客了。可以先执行以下命令（在对应文件夹下），然后再浏览器输入localhost:4000查看。 12$ hexo generate$ hexo server 这个博客只是本地的，别人是浏览不了的，之后需要部署到GitHub上。 2.4.3 相关资料 Hexo 官方文档 三、一般的搭建方法在上面，我们已经配置好了所需的所有东西，也成功地搭建了一个本地Hexo博客。现在，需要使用GitHub Pages搭建一个别人能够访问的Hexo博客了。 3.1 使用默认theme我们继续使用上面的文件夹f:\Blog（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml。 默认生成的_config.yml：1234# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: 修改后的_config.yml：1234deploy: type: git repo: 对应仓库的https地址（可以在GitHub对应的仓库中复制） branch: 分支（User Pages为master，Project Pages为gh-pages） 注意：冒号后面要加上一个空格，否则会报错。 如果你的仓库不是使用的github的主仓库，则需要改_config.yml的root： 123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /blog/permalink: :year/:month/:day/:title/permalink_defaults: 为了能够使Hexo部署到GitHub上，需要安装一个插件： 1$ npm install hexo-deployer-git --save 然后，执行下列指令即可完成部署： 12$ hexo generate$ hexo eploydeploy 如果 hexo deploy 报错，请在Git Bash里边打开重新走上面两步 之后，可以通过在浏览器键入：username.github.io/blog进行浏览，开心吧~ 3.2 其他theme如果想要使用其他主题，可以使用git clone将别人的主题拷贝到D:\Hexo\themes下，然后将_config.yml中的theme: landscape改为对应的主题名字。 详细步骤可以参考网上的指南。 提示：上述搭建步骤大量参考了yangruihan的博客，如果你对搭建过程还有疑问，可以查看他的博文如何利用GitHub Pages和Hexo快速搭建个人博客 3.3 发表博文辛苦了这么久，终于回到我们搭建博客最初的目标–写作，现在来看看怎么写博文并发表吧。 3.3.1 新建博文我们可以使用命令新建一篇博文,使用 Git Shell 进入 Hexo 文件夹，输入以下命令： 1hexo new "文章题目" 命令执行完后，就会发现在 Hexo\source_posts 目录中多了一个文件博文名.md，这就是我们刚才新建的博文。 此外，我们也可以直接进入 Hexo\source_posts 目录中，右键新建一个文本文档，将名字改为博文名.md,这样也新建了一篇博文。 3.3.2 新建页面1hexo new page "页面名称" 命令执行完后，就会发现在在 Hexo\source 目录中多了一个文件夹，里面还有一个index.md,这就代表我们新建了一个页面。 3.4 写博文用文本编辑器打开上面新建的博文，如下所示：123456---title: GitHub Pages + Hexo搭建博客date: 2016-08-07 17:04:35tags:categories: Hexo--- 新建的页面略有不同，没有tags和categories标签。 三个”-“后面就是博文的正文内容，接下来就是正儿八经地撰写博文了。 因为我们的博文都是用Markdown语言写的，所以首先，你需要一个好用的Markdown编辑器。其实好用的Markdown编辑器一大堆，这里就给大家推荐两个，如果你用的不习惯也可以换其它的。 本地编辑器：Haroopad,非常小众的一款Markdown编辑器，左边编辑右边实时预览效果，非常轻便； 在线编辑器：MaHua,也是比较小众的一款Markdown编辑器，但效果确实很棒。 现在你可以打开新建的博文了，然而还不造怎么下手对吧。其实很简单，除了特殊格式，其它的你就当做在word里面写文章就行了，具体请看这里的Markdown教程：Markdown——入门指南.3.5 发博文 博文写好了，依然在 Git Shell 中进入 Hexo 文件夹，执行下面几条命令，将博客部署到 GitHub 上： 123hexo cleanhexo generate (若要本地预览就先执行 hexo server)hexo deploy 12345快捷命令：hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 还能组合使用，如： 1hexo d -g 刷新你的个人博客，就可以看到新鲜出炉的博文了。 四、安装主题4.1 选择主题我们刚才使用Hexo生成的博客使用的是Hexo的默认主题：Landscape。 不过hexo 给我们提供了大量的主题，Themes·Hexo 我选择的是这个主题：NexT。 4.2 安装NexT主题Hexo 有两份主要的配置文件_config.yml，一份位于站点根目录下，另一份位于主题目录下。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。 4.2.1 下载 NexT 主题使用 Git Shell 进入 Hexo 文件夹，输入以下两条命令：12cd Hexogit clone https://github.com/iissnan/hexo-theme-next themes/next 4.2.2 启用NexT主题下载完成后，打开 站点配置文件，找到 theme 字段，并将其值更改为 next。 4.2.3 验证主题是否启用执行上面发博文的命令($ hexo d -g)，刷新你的个人博客，就能看到你设置的主题是否启用。 4.3 设置NexT主题和第三方服务安装完NexT之后，还是发现不够漂亮对不对，所以下面我们来慢慢地润色你的个人博客。 4.3.1 选择样式NexT默认的样式其实也比较丑，幸好作者提供了一款十分漂亮的样式:Mist。启用 Mist 很简单，仅需在 主题配置文件中将 #scheme: Mist 前面的 # 注释去掉即可。 4.3.2 菜单设置菜单配置在 主题配置文件 的 menu，下面是菜单配置示例： 1234567menu: #home: / archives: /archives about: /about categories: /categories tags: /tags #commonweal: /404.html 除了home和archives菜单主题自带，其他菜单需要自己建文件夹，非常简单的还是；其它的很多在NexT官方文档里面已经讲的很清楚了,可以自己去研究研究。五、 优化部署与管理 5.1 概述Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html o(^▽^)o ）。 其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。 但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库(ˉ▽ˉ；)…）。 所以，我利用了分支！！！ 简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 下面以我的博客作为例子详细地讲述。 5.2 我的博客搭建流程 github创建仓库，blog 在本地新建的/blog文件夹中运行Git Bash,输入git init(在当前目录新建一个Git代码库); 接着命令行输入git remote add origin https://github.com/用户名/仓库名.git 依次执行git add .、git commit -m “…”、git push origin master提交网站相关的文件；PS: 我是在gh-pages分支上改的，所以提交代码时会提示github上没有master分支，然后点击确定会帮你创建一个master分支，就可以提交成功了； 这样一来，在GitHub上的gxhpersonal.github.io仓库就有两个分支，一个master分支用来存放网站的原始文件，一个gh-pages分支用来存放生成的静态网页。完美( •̀ ω •́ )y！ 5.3 我的博客管理流程5.3.1 日常修改在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 个人习惯： 先依次执行git add .、git commit -m “…”、git push origin master指令将改动推送到GitHub（此时当前分支应为master）； 然后才执行hexo generate -d发布网站到gh-pages分支上。 PS:其实gh-pages分支不用管的，当你运行hexo d -g 的时候就会把生成的博客代码自动提交到gh-pages分支; 虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。 5.3.2 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:gxhpersonal/blog.git拷贝仓库（默认分支为master）； 在本地新拷贝的blog文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 hexo疑难问题解决hexo d命令提交部署博客发生的TaskCanceledException异常今天使用hexo d命令部署博客的时候发生了下面的异常： 123456789101112131415161718# Fatal: TaskCanceledException encountered.# ▒▒ȡ▒▒һ▒▒▒▒▒▒# bash: /dev/tty: No such device or address# error: failed to execute prompt script (exit code 1)# fatal: could not read Username for 'https://github.com': Invalid argument# FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html# Error: Fatal: TaskCanceledException encountered.# ��ȡ��һ��������# bash: /dev/tty: No such device or address# error: failed to execute prompt script (exit code 1)# fatal: could not read Username for 'https://github.com': Invalid argument## at ChildProcess.&lt;anonymous&gt; (E:\gitRep\hellofriday.github.com\node_modules\hexo-util\lib\spawn.js:37:17)# at emitTwo (events.js:87:13)# at ChildProcess.emit (events.js:172:7)# at ChildProcess.cp.emit (E:\gitRep\hellofriday.github.com\node_modules\cross-spawn\lib\enoent.js:40:29)# at maybeClose (internal/child_process.js:818:16)# at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5) 重新安装上传插件，为了能够使Hexo部署到GitHub上，需要安装一个插件： 1$ npm install hexo-deployer-git --save 然后，执行下列指令即可完成部署： 12$ hexo generate$ hexo deploy 确认安装成功后出现 command not found1bash: hexo: command not found 则代表没有配置环境变量 请去 node.js 执行 npm install -g hexo-cli 如果已经安装成功会提示出来路径 C:\Users\SUI\AppData\Roaming\npm\node_modules\hexo-cli\bin\ 然后右键我的电脑 把路径填入环境变量—-&gt;用户—-&gt;path 然后重新在gitbash执行 hexo init 如果不行 请重启电脑再次执行 1$ npm install 更改next样式必须进入 F:\github\sxiaobiblog\themes\next\source\css更改.styl文件 而不是在生成的目录 css中直接更改 解决hexo 分类文件设置为 HEXO 出现路径报错问题人家不然用这个文件分类那就别用，换成HEXOS不就好了啊。 hexo目录乱码问题今天设置目录老是乱码 错误： 正确: 对的 你没看错 hexo的标题不能进行跳级 比较严格 hexo图片路径问题我以前把图片放到F:\github\hexo\.deploy_git\images路径里面和网站设置的头像等等放一起，忽然有了TaskCanceledException异常问题，然后重新安装了上传git插件发现可能图片丢失了。 官方文档： 资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg)的方法访问它们。 https://hexo.io/zh-cn/docs/asset-folders.html 资源不一致报错 原因： GitHub远程仓库中的README.md文件不在本地仓库中。 因为我手动在github创建了一个README.md文件 解决方案： 1$ git pull --rebase origin master hexo功能优化给博客设置个人域名获取ip,如果你手上恰好有一个为自己购买的域名，那正适合你刚刚搭建好的博客。我的域名是在aliyun.com上购买的，在我搭建这个博客时候就想，我应该有一个自己的域名，换了很多组合选了一个还算满意的。当你看到这里的时候，如果也有冲动，那赶紧去看看吧，说不定过两天就没有了呢 首先，需要知道你的博客所在的服务器地址 1$ ping arobot.github.io 得到我的博客在151.101.73.147上面，记下这个ip，会在后面用到。 设置域名解析进入阿里云的云解析，可以为你购买的域名添加解析。 域名解析 选项 描述 记录类型 选择A 主机记录 配置两项。一项填写@;另一项填写www 其他的选择默认就行，配置好的结果如下 配置结果 完成了域名的解析工作之后，在博客的source文件下新建文件名为CNAME的文件，将你的域名不加协议填写进去。例如sxiaobi.com。 个性化域名的配置就完成了，将博客部署上去就能够通过自己的域名链接过来。 或者可以在项目文件夹中添加自己的网址 ！注意事项 如果启用了自定义域名，则项目文件不能是 sywsywsyw.github.io 必须换个名字 否则会出现各种乱七八糟的报错 官方文档:(https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/) hexo新增搜索功能NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 安装步骤安装 hexo-generator-search在站点的根目录下执行以下命令： $ npm install hexo-generator-search –save | 安装 hexo-generator-searchdb在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb –save | 启用搜索编辑 站点配置文件，新增以下内容到任意位置： search:path: search.xmlfield: postformat: htmllimit: 10000 介绍其他两个插件给博客添加feed安装hexo-generator-feed $ npm install hexo-generator-feed –save | 配置到站点配置文件_config.yml Plugins: http://hexo.io/plugins/RSS订阅plugin: hexo-generator-feed Feed Atomfeed:type: atompath: atom.xmllimit: 20 | 最后，在你next主题下的_config.yml下，添加RSS订阅链接即可： rss: /atom.xml | 给博客生成一个站点地图安装hexo-generator-seo-friendly-sitemap $ npm install hexo-generator-seo-friendly-sitemap –save | 在站点配置文件_config.yml 中添加 sitemap:path: sitemap.xml]]></content>
      <categories>
        <category>环境框架语言</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团队代码规范]]></title>
    <url>%2F2016%2F08%2F11%2FME-%E8%A7%84%E8%8C%83%2F%E5%9B%A2%E9%98%9F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[这是团队开发中基本约定的一些内容，请认真遵守，如果有补充的请联系管理。 codeBug分级需要立即更正的情况： 数据提交出错 BOSS们要求的 … 需要当天更正的情况： 样式出错 用户体验的优化 12345678910111213141516171819什么时候用img? 什么时候用background?看图片类型，内容型的用img；装饰型的用background-image项目开发 什么图片应该压缩？ 什么图片不应该压缩？设计师给的效果图 尽量不要压缩 看情况 如果特别大 例如banner示例图时建议压缩用户上传的资料 超过300K以上的尽量压缩 然后后端 必须做分割操作 切成不同比例大小的图片 （可使用第三方如：七牛....）css兼容性处理的时候私有浏览器前缀在前 w3c样式在后-moz-box-sizing: border-box;-webkit-box-sizing: border-box;box-sizing: border-box; 代码方面所有的html代码小写 所有的代码只能使用小写,适用于标签名，类名，标签的属性以及属性值（tetxt/CDATA例外，作为内容时例外） 12&lt;ul class="lists"&gt;&lt;li&gt;&lt;/li&gt;&lt;ul&gt;&lt;div class="name"&gt;&lt;a&gt;&lt;/a&gt;&lt;/div&gt; 使用html的doctype1&lt;!doctype html&gt; 页面编码使用UTF-81&lt;meat charset="utf-8"&gt; 页面内容lang为zh-Hans-CN 这条规范基于国际标准RFC 4646,使用单一的zh和zh-CN都属于废弃语法。和中文有关的lang值如下： zh-Hans 简体中文 zh-Hans-CN 大陆地区使用的简体中文 zh-Hans-HK 香港地区使用的简体中文 zh-Hans-MO 澳门地区使用的简体中文 zh-Hans-SG 新加坡使用的简体中文 zh-Hans-TW 台湾地区使用的简体中文 zh-Hant 繁体中文 zh-Hant-CN 大陆地区使用的繁体中文 zh-Hant-HK 香港地区使用的繁体中文 zh-Hant-MO 澳门地区使用的繁体中文 zh-Hant-SG 新加坡使用的繁体中文 zh-Hant-TW 台湾地区使用的繁体中文 文件命名 文件扩展名必须为.html index.html 首页或者引导页 main.html 首页主页 download.html 下载页面 vedio.html 视频 文件名中只可以由英文字母a~z、排序数字0~9或者间隔符-组成 文件命中禁止包含特殊符号，比如空格、$等 文件名区分大小写，统一使用小写字母 为了更好的表达语义，文件名使用英文单词命名，或英文简写 图片 图片统一存放在图片服务器中，注意修饰性图片和内容类型图片的分开放置，如：图片的存放文件夹建议使用img命名来存放logo,合并的图片等页面固定元素的图片，images放一些开发会动态调用的头像，剧照图等。 图片格式和大小 图片格式：图片格式允许采用gif/jpg/png/wep,平衡图片质量与文件大小，适当运用css sprite理念合并并修饰图片，不过分损失质量情况下尽量减小页面下载数据量，图片单张体积不能超过150K,jpg文件必须进行压缩，一般60%品质即可，如果图片质量不好，可以提高到80% 图片的引用 图片路径需要使用绝对路径方式 所有img元素必须加上alt属性，修饰性图片alt属性内容留空，内容性质图片的alt中填写相应的内容 必须加上width和height属性，值为它的原大小，但不要对他进行缩放。 1&lt;img src="themes/mall/new/img/logo.png" width="60" height="60" alt="飞鸟播客"&gt; 图片命名 图片后缀命名统一使用小写 使用间隔符-隔开,一般背景图片用bg-开头，测试图片用img-,按钮图片用btn-,图标图片用icon-开头，聚合图片用spr-开头，后面跟英文单词，不推荐使用汉语拼音，如果名称过长，适当使用缩写 1bg-body.jpg spr-home.png img-promo.jpg btn-submit.png icon-game.png 图片存放 图片存放在想对应的html文件的style中 注释 正确的注释规范 感叹号后面两个横线，结束时使用两个横线，不要再注释中使用--,--只能发生在XHTML注释的开头和技术，也就是说在内容中它们不再有效，例子: 12&lt;!--这里是注释 -这里是注释--&gt;&lt;!-- -这里是注释 -这里是注释 ---&gt; 用等号或者空格替换内部的虚线，这样的是正确的 1&lt;!--这里是注释========这里是注释&gt; IE条件注释（IE10已不支持注释） 12345678910111213141516171819&lt;!-- [if IE]&gt;这里只有ie浏览器才可以显示&lt;![endif]--&gt;&lt;!-- [if !IE]&gt;这里只有非ie浏览器才可以显示&lt;! &lt;![endif]--&gt;&lt;!--[if IE 6]&gt;这里只有ie6浏览器才可以显示&lt;![endif]--&gt;&lt;!--[if lt IE 9]&gt;这里只有ie9以下浏览器才可以显示&lt;![endif]--&gt;&lt;!--[if lte IE 8]&gt;这里只有ie8以及ie8以下浏览器才可以显示&lt;![endif]--&gt; 脚本中文转换unicode 为了防止外链脚本没有申明正确编码导致乱码问题，脚本中如果用到中文，必须转为unicode码 1234/* 不推荐 */document.write("关于飞鸟播客")/* 推荐 */document.write("\u5173\u4e8e\u817e\u8baf\u6e38\u620f") 去掉类型属性 不要为css,js使用类型属性，特别说明类型（type）属性是多余的，在HTML5中默认已包含 12345678&lt;!--不推荐--&gt;&lt;link href="../css/comm.css" rel="stylesheet" type="text/css" /&gt;&lt;script type="text/javascript"&gt;&lt;!--mce:0--&gt;&lt;/script&gt;&lt;script src="common.js" type="text/javascript"&gt;&lt;!--推荐--&gt;&lt;link href="../css/comm.css" rel="stylesheet" /&gt;&lt;script type="text/javascript"&gt;&lt;!--mce:1--&gt;&lt;/script&gt;&lt;script src="common.js"&gt; 去掉自闭合元素/闭合符 为半闭合元素加上’/‘闭合符是没有必要的，声明为HTML5以后的doctype,所有的浏览器都会正确处理，常见的半闭合元素：img input br hr 1234&lt;!--不推荐--&gt;&lt;br /&gt;&lt;hr /&gt;&lt;img src="/wiki/" /&gt;&lt;input type="text" /&gt;&lt;!--推荐--&gt;&lt;br&gt;&lt;hr&gt;&lt;img src="/wiki/"&gt;&lt;input type="text"&gt; 对于”&lt;””&gt;”之类的符号进行实体转义 在HTML中不能使用小于号”&lt;”和”&gt;”,以免浏览器误认为他们是标签。若果希望正确显示预留字符，我们必须在HTML源代码中使用字符字体（character entities） 1234&lt;!--不推荐--&gt;&lt;a href="/wiki/"&gt;more&gt;&gt;&lt;/a&gt;&lt;!--推荐--&gt;&lt;a href="/wiki/"&gt;more&amp;gt;&amp;lt;&lt;/a&gt; 元素嵌套规范 段落元素与标题元素只能嵌套内联元素 12345&lt;!--不推荐--&gt;&lt;a&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;/a&gt; &lt;h2&gt;&lt;div&gt;&lt;/div&gt;&lt;/h2&gt;&lt;!--推荐--&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;/span&gt;&lt;/h2&gt; CSS规范命名规范使用类选择器，尽量避免使用ID选择器定义样式 ID在一个页面的唯一性导致了如果以ID伟选择器来写CSS,就无法重用 用字母开头 必须用字母开头命名选择器，这样可以在所有浏览器下面兼容 不允许出现单个字母的类选择器出现 不允许命名带有广告等英文的单词，例如ad,adv,adver,advertisin以免该模块被浏览器当做垃圾广告过滤掉。 全小写，并使用’-‘连字符 下划线’_’禁止出现在class命名中，统一用’-‘连字符 禁止驼峰式命名 命名简约而不失语义 避免过度简写，.icon足够表示这是一个图标，而.i不代表任何意思 使用有意义的名称，使用结构化或者作用目标相关的，而不失抽象的名称 文件命名举例 基本样式：base.css框架布局：layout.css模块样式：module.css全局样式：global.css字体样式：font.css首页样式：index.css链接样式：link.css 常用类/ID命名举例 常用的类命名应该尽量以常用英文单词为准，并在适当的地方加以注释。部分命名解释约定：整页.wp页眉.header页脚.footer导航.nav主体内容.main侧边栏.side标志.logo搜索.search登录.login注册.reg标题.tit-…副标题.subtit-…按钮.btn-…链接.link-…背景图片.bg-…列表.list-…表哥.tb-…标签.tag-…视频.video-…联系.contact Reset参考 使用时按需配置，去除冗余 精简版（适用于一般的游戏类官网、专题）12345678910body,h1,h2,h3,h4,h5,h6,p,ul,ol,li,input,select,textarea,div,table,td,th,tr,dt,dd,dl&#123;margin:0;padding:0;&#125;h1,h2,h3,h4,h5,h6&#123;font-size:100%;font-weight:normal;&#125;ul,ol&#123;list-style:none;&#125;strong,b&#123;font-weight:normal;&#125;em,i&#123;font-style:normal;&#125;table&#123;border-spacing:0;border-collapse:collapse;&#125;img&#123;border:0;vertical-align:middle;&#125;input,select&#123;vertical-align:middle;font-size:100%;line-height:150%;font-family:arial,'\5FAE\8F6F\96C5\9ED1',sans-serif;-webkit-appearance:none;&#125;a&#123;text-decoration:none;outline:none;hide-focus:expression(this.hideFocus=true);background-color:transparent;-webkit-tap-highlight-color:transparent;&#125;body&#123;min-width:1000px;font:14px/1.5 arial,"\5FAE\8F6F\96C5\9ED1",sans-serif;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;&#125; 通用版（基本适用于所有的页面）12345678910111213body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td&#123;margin:0;padding:0&#125;table&#123;border-collapse:collapse;border-spacing:0&#125;fieldset,img&#123;border:0&#125;address,caption,cite,code,dfn,em,strong,th,var&#123;font-style:normal;font-weight:normal&#125;ol,ul&#123;list-style:none&#125;caption,th&#123;text-align:left&#125;h1,h2,h3,h4,h5,h6&#123;font-size:100%;font-weight:normal&#125;q:before,q:after&#123;content:''&#125;abbr,acronym&#123;border:0;font-variant:normal&#125;sup&#123;vertical-align:text-top&#125;sub&#123;vertical-align:text-bottom&#125;input,textarea,select&#123;font-family:inherit;font-size:inherit;font-weight:inherit&#125;input,textarea,select&#123;*font-size:100%&#125; 通用版（支持HTML5）123456789101112131415body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td,hr,button,article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section&#123;margin:0;padding:0&#125;article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section &#123; display:block; &#125;table&#123;border-collapse:collapse;border-spacing:0&#125;audio,canvas,video &#123; display: inline-block;*display: inline;*zoom: 1;&#125;fieldset,img&#123;border:0&#125;address,caption,cite,code,dfn,em,strong,th,var&#123;font-style:normal;font-weight:normal&#125;ol,ul&#123;list-style:none&#125;caption,th&#123;text-align:left&#125;h1,h2,h3,h4,h5,h6&#123;font-size:100%;font-weight:normal&#125;q:before,q:after&#123;content:''&#125;abbr,acronym&#123;border:0;font-variant:normal&#125;sup&#123;vertical-align:text-top&#125;sub&#123;vertical-align:text-bottom&#125;input,textarea,select&#123;font-family:inherit;font-size:inherit;font-weight:inherit&#125;input,textarea,select&#123;*font-size:100%&#125; 代码风格css属性值需要用到引号时，统一使用单引号为单个css选择器或新申明开启新行css属性书写顺序 布局定位属性 自身属性 文本属性 其他属性 CSS3属性123456789/* 这些属性只是最常用到的, 并不代表全部 *//* 布局定位属性 */display / list-style / position（相应的 top,right,bottom,left） / float / clear / visibility / overflow/* 自身属性 */width / height / margin / padding / border / background/* 文本属性 */color / font / text-decoration / text-align / vertical-align / white- space / break-word/* 其他（CSS3） */content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient ... css浏览器私有前缀书写格式 私有格式在前面，标准格式在后面。先写带有浏览器私有标志的，后写W3C标准的 123456789selectors&#123; background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffffff), color-stop(100%,#eff2f4)); background: -webkit-linear-gradient(top, #ffffff 0%,#eff2f4 100%); background: -moz-linear-gradient(top, #ffffff 0%, #eff2f4 100%); background: -ms-linear-gradient(top, #ffffff 0%,#eff2f4 100%); background: -o-linear-gradient(top, #ffffff 0%,#eff2f4 100%); background: linear-gradient(to bottom, #ffffff 0%,#eff2f4 100%); filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#eff2f4',GradientType=0 );&#125; 不要以没有寓意的标签做为选择器 强烈建议不要使用，因为这会造成大面积污染，除非你可以断定现在或将来你的这个选择器不会污染其他同类 css单行书写法 每个CSS选择符的主申明区的属性在同一行内书写，每个属性之间空一格 1selectors&#123; height: 30px; padding-bottom: 10px; border-bottom: 1px solid #858585; margin-bottom: 10px; &#125; css多行书写法12345selectors&#123;height: 30px;padding-bottom: 10px;border-bottom: 1px solid #858585;&#125; 除非必要情况否则尽量少书写行内进行控制样式用CSS控制交互或视觉的变化，js只要增加ClassName 利用css一次性更改多个节点样式，避免多次渲染，提高渲染效率 需要在结构中注释此类交互 注释行间注释 直接写于属性值后面，如： 1.search&#123;background: #333 url(../img/search.gif) no-repeat;/*定义搜索框的背景*/ 整段注释 分别在开始及结束地方加入注释，如： 123/*=====搜索条=====*/.search &#123;background: #333 url(../img/search.gif) no-repeat;&#125;/*=====搜索条结束=====*/ 注意：以下写法不可取 12.news/* 这里是高度自动撑 */ &#123;line-height:1.5&#125;.news &#123;/*line-height:1.5 这里是高度自动撑 */&#125; 理由很简单，注释是ie6的hack方法之一，所以这样写容易让ie6误解。提示：尽量不要使用中文注释，无论是html也好css js也罢，这样会让ie6出现问题 尽量使用简单的英文或者拼音，在版本发布的时候 尽量剔除注释内容，尽可能的减少文件的字节数。 Hack（本项目中暂时不用这么考虑） 原则上不允许使用Hack - 很多不兼容问题可以通过改变方法和思路来解决，并非一定需要Hack，根据经验你完全可以绕过某些兼容问题。 - 一种合理的结构和合理的样式，是极少会碰到兼容问题的。 -由于浏览器自身缺陷，我们无法避开的时候，可以允许使用适当的Hack。 统一Hack方法1234567891011.element&#123;color:#000; /*w3c标准*/[;color:#f00;]; /*Webkit(chrome和safari)*/color:#666\9; /*IE8*/*color:#999; /*IE7*/_color:#333; /*IE6*/&#125;:root .element&#123;color:#0f0\9;&#125; /*IE9*/@media all and (-webkit-min-device-pixel-ratio:10000), not all and (-webkit-min-device-pixel-ratio:0) &#123; .element&#123;color:#336699;&#125;&#125; /*opera*/@-moz-document url-prefix()&#123; .element&#123;color:#f1f1f1;&#125;&#125; /*Firefox*/ 简写css颜色属性值1234/* 不推荐 */selectors&#123; color:#000000; background-color:#ddeeff;&#125;/* 推荐 */selectors&#123; color:#000; background-color:#def;&#125; 删除css属性值为0的单位 0就是0，任何单位都不需要 1234/*不推荐*/selectors&#123; margin:0px; padding:0px;&#125;/*推荐*/selectors&#123; margin:0; padding:0;&#125; 删除无用css样式 好处：（1）删除无用的样式后可以缩减样式文件的体积，加快资源下载速度;第二，对于浏览器而言，所有的样式规则都会被接卸后索引起来，即使当前页面无匹配规则。移除无匹配规则，减少索引性，加快浏览器查找速度。 1234567/* 不推荐 */selectors&#123; font-size:12px;&#125;.nav&#123;&#125;.nav-item&#123; height:20px;&#125;/* 推荐 */selectors&#123; font-size:12px;&#125;.nav-item&#123; height:20px;&#125; JS规范 页面中书写到js时请务必参考本规范Javascript是控制用户与页面交互、前端与后台数据交互的重要工具，在我们的日常工作中应用非常广泛。为了有效提高代码的质量，基于“易维护，易调试，高性能”的原则，参考业界知名团队的规范与指南指定本ugifan，大家在编写Javascript代码时，应尽量遵守本规范，提高自己的代码质量。 命名 Javascript是区分大小写的语言，在对Javascript的变量、函数、常量等命名时，应该遵循Javascript自身采用的命名规则，以保持代码的一致性。具体规则如下： 常量： Javascript自身不支持常量，在程序中如果要定义“禁止定义后改变”的变量，可以参考其他编程语言，采用下划线分割的全大写字符串来定义。例如:PAGEBASECOLOR、COOKIR_PREFIX等。 变量： 首字母小写，驼峰命名法，原则上采用名词及名词短语，描述该变量代表的数据。例如：videoID,userLevel,linkToHome,btnDown,totalPages 函数： 首字母小写，驼峰命名法，原则上函数采用动词及动词短语，以描述该函数的行为，对象采用名词及名词词组。例如：login(),checkLogin(),showVideo(),switchTabs(),changLevel(),addClass(),loadScript(), 类及命名空间： 首字母大写、驼峰命名法。例如：LoginManager,Dialog,LazyLoader,FlashManager 文件名： 全小写，单词间可以不分割或用连接线“-”分隔，文件名可以加.min/.debug表示文件状态，例如：common.js(一般的文件名)、milo.min.js(压缩后的文件)、common.debug.js(未压缩、调试用的文件)。 可读性： 在未做压缩处理的源代码中，类、变量、函数的命名应该尽量具有语义、应当避免“a”、“b”、“yy”这类无意义的命名(循环语句中的i/j/k/除外)。代码的压缩，应该采用专门的工具（如YUI Compressor、Google Closure）来进行，不要人为用无意义的命名来减少代码量。 变量定义和初始化 javascript并不强调变量在使用前必须定义，但是如果没有使用var 关键字来定义变量，则这个变量就会变成全局变量，可能会造成对同名全局变量的覆盖，在多人写作开发，引入多个库或多个js文件的情况下，容易导致变量名冲突等问题。因此，对变量的定义和初始化建议参照一下规则：总是将代码包裹成一个IIFE（Immediateley-Invoked Function Expression）,用一创建独立隔绝的定义域。这一举措可以防止全局命名空间被污染。IIFE还可以确保你的代码不会轻易被其他全局命名空间的代码所修改。 不推荐 123456var x = 10, y = 100;// Declaring variables in the global scope is resulting in global scope pollution. All variables declared like this// will be stored in the window object. This is very unclean and needs to be avoided.console.log(window.x + ' ' + window.y); 推荐 1234567891011// We declare a IIFE and pass parameters into the function that we will use from the global space(function(log, w, undefined)&#123; 'use strict'; var x = 10, y = 100; // Will output 'true true' log((w.x === undefined) + ' ' + (w.y === undefined));&#125;(window.console.log, window)); 虽然Javascript是一门弱类型语言，变量的数据类型可以随时自由转换，但是在实际使用中，依然建议大家避免用同一个变量存储不同类型的数据。 在定义变量的同时对其初始化是很好的编程实践，这可以避免后续忘记给变量赋值而直接使用它引发的”undefined”错误。 代码格式大括号 前大括号始终位于当前行末尾，后大括号新起一行并与代码块的首行保持相同缩进对齐，数组和对象的快速定义可以例外。例如 _数组和对象的快速定义: 12var arr = [1,2,3];var obj = &#123;a:1, b:2, c:3&#125;; 数组初始化12345678this.rows_ = [ '"Slartibartfast" ', '"Zaphod Beeblebrox" ', '"Ford Prefect" ', '"Arthur Dent" ', '"Marvin the Paranoid Android" ', 'the.mice@magrathea.com']; 函数的调用12345678tvp.play('u1134234422','mod_player', &#123; autoplay: '1', width: 600, height: 449, controls: '1'&#125;);];` 函数定义123function functionName() &#123; // function codes&#125; 代码块123456789if (condition == true) &#123; // do something&#125; else &#123; // do something else&#125;for(var i = 0; i &lt; data.length; i++) &#123; // loop body&#125; 12345/* 不推荐 */if(event.target) return event.target;else return event.srcElement; 123456/* 推荐 */if(event.target) &#123; return event.target;&#125; else &#123; return event.srcElement;&#125; 对于代码块，始终用大括号包裹，对于单行判断、while循环等可以省略大括号的，一律不省略。 ###引号 在处理字符串时，优先使用单引号，仅在必须的情况下才使用双引号。这不仅能保持代码的一致性、缩小代码文件大小，在创建包含HTML代码的字符串时，这尤其有利，例如： 1var msg = '&lt;li class="msg"&gt;这是一条信息&lt;/li&gt;'; ####### 分号 所有的语句必须用分号结尾所有的代码块不得使用分号结尾 注释 对代码中的类、方法、属性、复杂的实现逻辑等，应该加上必要的注释。注释的格式参照JSDoc语法。常见的注释范例： 1234567891011121314151617181920212223/** * 这是一段常规注释，不包含调用参数和返回值 */ function doSomething() &#123; alert('hello'); &#125;/** * 这是一个有调用参数和返回值的函数 * 注释里要用@param和@return分别标注参数和返回值 * * @param &#123;number&#125; idx 每次执行时当前元素在数组中的索引 * @param &#123;object&#125; dom 当前循环到的元素 * @return &#123;string&#125; 每次循环时返回当前元素的id */ $.each = function(idx, dom) &#123; if(dom = this[idx]) &#123; return dom.id; &#125; else &#123; return ''; &#125; &#125;;` 技巧和实践eval函数（魔鬼） eval()不但混淆语境还很危险，总会有比他更好，更清晰，更安全的另一种方案来写你的代码，因此尽量不要使用eval()函数。 this关键字 只在对象构造器，方法和设定的闭包中使用this关键字。this的语义在此有些误导。它时而指向全局对象（大多数时），时而指向调用者的定义域（在eval()中），时而指向DOM树中的某一个节点，（当用事件处理绑定到 HTML 属性上时），时而指向一个新创建的对象（在构造器中），还时而指向其它的一些对象（如果函数被 call() 和 apply() 执行和调用时）。 正因为它是如此的容易被搞错，请限制它的使用场景 在构造函数中 在对象的方法中（包括由此创建出的闭包内） True和False:布尔值表达式 以下用作布尔表达式时均为False: 1234nullundefinded&apos;&apos;//空字符串0// 数字0 以下用作布尔表达式时均为Ture 123&apos;0&apos;//字符串‘0’[] //空数组&#123;&#125; //空对象 基于以上结论，我们可以把下面的代码 1if(x != null) 精简为：1if(x) 同样，如果你想判断一个变量既不为null，也不是空字符串的话，不必用： 1if (x != null &amp;&amp; x != '') 只需要： 1if (x) 即可。 注意，有一些很容易搞错的布尔表达式。以下列举出一部分： Boolean(‘0’) == true‘0’ != true0 != null0 == [] //特别注意，0 == false, [] == true, 但是 0 == []0 == falseBoolean(null) == false // 这个也要特别注意null != truenull != falseBoolean(undefined) == falseundefined != trueundefined != falseBoolean([]) == true[] != true[] == falseBoolean({}) == true{} != true{} != falseNaN != trueNaN != falseBoolean(NaN) == false 这里很容易混淆，最好自己多实践一下。能用if(x)来判断的，不一定能用if(x == true)来判断。 ###三目运算符 对于下面这种简单的true返回a,false返回b的判断： 12345if(condition) &#123; return a;&#125; else &#123; return b;&#125; 可以采用三目运算符简写为： 1return (condition) ? a : b; 在生成HTML时，这种表达方式尤其有用： 12var cls = isFocused ? 'class="chk-focus"' : '';var checkbox = '&lt;input type="checkbox" /&gt;' 逻辑运算符 由逻辑与(&amp;&amp;)和逻辑或(||)运算符连接的表达式会从左到右依次执行，直到遇到满足条件为止，因此逻辑或(||)运算符也可以当作默认值运算符来用。比如： 123456789function doSomething(jQuery) &#123; var $; if (jQuery) &#123; $ = jQuery; &#125; else &#123; $ = window.jQuery; &#125; // other code&#125; 可以简写为：123function doSomething(jQuery) &#123; var $ = jQuery || window.jQuery;&#125; 逻辑与(&amp;&amp;)也可以做类似的使用（当满足左边条件时执行右边的语句）。比如123if('function' == typeof pgvMain) &#123; pgvMain();&#125; 可以简写为：1'function' == typeof pgvMain &amp;&amp; pgvMain(); ####### 节点遍历操作 我们经常有类似这样的操作：获取一组节点，然后对这个节点数组（节点列表）进行遍历。通常代码是这样的： 1234var divs = document.getElementsByTagName('div');for (var i = 0; i &lt; divs.length; i++) &#123; doSomething(divs[i]);&#125; 这样的操作，假如获取节点长度(divs.length)的复杂度是O(n)，获取某个子节点的复杂度也是O(n)，则由于每次要计算节点长度，因而遍历一遍所有节点，这个算法的时间复杂度就为O(n^2)。用以下方法可降低时间复杂度：12345var divs = document.getElementsByTagName('div');var size = divs.length;for (var i = 0; i &lt; size; i++) &#123; doSomething(divs[i]);&#125; 这里先把节点长度存到一个局部变量中，以后每次循环不再计算节点长度，因此总的时间复杂度变为了O(n) + 1; 还可以用另一种方法 1234var divs = document.getElementsByTagName('div');for (var i = 0, div; div = divs[i]; i++) &#123; doSomething(div);&#125; 这种算法由于完全不检查节点长度，只是每次循环的时候取出一个子节点，因此时间复杂度降低到了O(n)。]]></content>
      <categories>
        <category>SPEC</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php入门]]></title>
    <url>%2F2016%2F08%2F07%2FME-%E6%A1%86%E6%9E%B6%E7%8E%AF%E5%A2%83%2FPHP-PHP%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[部分常用php代码 打印数据但是会打断页面其他信息加载 1&lt;php&gt;print_r($info);exit;&lt;/php&gt; 打印数据不会打断页面其他信息加载 1&lt;php&gt;print_r($info);&lt;/php&gt; json数据 1&lt;php&gt;echo json_encode($info);&lt;/php&gt; php标签的说明可以通过memory_get_usage();来获取当前php消耗的内存;知识点 php的注释是用”//“来表示; php的字符连接是用”.”来链接; php的赋值运算符号是”=” 和js一样; php的每句指令结束符号必须是”;”结束; php代码的写法 &lt;?php echo $name = “土豆先生”;?&gt; 变量声明 $name = “土豆先生”; $_name = “土豆先生”; $N_name = “土豆先生”; 变量声明的规则：必须用字母或者”_”下划线开头,不可以用数字开头;可以使用驼峰命名法 $myName; 可以用字母，数字，汉字，下划线组成但是不能用特殊符号区分大小写 变量的数据类型 字符串类型，整型，浮点型，数组，布尔类型，资源（特殊类型，可以偷窥一些服务器上面的资料）,空类型(NUll,null,对大小写不敏感，unset()对某个变量进行注销定义) 当字符串中有引号怎么办（1）双引号中嵌套单引号 （2）单引号中嵌套双引号 （3）使用转义符号 当字符串中包含”$”变量的时候 如果是双引号引用数据则会将变量输出；如果是单引号引入数据会将变量当成字符串输出出来 当字符串中有很长的字符的时候，可以使用heredoc结构形式的方法来解决问题，首先使用定界符表示字符串（&lt;&lt;&lt;）然后再字符串后面提供一个表示符号GOD然后接字符串，最后提供这个标识符结束字符串123456789&lt;?php $string1 = &lt;&lt;&lt;GOD;我有一只小毛驴，我从来也不骑。有一天我心血来潮，骑着去赶集。我手里拿着小皮鞭，我心里正得意。不知怎么哗啦啦啦啦，我摔了一身泥.GOD;echo $string1;?&gt; 常量是什么？ 在脚本中值不变,分为自定义常量和系统常量。 自定义常量就是自己定义的一些常量,而定义的常量（系统常量）是通过PHP函数define()函数中定义的; 可以通过memory_get_usage();来获取当前php消耗的内存; 知识点 php的注释是用”//“来表示单行 用”/**/“来表示多行; php的字符连接是用”.”来链接; php的赋值运算符号是”=” 和js一样; php的每句指令结束符号必须是”;”结束; php代码的写法 &lt;?php echo $name =”土豆先生”;?&gt; 变量声明 $name =”土豆先生”; $_name =”土豆先生”; $N_name =”土豆先生”; 变量声明的规则：必须用字母或者”_”下划线开头,不可以用数字开头;可以使用驼峰命名法 $myName; 可以用字母，数字，汉字，下划线组成但是不能用特殊符号区分大小写 变量的数据类型 字符串类型，整型，浮点型，数组，布尔类型，资源（特殊类型，可以偷窥一些服务器上面的资料）,空类型(NUll,null,对大小写不敏感，unset()对某个变量进行注销定义) is_integer(变量名) 判断是否为整数 is_string() is_double()浮点型 is_object()对象 is_array() 当字符串中有引号怎么办（1）双引号中嵌套单引号 （2）单引号中嵌套双引号 （3）使用转义符号 当字符串中包含”$”变量的时候 如果是双引号引用数据则会将变量输出；如果是单引号引入数据会将变量当成字符串输出出来 当字符串中有很长的字符的时候，可以使用heredoc结构形式的方法来解决问题，首先使用定界符表示字符串（&lt;&lt;&lt;）然后再字符串后面提供一个表示符号GOD然后接字符串，最后提供这个标识符结束字符串 &lt;?php$string1 = &lt;&lt;常量是什么？ 在脚本中值不变,分为自定义常量和系统常量。 自定义常量就是自己定义的一些常量,而定义的常量（系统常量）是通过PHP函数define()函数中定义的; if (a=b){}elseif (){} 不同于js strtolower() 将数值转为小写]]></content>
      <categories>
        <category>环境框架语言</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax]]></title>
    <url>%2F2016%2F07%2F19%2FME-JS%2CJQ%2FAJAX-ajax%2F</url>
    <content type="text"><![CDATA[AJAX 是与服务器交换数据并更新部分网页的艺术，是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 ajax 原理创建 XMLHttpRequest 对象1var obj = new XMLHttpRequest(); 向服务器发送请求 如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法： 12xmlhttp.open("GET","test1.txt",true);xmlhttp.send(); 方法 描述 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) 将请求发送到服务器。 string：仅用于 POST 请求 open需要三个参数 第一个参数定义发送请求所使用的方法（GET 还是 POST） GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 第二个参数规定服务器端脚本的 URL(该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）)。 第三个参数规定应当对请求进行异步地处理(true（异步）或 false（同步）)。 异步 - True 或 False？ 对于 web 开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。 我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。 send() 方法可将请求送往服务器。 onreadystatechange 属性存有处理服务器响应的函数。 readyState 属性存有服务器响应的状态信息。每当 readyState 改变时，onreadystatechange 函数就会被执行。 readyState状态值 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status状态 200: “OK”404: 未找到页面 原生ajax写法1234567891011121314151617181920212223var Ajax=&#123; get: function (url,fn)&#123; var obj=new XMLHttpRequest(); // XMLHttpRequest对象用于在后台与服务器交换数据 obj.open('GET',url,true); obj.onreadystatechange=function()&#123; if (obj.readyState == 4 &amp;&amp; obj.status == 200 || obj.status == 304) &#123; // readyState==4说明请求已完成 fn.call(this, obj.responseText); //从服务器获得数据 &#125; &#125;; obj.send(null); &#125;, post: function (url, data, fn) &#123; var obj = new XMLHttpRequest(); obj.open("POST", url, true); obj.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); // 发送信息至服务器时内容编码类型 obj.onreadystatechange = function () &#123; if (obj.readyState == 4 &amp;&amp; (obj.status == 200 || obj.status == 304)) &#123; // 304未修改 fn.call(this, obj.responseText); &#125; &#125;; obj.send(data); &#125;&#125; http://www.w3school.com.cn/ajax/index.asp Ajax中同步和异步的概念 var xhr=new XMLHttpRequest() xhr.open(‘get’,’/robot.txt’,true) xhr.send() document.body.innerHTML +=xhr.response; var xhr=new XMLHttpRequest(); xhr.addEventListener(‘readystatechange’,function(){ //检测到状态改变 // console.log(xhr.response) if( this.readyState !== 4){ 状态改变 return; } if( this.status === 200 || this.status === 304){ document.body.innerHTML += xhr.response } }) xhr.open(‘get’,’/robot.txt’,true); xhr.send(); x 随意 ML 标记语言 HTTP 超文本传输协议 Request 请求 执行队列 异步 可执行 待执行 ajax问题怎么使用ajax上传图片 建议图片一定通过异步上传。就是单独开一个接口。避免上传图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 获取其他表单数据var form=document.forms[0];var formData = new FormData(form); //这里连带form里的其他参数也一起提交了,如果不需要提交其他参数可以直接FormData无参数的构造函数//convertBase64UrlToBlob函数是将base64编码转换为BlobformData.append("imageName",convertBase64UrlToBlob(base64Codes)); //append函数的第一个参数是后台获取数据的参数名,和html标签的input的name属性功能相同/** * 将以base64的图片url数据转换为Blob * @param urlData * 用url方式表示的base64图片数据 */function convertBase64UrlToBlob(urlData)&#123; var bytes=window.atob(urlData.split(',')[1]); //去掉url的头，并转换为byte //处理异常,将ascii码小于0的转换为大于0 var ab = new ArrayBuffer(bytes.length); var ia = new Uint8Array(ab); for (var i = 0; i &lt; bytes.length; i++) &#123; ia[i] = bytes.charCodeAt(i); &#125; return new Blob( [ab] , &#123;type : 'image/png'&#125;);&#125;//创建FormData对象var data = new FormData();//为FormData对象添加数据var file = $('#inputfile')[0].files[0];data.append('upload_file', file); //第一个参数为参数名，第二个为参数值console.log(data.get('imageName'));$.ajax(&#123; url: "http://www.baidu.com", //请求的url地址 type: "POST", //请求方式 GET data: data, //参数值 cache: false, contentType: false, // 告诉jQuery不要去处理发送的数据 processData: false, // 告诉jQuery不要去设置Content-Type请求头 beforeSend: function () &#123;//请求前的处理 alert("正在加载"); &#125;, success: function (req) &#123; //请求成功时处理 console.log(req); &#125;, complete: function () &#123; //请求完成的处理 alert("修改完成"); &#125;, error: function (req) &#123; //请求出错处理 console.log(req); &#125;&#125;); ajax请求返回状态为200但还是进入error事件 最近遇到一个问题，发送一个ajax请求，请求成功了，并且放回状态为200，但是就是不进入success事件，添加error事件竟进入了error事件。 1234567891011$.ajax(&#123; url:$WEB_ROOT_PATH+"/dataLevel/dataLevelCtrl.htm?BLHMI=findBasicDataLevel", type:"post", dataType:"json", async:false, success:function(data)&#123; var dataScore = data; &#125;,error:function()&#123; alert("出错啦！"); &#125; &#125;); 出错原因：dataType:”json”,而后台返回的数据不符合json规范。解决方法：先将dataType设置为text，这样就可以进入success方法了，查看data数据究竟是什么。我的data为：｛”success”:success｝，可以看出第二个success没有引号包裹，不符合json规范，故而不能转换为json对象。之后的解决方法就很好办了。一种是修改后台返回值，二种是直接解析text返回的值。 PHP Ajax 跨域问题最佳解决方案 本文通过设置Access-Control-Allow-Origin来实现跨域。例如：客户端的域名是client.runoob.com，而请求的域名是server.runoob.com。如果直接使用ajax访问，会有以下错误：XMLHttpRequest cannot load http://server.runoob.com/server.php. No ‘Access-Control-Allow-Origin’ header is present on the requested resource.Origin ‘http://client.runoob.com‘ is therefore not allowed access.1、允许单个域名访问指定某域名（http://client.runoob.com）跨域访问，则只需在http://server.runoob.com/server.php文件头部添加如下代码：header(‘Access-Control-Allow-Origin:http://client.runoob.com‘);2、允许多个域名访问指定多个域名（http://client1.runoob.com、http://client2.runoob.com等）跨域访问，则只需在http://server.runoob.com/server.php文件头部添加如下代码：$origin = isset($_SERVER[‘HTTP_ORIGIN’])? $_SERVER[‘HTTP_ORIGIN’] : ‘’; $allow_origin = array( ‘http://client1.runoob.com‘, ‘http://client2.runoob.com‘);if(in_array($origin, $allow_origin)){ header(‘Access-Control-Allow-Origin:’.$origin);}3、允许所有域名访问允许所有域名访问则只需在http://server.runoob.com/server.php文件头部添加如下代码：header(‘Access-Control-Allow-Origin:*’); ajax4种方式$.ajax(),$.getjson(),$.get(),$.post()的区别和差异$.ajax() $.ajax()是jquery中通用的一个ajax封装，其语法的格式为：$.ajax(options)其中options是一个object类型，它指明了本次ajax调用的具体参数，这里我把最常用的几个参数附上123456789101112131415161718// 新写法// 代码更加美化$.ajax(&#123; url: '/path/to/file', type: 'default GET (Other values: POST)', dataType: 'default: Intelligent Guess (Other values: xml, json, script, or html)', data: &#123;param1: 'value1'&#125;&#125;).done(function() &#123; console.log("success");&#125;).fail(function() &#123; console.log("error");&#125;).always(function() &#123; console.log("complete");&#125;); 1234567891011121314151617181920212223242526272829303132333435363738$.ajax(&#123; url: "", type: "POST", //请求方式 GET async: false, data: &#123; "xx": "xxx" &#125;, dataType: "json", beforeSend: function () &#123; console.log("正在加载"); &#125;, success: function (req) &#123; console.log(req); &#125;, complete: function () &#123; console.log("修改完成"); &#125;, error: function (req) &#123; console.log(req); &#125;&#125;);$.ajax(&#123; url: "", //请求的url地址 type: "POST", //请求方式 GET async: false, //请求是否异步，默认为异步，这也是ajax重要特性 飞鸟项目默认为同步了 注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 data: &#123; "xx": "xxx" &#125;, //参数值 dataType: "json", //返回格式为json beforeSend: function () &#123;//请求前的处理 console.log("正在加载"); &#125;, success: function (req) &#123; //请求成功时处理 console.log(req); &#125;, complete: function () &#123; //请求完成的处理 console.log("修改完成"); &#125;, error: function (req) &#123; //请求出错处理 console.log(req); &#125;&#125;); $.getJSON() $.getJSON()是专门为ajax获取json数据而设置的，并且支持跨域调用，其语法的格式为：getJSON(url,[data],[callback])url：string类型， 发送请求地址 data ：可选参数， 待发送 Key/value 参数 ，同get，post类型的data callback ：可选参数，载入成功时回调函数，同get，post类型的callbackJSON是一种理想的数据传输格式，它能够很好的融合与JavaScript或其他宿主语言，并且可以被JS直接使用。使用JSON相比传统的通过 GET、POST直接发送“裸体”数据，在结构上更为合理，也更为安全。至于jQuery的getJSON()函数，只是设置了JSON参数的 ajax()函数的一个简化版本。这个函数也是可以跨域使用的，相比get()、post()有一定优势。另外这个函数可以通过把请求url写 成”myurl?callback=X”这种格式，让程序执行回调函数X。 1234567$.getJSON("http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&amp;tagmode=any&amp;format=json&amp;jsoncallback=?",function(req)&#123; $.each(req.items,function(i, item)&#123; if(i == vnum)&#123; $("&lt;img src="" + item.media.m + "" title="" + item.title + "" /&gt;").appendTo("#showjson"); &#125; &#125;);&#125;); $.post() $.post()方法使用POST方式来进行异步请求，它的语法结构为：$.post(url,[data],[callback],[type])这个方法和$.get()用法差不多，唯独多了一个type参数，那么这里就只介绍type参数吧，其他的参考上面$.get()的。type：type为请求的数据类型，可以是html,xml,json等类型，如果我们设置这个参数为：json，那么返回的格式则是json格式的，如果没有设置，就和$.get()返回的格式一样，都是字符串的。123456789101112$.post( "submit.aspx",&#123; id: '2016', name: '笔者', &#125;,function(data,state)&#123; //这里显示从服务器返回的数据 console.log(data); //这里显示返回的状态 console.log(state); &#125;, "json") $.get() $.get()方法使用GET方式来进行异步请求，它的语法结构为：$.get( url [, data] [, callback] )url：string类型，ajax请求的地址。data：可选参数，object类型，发送至服务器的key/value数据会作为QueryString附加到请求URL中。callback：可选参数，function类型，当ajax返回成功时自动调用该函数。1234567891011$.get( "url",&#123; id: '2016', name: '笔者', &#125;,function(data,state)&#123; //这里显示从服务器返回的数据 console.log(data); //这里显示返回的状态 console.log(state); &#125;) 参数options 类型：Object 可选。AJAX 请求设置。所有选项都是可选的。 async 类型：Boolean 默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 beforeSend(XHR) 类型：Function 发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。 XMLHttpRequest 对象是唯一的参数。 这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。 cache 类型：Boolean 默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。 jQuery 1.2 新功能。 complete(XHR, TS) 类型：Function 请求完成后回调函数 (请求成功或失败之后均调用)。 参数： XMLHttpRequest 对象和一个描述请求类型的字符串。 这是一个 Ajax 事件。 contentType 类型：String 默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。 默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax() 那么它必定会发送给服务器（即使没有数据要发送）。 context 类型：Object 这个对象用于设置 Ajax 相关回调函数的上下文。也就是说，让回调函数内 this 指向这个对象（如果不设定这个参数，那么 this 就指向调用本次 AJAX 请求时传递的 options 参数）。比如指定一个 DOM 元素作为 context 参数，这样就设置了 success 回调函数的上下文为这个 DOM 元素。 就像这样： $.ajax({ url: “test.html”, context: document.body, success: function(){ $(this).addClass(“done”); }}); data 类型：String 发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 dataFilter 类型：Function 给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。 dataType 类型：String 预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。在 1.4 中，JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值: “xml”: 返回 XML 文档，可用 jQuery 处理。 “html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。 “script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载） “json”: 返回 JSON 数据 。 “jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 “text”: 返回纯文本字符串 error 类型：Function 默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。 有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。 如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。 这是一个 Ajax 事件。 global 类型：Boolean 是否触发全局 AJAX 事件。默认值: true。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 Ajax 事件。 ifModified 类型：Boolean 仅在服务器数据改变时获取新数据。默认值: false。使用 HTTP 包 Last-Modified 头信息判断。在 jQuery 1.4 中，它也会检查服务器指定的 ‘etag’ 来确定数据没有被修改过。 jsonp 类型：String 在一个 jsonp 请求中重写回调函数的名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。 jsonpCallback 类型：String 为 jsonp 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让 jQuery 生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存 GET 请求的时候，指定这个回调函数名。 password 类型：String 用于响应 HTTP 访问认证请求的密码 processData 类型：Boolean 默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。 scriptCharset 类型：String 只有当请求时 dataType 为 “jsonp” 或 “script”，并且 type 是 “GET” 才会用于强制修改 charset。通常只在本地和远程的内容编码不同时使用。 success 类型：Function 请求成功后的回调函数。 参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。 这是一个 Ajax 事件。 traditional 类型：Boolean 如果你想要用传统的方式来序列化数据，那么就设置为 true。请参考工具分类下面的 jQuery.param 方法。 timeout 类型：Number 设置请求超时时间（毫秒）。此设置将覆盖全局设置。 type 类型：String 默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 url 类型：String 默认值: 当前页地址。发送请求的地址。 username 类型：String 用于响应 HTTP 访问认证请求的用户名。 xhr 类型：Function 需要返回一个 XMLHttpRequest 对象。默认在 IE 下是 ActiveXObject 而其他情况下是 XMLHttpRequest 。用于重写或者提供一个增强的 XMLHttpRequest 对象。这个参数在 jQuery 1.3 以前不可用。 回调函数如果要处理 $.ajax() 得到的数据，则需要使用回调函数：beforeSend、error、dataFilter、success、complete。 beforeSend在发送请求之前调用，并且传入一个 XMLHttpRequest 作为参数。 error在请求出错时调用。传入 XMLHttpRequest 对象，描述错误类型的字符串以及一个异常对象（如果有的话） dataFilter在请求成功之后调用。传入返回的数据以及 “dataType” 参数的值。并且必须返回新的数据（可能是处理过的）传递给 success 回调函数。 success当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。 complete当请求完成之后调用这个函数，无论成功或失败。传入 XMLHttpRequest 对象，以及一个包含成功或错误代码的字符串。 数据类型$.ajax() 函数依赖服务器提供的信息来处理返回的数据。如果服务器报告说返回的数据是 XML，那么返回的结果就可以用普通的 XML 方法或者 jQuery 的选择器来遍历。如果见得到其他类型，比如 HTML，则数据就以文本形式来对待。 通过 dataType 选项还可以指定其他不同数据处理方式。除了单纯的 XML，还可以指定 html、json、jsonp、script 或者 text。 其中，text 和 xml 类型返回的数据不会经过处理。数据仅仅简单的将 XMLHttpRequest 的 responseText 或 responseHTML 属性传递给 success 回调函数。 注意：我们必须确保网页服务器报告的 MIME 类型与我们选择的 dataType 所匹配。比如说，XML的话，服务器端就必须声明 text/xml 或者 application/xml 来获得一致的结果。 如果指定为 html 类型，任何内嵌的 JavaScript 都会在 HTML 作为一个字符串返回之前执行。类似地，指定 script 类型的话，也会先执行服务器端生成 JavaScript，然后再把脚本作为一个文本数据返回。 如果指定为 json 类型，则会把获取到的数据作为一个 JavaScript 对象来解析，并且把构建好的对象作为结果返回。为了实现这个目的，它首先尝试使用 JSON.parse()。如果浏览器不支持，则使用一个函数来构建。 JSON 数据是一种能很方便通过 JavaScript 解析的结构化数据。如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用 jsonp 类型。使用这种类型的话，会创建一个查询字符串参数 callback=? ，这个参数会加在请求的 URL 后面。服务器端应当在 JSON 数据前加上回调函数名，以便完成一个有效的 JSONP 请求。如果要指定回调函数的参数名来取代默认的 callback，可以通过设置 $.ajax() 的 jsonp 参数。 注意：JSONP 是 JSON 格式的扩展。它要求一些服务器端的代码来检测并处理查询字符串参数。 如果指定了 script 或者 jsonp 类型，那么当从服务器接收到数据时，实际上是用了 标签而不是 XMLHttpRequest 对象。这种情况下，$.ajax() 不再返回一个 XMLHttpRequest 对象，并且也不会传递事件处理函数，比如 beforeSend。 发送数据到服务器默认情况下，Ajax 请求使用 GET 方法。如果要使用 POST 方法，可以设定 type 参数值。这个选项也会影响 data 选项中的内容如何发送到服务器。 data 选项既可以包含一个查询字符串，比如 key1=value1&amp;key2=value2 ，也可以是一个映射，比如 {key1: ‘value1’, key2: ‘value2’} 。如果使用了后者的形式，则数据再发送器会被转换成查询字符串。这个处理过程也可以通过设置 processData 选项为 false 来回避。如果我们希望发送一个 XML 对象给服务器时，这种处理可能并不合适。并且在这种情况下，我们也应当改变 contentType 选项的值，用其他合适的 MIME 类型来取代默认的 application/x-www-form-urlencoded 。 高级选项global 选项用于阻止响应注册的回调函数，比如 .ajaxSend，或者 ajaxError，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在 ajaxSend 里禁用这个。 如果服务器需要 HTTP 认证，可以使用用户名和密码可以通过 username 和 password 选项来设置。 Ajax 请求是限时的，所以错误警告被捕获并处理后，可以用来提升用户体验。请求超时这个参数通常就保留其默认值，要不就通过 jQuery.ajaxSetup 来全局设定，很少为特定的请求重新设置 timeout 选项。 默认情况下，请求总会被发出去，但浏览器有可能从它的缓存中调取数据。要禁止使用缓存的结果，可以设置 cache 参数为 false。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置 ifModified 为 true。 scriptCharset 允许给 标签的请求设定一个特定的字符集，用于 script 或者 jsonp 类似的数据。当脚本和页面字符集不同时，这特别好用。 Ajax 的第一个字母是 asynchronous 的开头字母，这意味着所有的操作都是并行的，完成的顺序没有前后关系。$.ajax() 的 async 参数总是设置成true，这标志着在请求开始后，其他代码依然能够执行。强烈不建议把这个选项设置成 false，这意味着所有的请求都不再是异步的了，这也会导致浏览器被锁死。 $.ajax 函数返回它创建的 XMLHttpRequest 对象。通常 jQuery 只在内部处理并创建这个对象，但用户也可以通过 xhr 选项来传递一个自己创建的 xhr 对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的 .abort() 可以在请求完成前挂起请求。]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2016%2F07%2F17%2FME-%E6%A1%86%E6%9E%B6%E7%8E%AF%E5%A2%83%2FGIT-git%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 验证 1git --version 摘抄自 廖雪峰的官方网站 Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一），一个可以自动帮你记录每次文件的改动，还可以让同事协作编辑的神器。 Git的特点 1、速度：Git在本地上保存着所有当前项目的版本和更新，并且Git中的绝大多数操作都在本地，无需连网，所以处理起来速度。 2、简单的设计：Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。 3、完全分布式模式：每个人电脑上都有一个完整的版本库，而且它支持离线工作（大部分操作都是本地执行），本地提交可以稍后提交到服务器上。 4、对非线性开发模式的强力支持：允许上千个并行开发的分支。 1、配置git12$ git config --global user.name "your name"$ git config --global user.email "email@example.com" 注意git config命令的–global参数，顾名思义，用了这个参数，表示你这台电脑上所有的Git仓库都会使用这个配置(这个应该很好理解)，当然你也可以对某个仓库指定不同的uer.name和user.email。当然如果大家没有配置该信息的话， 一般情况下在git提交时会使用机器名，这样肯定不方便了。所以笔者建议大家都配置明确的user.name 和 user.email信息。 配置好了后，大家可以使用git config -l来查看当前的git配置列表。 2、远程仓库及其与本地仓库交互2.1、创建GitHub账号及获取SSH秘钥对首先你必须有github帐号，账号请大家自行注册。由于你的本地Git仓库和远程GitHub仓库之间的传输是通过SSH协议加密的，因此需要进行一些设置。 2.1.1、检查电脑是否已经有SSH keys。12$ ls -al ~/.ssh# Lists the files in your .ssh directory, if they exist 默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。 2.1.2、如果没有SSH key，则生成新的SSH key。12$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"# Creates a new ssh key, using the provided email as a label 之后一路回车即可（如果你用的着设置密码，请自行设置）。 2.1.3、在GitHub添加SSH key。首先，拷贝key： 12clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your cllipboard 然后，在GitHub右上方点击头像，选择”Settings”，在右边的”Personal settings”侧边栏选择”SSH Keys”。接着粘贴key，点击”Add key”按钮。最后，测试链接： 12$ ssh -T git@github.com# Attempts to ssh to GitHub 如果你看到： 123The authenticity of host 'github.com (207.97.227.239)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 就键入：yes。之后将会看到如下信息： 12Hi username! You've successfully authenticated, but GitHub does notprovide shell access. 2.2、创建远程仓库有了GitBub账号，登录后找到右上角的”Create new…”，点击New repository(即创建一个新的仓库)，然后在Repository name中输入mygit（仓库名），点击Create repository即可。新建远程仓库 2.3、将本地仓库推送至远程仓库现在这个远程的mygit仓库还是空的，下面我们把上面创建的本地mygit仓库推送到这个远程仓库中。首先要把一个已有的本地仓库与之关联，然后把本地仓库的内容推送到GitHub仓库。 依次执行下面几步 123456789$ git init #创建本地仓库$ git add index.html$ git status (可以查看本地更新了什么，一般不用)$ git commit -m "2017072157"&lt;!-- $ git remote rm origin --&gt;$ git remote add origin git@github.com:username/repository.git #将本地仓库和远程仓库关联，并命名为origin(可以随意修改) (记得将username命名成自己的github的名字)$ git push -u origin master#使用git push -u origin master第一次推送master分支的所有内容#以后每次本地提交后，就只需敲入命令git push origin master推送最新修改到远程即可。 可能出现的报错 12345678$ git push origin masterTo github.com:sywsywsyw/Card-Verify.git! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to 'git@github.com:sywsywsyw/Card-Verify.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 原因： GitHub远程仓库中的README.md文件不在本地仓库中。 因为我手动在github创建了一个README.md文件 解决方案： 1$ git pull --rebase origin master 1error:src refspec master does not match any 原因： 目录中没有文件，空目录是不能提交上去的 12Your branch is up-to-date with 'origin/master'. nothing to commit, working tree clean 意思太明显了,该文件又回到了以前… 2.4、从远程仓库clone至本地只需执行一条命令 1$ git clone git@github.com:username/repository.git 3、工作区&lt;–&gt;暂存区&lt;–&gt;版本库 和 git status工作区(Working area)：就是咱们创建的本地文件夹。 暂存区(Staging area)：对文件操作(也就是需要提交的文件修改)的地方就叫暂存区。–注意：这里的修改包括对文件的增删改。 版本库(Repository)：就是你所看到的的那个隐藏的”.git”目录，它就是咱们的版本(仓)库。 3.1、git status命令可以让咱们随时了解当前版本库的状态下面我们目录下新建一个index.txt，然后咱们用git status来查看该文件的状态：利用 cat index.txt 可以查看文档内容 1234567891011$ git statusOn branch masterInitial commitUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) index.txt（红色字体）nothing added to commit but untracked files present (use "git add" to track) 红色告诉我们该本件的状态仍处于工作区。 接着咱们通过git add hellogit.txt命令将该本件添加到暂存区： 1$ git add index.txt 执行上面命令后，没有任何显示，就说明添加成功,用git status 查看一下 123456789$ git statusOn branch masterInitial commitChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: index.txt 说明已经添加进了暂存区 4、分支管理4.1、创建一个gh-pages分支，然后切换到gh-pages分支上12$ git branch gh-pages$ git checkout gh-pages 可以用git branch 来查看当前分支 4.2、 推送本地项目的子文件到gh-pages123456$ git branch gh-pages$ git checkout gh-pages$ git add "dist"$ git commit -m "first commit"$ git subtree push --prefix=dist origin gh-pages# dist为本地项目的子文件名 4.3、合并分支合并分支命令很简单，但请注意：合并分支一定要切换至主分支，并且要合并的分支必须commit了： 1git merge gh-pages 合并分支只是合并内容，并不会删除分支 4.4、删除分支1git branch -d gh-pages 好了，咱又只剩master分支了，可以看到无论是创建、合并还是删除分支，速度都是非常迅速的，这也是Git一个非常重要的特点，而且工作中常用分支来完成咱们的工作。 新建代码库12345//在当前目录新建一个git代码库$ git init//克隆一个项目$ git clone https://github.com/gxhpersonal/blog.git 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123// 设置提交代码时的用户信息git config --global user.name &quot;gxhpersonal&quot;git config --global user.email &quot;991158744@qq.com&quot; 增加/删除文件123456789101112//添加当前目录的所有文件到暂存区$ git add .//添加每个变化前，都会要求确认//对于同一个文件的多处变化，可以实现分次提交$ git add -p//删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...//改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交12345//提交暂存区到仓库区$ git commit -m &quot;改的内容标题&quot;//提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a 新建的分支push到远程服务器上1$ git push -u origin [分支名] 远程代码取到本地1$ git pull 本地代码提交到远程仓库1$ git push 分支1234567891011121314151617181920212223242526272829 //列出所有本地分支$ git branch//列出所有远程分支$ git branch -r//列出所有本地分支和远程分支$ git branch -a//新建一个分支，但依然停留在当前分支$ git branch [branch-name]//新建一个分支，并切换到该分支$ git checkout -b [branch]//切换到指定分支，并更新工作区$ git checkout [branch-name]//切换到上一个分支$ git checkout -//合并指定分支到当前分支$ git merge [branch]//选择一个commit，合并进当前分支$ git cherry-pick [commit]//删除分支$ git branch -d [branch-name] 指定某个commit到指定的分支1.执行git log -3 –graph test，查看test分支下的commit: 注：commit 后面的hash值代表某个commit，这里把”2e1ada53819d46557b24ee7376dc61d37a06939d”这个commit提交到master。 2.执行git checkout master，切换到master分支。 3.执行 git cherry-pick 2e1ada53819d46557b24ee7376dc61d37a06939d，该commit便被提交到了master分支。 到此，”2e1ada53819d46557b24ee7376dc61d37a06939d”这个commit便被提交到了master分支。]]></content>
      <categories>
        <category>环境框架语言</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2016%2F07%2F17%2FME-%E5%B7%A5%E5%85%B7%2FGIT-git%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 验证 1git --version 摘抄自 廖雪峰的官方网站 Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一），一个可以自动帮你记录每次文件的改动，还可以让同事协作编辑的神器。 Git的特点 1、速度：Git在本地上保存着所有当前项目的版本和更新，并且Git中的绝大多数操作都在本地，无需连网，所以处理起来速度。 2、简单的设计：Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。 3、完全分布式模式：每个人电脑上都有一个完整的版本库，而且它支持离线工作（大部分操作都是本地执行），本地提交可以稍后提交到服务器上。 4、对非线性开发模式的强力支持：允许上千个并行开发的分支。 1、配置git12$ git config --global user.name "your name"$ git config --global user.email "email@example.com" 注意git config命令的–global参数，顾名思义，用了这个参数，表示你这台电脑上所有的Git仓库都会使用这个配置(这个应该很好理解)，当然你也可以对某个仓库指定不同的uer.name和user.email。当然如果大家没有配置该信息的话， 一般情况下在git提交时会使用机器名，这样肯定不方便了。所以笔者建议大家都配置明确的user.name 和 user.email信息。 配置好了后，大家可以使用git config -l来查看当前的git配置列表。 2、远程仓库及其与本地仓库交互2.1、创建GitHub账号及获取SSH秘钥对首先你必须有github帐号，账号请大家自行注册。由于你的本地Git仓库和远程GitHub仓库之间的传输是通过SSH协议加密的，因此需要进行一些设置。 2.1.1、检查电脑是否已经有SSH keys。12$ ls -al ~/.ssh# Lists the files in your .ssh directory, if they exist 默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。 2.1.2、如果没有SSH key，则生成新的SSH key。12$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"# Creates a new ssh key, using the provided email as a label 之后一路回车即可（如果你用的着设置密码，请自行设置）。 2.1.3、在GitHub添加SSH key。首先，拷贝key： 12clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your cllipboard 然后，在GitHub右上方点击头像，选择”Settings”，在右边的”Personal settings”侧边栏选择”SSH Keys”。接着粘贴key，点击”Add key”按钮。最后，测试链接： 12$ ssh -T git@github.com# Attempts to ssh to GitHub 如果你看到： 123The authenticity of host 'github.com (207.97.227.239)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 就键入：yes。之后将会看到如下信息： 12Hi username! You've successfully authenticated, but GitHub does notprovide shell access. 2.2、创建远程仓库有了GitBub账号，登录后找到右上角的”Create new…”，点击New repository(即创建一个新的仓库)，然后在Repository name中输入mygit（仓库名），点击Create repository即可。新建远程仓库 2.3、将本地仓库推送至远程仓库现在这个远程的mygit仓库还是空的，下面我们把上面创建的本地mygit仓库推送到这个远程仓库中。首先要把一个已有的本地仓库与之关联，然后把本地仓库的内容推送到GitHub仓库。 依次执行下面几步 123456789$ git init #创建本地仓库$ git add index.html$ git status (可以查看本地更新了什么，一般不用)$ git commit -m "2017072157"&lt;!-- $ git remote rm origin --&gt;$ git remote add origin git@github.com:username/repository.git #将本地仓库和远程仓库关联，并命名为origin(可以随意修改) (记得将username命名成自己的github的名字)$ git push -u origin master#使用git push -u origin master第一次推送master分支的所有内容#以后每次本地提交后，就只需敲入命令git push origin master推送最新修改到远程即可。 可能出现的报错 12345678$ git push origin masterTo github.com:sywsywsyw/Card-Verify.git! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to 'git@github.com:sywsywsyw/Card-Verify.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 原因： GitHub远程仓库中的README.md文件不在本地仓库中。 因为我手动在github创建了一个README.md文件 解决方案： 1$ git pull --rebase origin master 1error:src refspec master does not match any 原因： 目录中没有文件，空目录是不能提交上去的 12Your branch is up-to-date with 'origin/master'. nothing to commit, working tree clean 意思太明显了,该文件又回到了以前… 2.4、从远程仓库clone至本地只需执行一条命令 1$ git clone git@github.com:username/repository.git 3、工作区&lt;–&gt;暂存区&lt;–&gt;版本库 和 git status工作区(Working area)：就是咱们创建的本地文件夹。 暂存区(Staging area)：对文件操作(也就是需要提交的文件修改)的地方就叫暂存区。–注意：这里的修改包括对文件的增删改。 版本库(Repository)：就是你所看到的的那个隐藏的”.git”目录，它就是咱们的版本(仓)库。 3.1、git status命令可以让咱们随时了解当前版本库的状态下面我们目录下新建一个index.txt，然后咱们用git status来查看该文件的状态：利用 cat index.txt 可以查看文档内容 1234567891011$ git statusOn branch masterInitial commitUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) index.txt（红色字体）nothing added to commit but untracked files present (use "git add" to track) 红色告诉我们该本件的状态仍处于工作区。 接着咱们通过git add hellogit.txt命令将该本件添加到暂存区： 1$ git add index.txt 执行上面命令后，没有任何显示，就说明添加成功,用git status 查看一下 123456789$ git statusOn branch masterInitial commitChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: index.txt 说明已经添加进了暂存区 4、分支管理4.1、创建一个gh-pages分支，然后切换到gh-pages分支上12$ git branch gh-pages$ git checkout gh-pages 可以用git branch 来查看当前分支 4.2、 推送本地项目的子文件到gh-pages123456$ git branch gh-pages$ git checkout gh-pages$ git add "dist"$ git commit -m "first commit"$ git subtree push --prefix=dist origin gh-pages# dist为本地项目的子文件名 4.3、合并分支合并分支命令很简单，但请注意：合并分支一定要切换至主分支，并且要合并的分支必须commit了： 1git merge gh-pages 合并分支只是合并内容，并不会删除分支 4.4、删除分支1git branch -d gh-pages 好了，咱又只剩master分支了，可以看到无论是创建、合并还是删除分支，速度都是非常迅速的，这也是Git一个非常重要的特点，而且工作中常用分支来完成咱们的工作。 新建代码库12345//在当前目录新建一个git代码库$ git init//克隆一个项目$ git clone https://github.com/gxhpersonal/blog.git 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123// 设置提交代码时的用户信息git config --global user.name &quot;gxhpersonal&quot;git config --global user.email &quot;991158744@qq.com&quot; 增加/删除文件123456789101112//添加当前目录的所有文件到暂存区$ git add .//添加每个变化前，都会要求确认//对于同一个文件的多处变化，可以实现分次提交$ git add -p//删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...//改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交12345//提交暂存区到仓库区$ git commit -m &quot;改的内容标题&quot;//提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a 新建的分支push到远程服务器上1$ git push -u origin [分支名] 远程代码取到本地1$ git pull 本地代码提交到远程仓库1$ git push 分支1234567891011121314151617181920212223242526272829 //列出所有本地分支$ git branch//列出所有远程分支$ git branch -r//列出所有本地分支和远程分支$ git branch -a//新建一个分支，但依然停留在当前分支$ git branch [branch-name]//新建一个分支，并切换到该分支$ git checkout -b [branch]//切换到指定分支，并更新工作区$ git checkout [branch-name]//切换到上一个分支$ git checkout -//合并指定分支到当前分支$ git merge [branch]//选择一个commit，合并进当前分支$ git cherry-pick [commit]//删除分支$ git branch -d [branch-name] 指定某个commit到指定的分支1.执行git log -3 –graph test，查看test分支下的commit: 注：commit 后面的hash值代表某个commit，这里把”2e1ada53819d46557b24ee7376dc61d37a06939d”这个commit提交到master。 2.执行git checkout master，切换到master分支。 3.执行 git cherry-pick 2e1ada53819d46557b24ee7376dc61d37a06939d，该commit便被提交到了master分支。 到此，”2e1ada53819d46557b24ee7376dc61d37a06939d”这个commit便被提交到了master分支。]]></content>
      <categories>
        <category>环境框架语言</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端布局 字体选择 rem]]></title>
    <url>%2F2016%2F05%2F26%2FME-MOB%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80rem%2F</url>
    <content type="text"><![CDATA[移动端兼容//移动端适配 rem两种方式第一种只需在页面引入这段原生js代码就可以了 123456789101112(function(doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function() &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 100 * (clientWidth / 750) + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 如何使用？ 这是rem布局的核心代码，这段代码的大意是：如果页面的宽度超过了640px，那么页面中html的font-size恒为100px，否则，页面中html的font-size的大小为： 100 * (当前页面宽度 / 640) 为什么是640px？ 设计图一般是640px的，这样相当于100px = 1rem，可以方便计算； 因为是640px所以应限制下页面的大小，所以最外层的盒子应该是： position: relative; width: 100%; max-width: 640px; min-width: 320px; margin: 0 auto; 为什么是640px？对于手机屏幕来说，640px的页面宽度是一个安全的最大宽度，保证了移动端页面两边不会留白。注意这里的px是css逻辑像素，与设备的物理像素是有区别的。如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而它的CSS逻辑像素数为320 x 568px。如果要切移动端页面，你可以先把效果图宽度等比例缩放到640px，很好用。 为什么要设置html的font-size？rem就是根元素（即：html）的字体大小。html中的所有标签样式凡是涉及到尺寸的（如： height,width,padding,margin,font-size。甚至，left,top等）你都可以放心大胆的用rem作单位。如果你把html的font-size设为20px，前面说过，rem就是html的字体大小，那么1rem = 20px。此时，此时宽60px，高40px的元素样式就这样设置如下 ↓width: 3rem;height: 2rem;那要是宽55px，高37px呢？然后经过换算，，设置如下 ↓width: 2.75rem;height: 1.85rem;是不是发现这换算起来有点麻烦啊，，，（当然，你要是心算帝请无视）如果我们一开始把html的font-size设为100px呢？此时1rem = 100px，那么上面的宽55px，高37px的元素样式就可以这么设置 ↓width: 0.55rem;height: 0.37rem;是不是换算起来简单多了？！（当然可能有同学问，为什么不一开始把html的font-size设为1px呢，这样换算起来也简单，答：浏览器一般都有最小字体限制，比如谷歌浏览器，最小中文字体就是12px，所以实际上没有办法让1rem=1px。）根据上面的js代码，如果页面宽度低于640px,那么页面中html的font-size也会按照（当前页面宽度/640）的比例变化。这样，页面中凡是应用了rem的作尺寸单位的元素都会随着页面变化而等比例缩放了！ 都哪些情况可以用rem布局？大部分情况下都可以用rem布局这个方法，当然具体还要看情况而定。拿我们公司项目举例，只有底部的导航不用rem，而是用的flex布局。因为导航点击最多，所以给它一个固定的大小（其实就是高度固定，宽度自适应的方案）。大家可以看看淘宝的这个手机页面 淘宝手机站，基本就是这种感觉，底部导航和顶部搜索框用的高固定，宽自适应的方案，其余的部分基本都是随着浏览器宽度变化在等比例缩放。 第二种 123456789101112131415161718@mixin userem($size)&#123; $shebei-list:320px,375px,360px,384px,414px,460px,640px; @each $shebei in $shebei-list&#123; @media screen and(min-width: $shebei)&#123; html&#123; font-size:100px * ($shebei/$size); &#125; &#125; &#125;&#125;@include userem(640px).item&#123; height: 0.88rem; background: red;&#125; @media screen and (min-width: 320px) { html { font-size: 50px; }} @media screen and (min-width: 375px) { html { font-size: 58.59375px; }} @media screen and (min-width: 360px) { html { font-size: 56.25px; }} @media screen and (min-width: 384px) { html { font-size: 60px; }} @media screen and (min-width: 414px) { html { font-size: 64.6875px; }} @media screen and (min-width: 460px) { html { font-size: 71.875px; }} @media screen and (min-width: 640px) { html { font-size: 100px; }} .item { height: 0.88rem; background: red;} meta标签 1、控制显示区域各种属性： metacontent=width=device-width， initial-scale=1.0， maximum-scale=1.0， user-scalable=0name=viewport width：viewport的宽度 height：viewport的高度 initial-scale：初始的缩放比例 minimum-scale：允许用户缩放到的最小比例 maximum-scale：允许用户缩放到的最大比例 user-scalable：用户是否可以手动缩放 2、iOS中Safari允许全屏浏览： meta content=yesname=apple-mobile-web-app-capable 3、iOS中Safari顶端状态条样式： meta content=blackname=apple-mobile-web-app-status-bar-style 4、iOS中Safari设置保存到桌面图标 需要在网站的根目录下存放favicon图标，防止404请求(使用fiddler可以监听到) link rel=apple-touch-icon href=icon.png 5、忽略将页面中的数字识别为电话号码 一般情况下，iOS和Android系统都会默认某长度内的数字为电话号码 二、取消表单元素在点击态时的边框以及半透明灰色背景 css 代码片段 input， textarea， button， a 运行代码复制代码保存代码提示：1、可先改代码再运行 2、支持Zen coding 3、当代码框处于激活状态下按 CTRL+F11 键可全屏! 三、移除原生控件样式 css 代码片段 input，button，textarea 运行代码复制代码保存代码提示：1、可先改代码再运行 2、支持Zen coding 3、当代码框处于激活状态下按 CTRL+F11 键可全屏! 四、使用rem来做响应式开发 针对不同的设备，对页面rem做不同缩放 sass 代码片段 html 运行代码复制代码保存代码提示：1、可先改代码再运行 2、支持Zen coding 3、当代码框处于激活状态下按 CTRL+F11 键可全屏! 五、定义字体 如无特殊需求，手机端无需定义中文字体，使用系统默认； 英文字体和数字字体可使用 Helvetica ，三种系统（iOS、android、winphone）都支持。 css 代码片段 body 运行代码复制代码保存代码提示：1、可先改代码再运行 2、支持Zen coding 3、当代码框处于激活状态下按 CTRL+F11 键可全屏! 六、flex布局兼容性写法 使用 Sass mixin实现flex布局 sass 代码片段 @mixin display-flex() 运行代码复制代码保存代码提示：1、可先改代码再运行 2、支持Zen coding 3、当代码框处于激活状态下按 CTRL+F11 键可全屏! 七、移动端touch事件 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 touchstart：当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove：当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend：当手指离开屏幕时触发 touchcancel：系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 八、click产生200-300 ms的延迟响应 页面js捕获click事件的回调函数处理，需要300ms后才生效 解决方案： 1、fastclick可以解决在手机上点击事件的300ms延迟 2、zepto的touch模块，tap事件也是为了解决在click的延迟问题 九、按钮active态 在iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态 javascript 代码片段 document.body.addEventListener(‘touchstart’， function () ); 运行代码复制代码保存代码提示：1、可先改代码再运行 2、支持Zen coding 3、当代码框处于激活状态下按 CTRL+F11 键可全屏! 移动端html5手机网站如何定义字体font-family很多懒友在使用自定义字体时候，很容易像PC端那样定义，其实安卓和ISO系统，对中文字体是不支持，所以定义以后看到效果不是直接定义字体效果，如果需要定义大家会想到 @font-face 定义为微软雅黑字体并存放到 web 服务器上，在需要使用时被自动下载@font-face { font-family: ‘MicrosoftYaHei’; src: url(‘MicrosoftYaHei.eot’); / IE9 Compat Modes / src: url(‘MicrosoftYaHei.eot?#iefix’) format(‘embedded-opentype’), / IE6-IE8 / url(‘MicrosoftYaHei.woff’) format(‘woff’), / Modern Browsers / url(‘MicrosoftYaHei.ttf’) format(‘truetype’), / Safari, Android, iOS / url(‘MicrosoftYaHei.svg#MicrosoftYaHei’) format(‘svg’); / Legacy iOS / } 问题虽然解决了，但是这样操作很消耗用户流量，也对页面打开造成了很大延迟。 我们在一起看看三大主流系统他们字体到底支持哪些呢？ iOS 系统 默认中文字体是Heiti SC默认英文字体是Helvetica默认数字字体是HelveticaNeue无微软雅黑字体 android 系统 默认中文字体是Droidsansfallback默认英文和数字字体是Droid Sans无微软雅黑字体 winphone 系统 （已弃用） 默认中文字体是Dengxian(方正等线体)默认英文和数字字体是Segoe无微软雅黑字体 总结：各个手机系统有自己的默认字体，一般不支持我们常用字体，例如微软雅黑等；如无特殊需求，手机端无需定义中文字体，使用系统默认即可。英文字体和数字字体可使用 Helvetica ，三种系统都支持。 / 移动端定义字体的代码 /body{font-family:Helvetica;} http://www.lanrenmb.com/yidongyunying/shoujijianzhan/1292.htmlhttps://segmentfault.com/a/1190000006110417 利用@media screen实现网页布局的自适应优点: 适应各种窗口大小。只需在CSS中添加@media screen属性,自动根据浏览器宽度判断并输出不同的长宽值 1280分辨率以上（大于1200px） 123@media screen and (min-width:1200px)&#123; &#125; 1100分辨率（大于960px，小于1199px） 123@media screen and (min-width: 960px) and (max-width: 1199px) &#123; &#125; 880分辨率（大于768px，小于959px） 123@media screen and (min-width: 768px) and (max-width: 959px) &#123; &#125; 720分辨率（大于480px，小于767px）123@media only screen and (min-width: 480px) and (max-width: 767px)&#123; &#125;]]></content>
      <categories>
        <category>MOB</category>
      </categories>
      <tags>
        <tag>mob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery概述]]></title>
    <url>%2F2016%2F04%2F20%2FME-JS%2CJQ%2FjQuery%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[JQ前端开发在开始写代码之前，一般首先要解决的两个问题1.解决js标准本身的兼容性问题 es5shim.js2.解决DOM扩展部分的兼容性问题 jQuery库1234//第一个引入的js库用来解决兼容性问题.&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="header.js"&gt;&lt;/script&gt;&lt;script src="footer.js"&gt;&lt;/script&gt; 分开引用的js文件一定要解决的一个问题不能污染全局作用域 12345678var getEle = function(selector)&#123; //定义一个变量 参数为selectorif(document.querySelector)&#123; //判断有没有这个方法return document.querySelector(selector)&#125;else&#123;console.warnning('浏览器不支持');console.error('请更换浏览器');&#125;&#125; 123var el = getElement(&apos;.abc&apos;)var getElement = function()&#123;&#125; 上面的这种写法的两个问题1.用户需要学习一门全新的语法2.用户需要避开那个库中的所有全局变量 DOM对象的存储方式 是怎么存储的? 可以使用查询console.dir() DOM集合的存储方式 是怎么存储的? 可以使用查询console.dir() jQuery对象的存储方式 是怎么存储的? 可以使用查询console.dir() 在Obj对象中存储了100+方法 jQuery 实现原理1.new的时候究竟发生了什么？2.对象的原型链3.函数对象身上一个属性(prototype)和一个方法(call)4.this的指向 jq中的大多数方法都会返回一个jq集合5. 操作集合的方法就是原集合6. 对集合做过过滤或者导致集合改变的一些方法返回改变后的是Query集合7. $ .append 这一类方法，当涉及到创建dom对象时，他们会返回创建完成后的一个Jquery 集合所以在jq中经常使用链式调用12345$('#one h1').width(100).height(200).css(&#123;color:'red'&#125;).position();在这里终止 1234567891011121314151617181920212223242526272829(function()&#123;var add = function(selector)&#123;console.log(this)var els = document.querySelectorAll(selector)for(var i=0;i&lt;els.length;i++)&#123;this[i] = els[i]console.log(this)&#125;this.length = els.length&#125;add.prototype.addClass = function(str)&#123;console.log(add)console.log(this)for(var i=0;i&lt;this.length;i++)&#123;this[i].classList.add(str)&#125;&#125;add.prototype.removeClass = function(str)&#123;console.log(add)console.log(this)for(var i=0;i&lt;this.length;i++)&#123;this[i].classList.remove(str)&#125;&#125;var $ = function(selector)&#123;return new add(selector)&#125;window.$ = $;&#125;)() DOM对象123456789101112var el = &#123;offsetWidth:12,_proto_: (HTMLDivElement)title:'aa';_proto_: HTMLElementsrc:'xxx.png'_proto_:ElementgetAttribute:fn,_proto_:NodenodeName:"IMG",_proto_&#125; DOM集合12345678var els = &#123;0:el,1:el,2:el,3:el,length:4,_proto_:(并没有多少有价值的方法或属性)&#125; jQuery对象12345678910111213var jQuery = &#123;0:div,1:div,2:div,length:3,_proto__:addClass:fn,removeClass:fn,toggleClass:fn,css:fn,prop:fn...&#125; jQuery 是一个javascript库，库，仓库，可以简单理解成一堆以某种方式组织起来的，方便，易用的函数的集合 jQuery库的优点1、全面解决PC端的兼容性优点2、语法精炼，性能好，插件库庞大，非常多。 jQuery版本号之间的区别1.xx-&gt;1.12 支持IE6-82.0 彻底放弃了对IE&lt;10的支持，转向移动端 $ 函数能接受的参数类型以及对应的返回值 null jQuery 数组 对象 选择器 html标签 DOM对象 DOM集合 函数 // javascript中构建一个对象的4种方式// 1. 字面量的形式var obj = {“a”:12,“b”:234}// 根据字面量的形式创建的对象// 原型就是 Obj.prototype 这个对象// 功能性较少// 2.构造函数var obj2 = new Object()obj2.a = 12;//一般不用 太麻烦// 3.利用 Obj.create() 方法// 从一个已有的对象开始构建新的对象var mao = {zhuazi:4,erduo:1,nao:function(){}}var bosimao = Object.create(mao);bosimao.dianjiaojian = function(){}// 4. 用new 关键字来构造对象var mao = function(){this.zhuazi = 4;this.erduo = 1;}// 每个函数对象身上都有一个其他对象不具备的属性，叫做’prototype’var bosimao = new mao()// 1.构建一个空对象()// 2.mao.call({}) 把mao那个函数作为这个空对象的临时方法调用了一次// {zhuazi:4,erduo:1}// 3.把mao那个函数对象身上的prototype那个属性拿来，作为自己原型链上的一条// 4.返回最终的对象 ##jquery中的方法 1.直接出现在是Query函数对象身上，是一些基础性质的工具函数2.出现在jqery.fn函数对象的原型解放链上，用来批量或单个操作jquery集合中的dom对象 大部分方法重载很严重123456789101112131415161718192021222324252627282930313233343536373839404142434445$('li').css('width'); //取出选中集合中第一个元素和宽度 +px$('li').css('width',200); //设置集合中所有的元素的宽度为200px$('li').css(&#123;width:200,height:300;border:'1px solid black'&#125;);// 给选中的集合中所有的元素，加上对象中的所有样式给集合中每一个的元素添加'width'这个属性，意味着jquery会对集合中的每一个元素调用用户传入的回调函数，一个是当前元素在集合中在集合中的位置，（0，1，2，3，4），另外一个是当前元素现在的'width'值$('li').css('width',function()&#123;return Math.random()&#125;)var colors = ['red','blue','green']$('li').css(&#123;width:function()&#123;return Math.random();&#125;height:function()&#123;return Math.random();&#125;backgroundColor:function(i)&#123;return Math.colors(i);&#125;&#125;)jQuery库设计理念1.解决兼容性问题2.让从页面中查找元素变得更多轻松3.提供很多内置方法，使对dom集合的操作 变得更轻松cssaddClass 这些方法通过内置的遍历去操作每一个dom元素 jQuery 不希望我们在循环中使用这些内置方法1.给集合中的每一个dom元素设置同样的值或行为2.给集合中的每一个dom对象设置不同的值或行为```javascriptvar els = document.querySelectorAll('.item');for(var i=0;i&lt;els.length;i++)&#123;$(els[i].addClass('aa'));&#125;var colors = ['red','blue','green','yellow','pink','red','blue','green']$('.main-content article').css('backgroundColor',function(i,w)&#123;return colors[i]&#125;)$('li').attr('data-id')$('li').attr('data-id','12')$('li').attr('data-id',function()&#123;return Math.random();&#125;)$('li').attr(&#123;data-id:12,data-src:'img.png'&#125;)$('li').attr(&#123;data-id:function()&#123;return Math.random()&#125;data-src:'img.png'&#125;)以空格分开的字符串 节点的操作 *.clone() 拷贝后得到对象父元素的信息 on 添加事件的重载 $(‘.item’).on(‘click’,function(){console.log(1)}//一次绑定的多个事件 用一个处理函数$(‘.item’).on(‘click mouseleave mouseenter’,clickHandler) //一个事件绑定不同处理函数var fn1 = function(){}var fn2 = function(){}var fn3 = function(){}$(‘.item’).on({‘click’:fn1,‘mouseleave’:fn2,‘mouseenter’:fn3})绑定3个不同的事件})//事件的委托方式$(‘#ul’).on(‘click’,’li’,function(){ })//事件的委托另外的方式$(‘#ul’).delegate(‘li’,’click’,function(){ })jQuery添加事件的注意事项 1. on()的几种添加方式 一次绑定多个事件，用同一个处理函数 一次绑定多个事件，用不同的处理函数2. 事件委托的添加方式(只能使用 on 和 delegate 方法)3. mouseover mouseout 方法由于事件冒泡带来多次触发 一般我们使用 mouseenter 和 mouseleave 以及 hover (hover 是对 mouseenter 和mouseleave)4. focus blur = focusin focusout 同上 后面的两个不会冒泡5. ready() 事件一般用 $(function(){})来代替内部的处理方式是 document.addEventListener(‘DOMContentLoaded’);如果文档结构(不包含图片，脚步等)已经加载完成，直接运行函数如果还没有加载完成 把函数绑定到’DOMContentLoaded’6. trigger()会模仿浏览器触发事件(会冒泡) triggerHandler (不会冒泡)7. 所有事件添加函数的返回值要绑定事件的那个jQuery对象，所以可以继续链式调用$(‘.item’).click(function(){console.log(1).css()}) jQuery中的事件对象 继承 原生的事件对象 e.keyCode e.altKey e.target e.clientX e.currentTarget e.data var xs = function(){var dict = {x:1,y:2}$($0).on(‘click’,dict,function(e){e.preventDefault();console.log(e.data);})setInterval(function(){dict = {x:Math.random(),y:Math.random()};},1000)} $(‘li’).on(‘click’,{x:1,y:2},function(e){console.log(e.data)})$(‘li’).click({x:1,y:2},function(e){console.log(e.data)}) e.namespace$(‘li’).on({‘click’:function(){consoel.log(1);},{‘click.lunbo’:function(e){console.log(2,e.namepace);}})$(‘li’).trigger(‘click.lunbo’) var dict = {39:’xia’,40:’you’}$(document).on(‘click’,dict,function(){console.log(e.data)})$($0).on(‘click.lunbo’,function(){console.log(e.namespace)}); 停止当前队列的四种方式.stop()不加参数是停止当前的进行的下一个.stop(true)第一个是否清除队列.stop(true,true) 不加就没效果 不清除队列 第一个是否清除队列 第二个是否到达最终状态.finish 停止整个动画 到动画的最终状态 不带队列.delay() 一个延迟.clearQueue 清楚后续动画，但不影响当前 $.fx.off = true 关掉所有的动画$.fx.interval = 13 默认每隔13毫秒执行一次动画 异步编程需要注意的问题：1.理清代码的执行时间线; 同步 正常的函数 正常的赋值 正常的逻辑运算，普通运算``` ### 事件 动画（setInterval setTimeout） Ajax(发送网络请求) 都会把我们带入异步 get获取一些安全性低的东西 post 弄一些安全性高的东西 Math.max(3,4,5) Math.max.call(null,3,4,5)]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
      <tags>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQ插件]]></title>
    <url>%2F2016%2F04%2F01%2FME-JS%2CJQ%2FjQ%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[//表示根据你的协议编写swiper 移动端广泛应用的插件cdn 内容分发网络（content dliver network)如果百度使用了cdn中的jquery。js 用户打开过百度下载过这个js文件 我们使用的和他同一个cdn中的jquery。js用户打开我们的网页时使用浏览器缓存中jquery.js(function($){ var lunbo = function(){ console.log(1) } $.fn.extend({ lunbo:lunbo; })})(jQuery)$(document).lunbo(); jquery 插件(function($){ var lunbo=function(config){ var _config={ interval:1500, step:$.noop } $.extend(_config,config) var ul=this.find(‘ul’), li=ul.find(‘li’), index=1, off=li.outerWidth(true); setInterval(function(){ ul.animate({‘marginLeft’:-index*off},500); index+=1; _config.step(index); if(index===li.length){ index=0; } },_config.interval) return this; } $.fn.extend({lunbo:lunbo});}(jQuery)) $(‘.lunbo’).lunbo({ interval:2500, step:function(i){ $(‘.pu’).fadeToggle(2500) } }); $(‘.xiaolunbo’).lunbo(); 拓展一个数组去重方法&lt;!– $.quchong([1,1,1,2,3]) reverseString –&gt; @keyframes diaoluo{ 0%{ transform: translateY(0); } 100%{ transform:translateY(300px); }} #section1{ h1{ position: absolute; top:0; color: white; width: 100%; text-align: center; }} #section1.active{ h1{ animation:diaoluo .8s ease both infinite alternate 1s; }} #section2{ position: relative; %fk{ width: 200px; height: 200px; background: pink; } .zuo,.you{ @extend %fk; position: absolute; top: 50%; transition: all 5s ease; } .zuo{ left: 0; } .you{ right:0; }} #section2.active{ .zuo{ transform: translateX(200px); } .you{ transform: translateX(-200px); }} &lt;!DOCTYPE html&gt; Document // $.extend({ // reverseString:function(s){ // for( var i =s.length-1,r=’’;i&gt;=0;i–){ // r+= s[i] // } // return r; // } // }) // $.extend({ // reverseString:function(s){ // return r.split(‘’).reverse().join(‘’) //先变成数组然后调用数组的反的方法在转回去 // } // }) // $.extend({ // reverseString:function(s){ // for( var i =s.length-1,r=’’;i&gt;=0;i–){ // r+= s[i] // } // return r; // }, // quchong:function(arr){ // var r =[]; // // $.each(arr,function(i,v){ // // if( $.inArray(v,r) === -1){ // // r.push(v) // // } // // }) // // return r; // var dict = {}; // for(var i=0;i]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
      <tags>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript概述]]></title>
    <url>%2F2016%2F02%2F16%2FME-JS%2CJQ%2Fjavascript%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[javascript:;概述.md(markdown) 把dom身上的一些 事件 属性的赋值给一个函数让浏览器就进行调用 javascript是一门程序语言 和计算机交流的语言 #计算机是什么？能做什么? 计算机用来计算 程序语言就是将人类可读的指令按照一定的规则传递给计算机进行计算，然后将计算的结果传递给显卡计算最终显示出图形界面。 一门程序语言必须具备一些能力，才能和计算机交流明白 #必须能很清楚的告诉计算机，怎样去做存储数据 #必须能很清楚的告诉计算机，怎样去做逻辑操作 ##javascript中的逻辑操作 / % &amp;&amp; || ! === !== &gt;= &lt;= &gt; &lt; (eslint) if(){}if(){}else{}if(){}else{}if(){}else{}if(){}else{}if(){}else{}swich(val){ case1; xxxx; break; case2; xxxxx; break; default; xxxx; break;} 数据的存储var v=’aaa’ ; Stringvar v=[1,2,3,’aa’] ; 数组Arrayvar v=function(){}; functionvar v={a:1,b:2,c:3}; Object 存储形式为表格 console.dir() var v = 1 ; number 存储单独值var v = true ; Booleam布尔值var v=null ; nullvar v = undefined ; undefined valueOf() ##javascript中用类似于’表’的形式存储数据(对象) &gt;var fn=function(){ alert(1); console.log(1); return 1;} 定义函数的时候发生了什么？ 要把代表函数的那张表构建完全1.调用这个属性要赋值，函数体内部的字符串2.需要把当前 可见范围内的所有的变量，由近到远的记录到一个链条中，形成一条作用域链 写在函数体的代码去那里了？ 函数会用一个不可见的属性调用来存储函数体中的代码 {‘调用’:’concole.log(1);return1’}函数对象特殊性在于它可以被调用函数名+（）可以调用函数调用函数的时候：函数对象会去读取自己身上调用这个属性的值，取出来一些字符串，把这些字符串交给js解析器去当做javascript代码去执行于此同时还会取出这个函数的作用域链 用来辅助这段代码的执行 在函数this是什么？ 只有在函数中才有this 函数定义的时候没有this函数在调用的时候根据调用的不同情况，来决定this变成什么 到底有那些不同的调用方式var obj={};var fn=function(){ console.log(this);}obj.c=fn;fn(); this指向windowobj.c(); 指向obj对象obj.c.call(‘111’) 指向它的宿主对象obj.c.apply([1,2,3,4],[3,4])fn.call([1,2,3,4,5]); 指向它的宿主对象第一种 正常定义(不把函数作为某个对象的属性)和正常调用(使用()的方式调用函数)一个函数的时候 this指向windowvar fn=function(){ console.log(this)}fn()第二种 如果我们需要把this换成任何我们想要的对象 指向obj对象var obj={ a:1; b:1; c:function(){ console.log(this)}}obj.c()第三种 借助函数对象上的call和apply的方法 指向它的宿主对象 更改我们想要的任何对象var obj={a:1;b:2} obj.c=function(){ console.log(this)}obj.c();obj.c.call(‘a,b’) call当我们写好一分程序之后，计算机在的过程中发生了什么？栈值对 一张表嵌套一张表objecte 有toString方法;console.log 方法 v.valueOfalert v.toString “[object Object]”左边为栈 右边为值 length为不可枚举的属性 for in 循环中不显示对象的栈 和值 无序分布函数也是一个对象&lt; localStorage.setItem(‘d’,12) 会在浏览器中存储一些数据(字符串) &gt;&lt; localStorage.getItem(‘d’,12) 会从本地存储中取出一些数据&gt; localStorage.removeItem(‘d’,12) 会从本地存储中删除一条数据&lt; JSON.stringify()把对象转成字符串//{a:1,b:2}=&gt;’{“a”:1,”b”:2}’JSON.parse()把符合规则的字符串重新转回对象//[‘1’,’2’,’3’]=][1,2,3] –&gt;]]></content>
      <categories>
        <category>JS/JQ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[scroll取消默认滚动条]]></title>
    <url>%2F2016%2F01%2F30%2FME-HTML%2FCSS-scroll%E5%8F%96%E6%B6%88%E9%BB%98%E8%AE%A4%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[忽然想到一个更简单的方式 第一种 css123456789101112131415&lt;style&gt; /*cms滚动条*/ .nav2-list::-webkit-scrollbar-track&#123; background-color: white; &#125; .nav2-list::-webkit-scrollbar&#123; width: 0px; background-color: rgba(0,0,0,0.3); &#125; .nav2-list::-webkit-scrollbar-thumb&#123; background-color: #e4e4e4; &#125;&lt;/style&gt; 第二种 div+css 控制今天看见layui群里有个网友问不想要左侧滚动条，然后就去看了http://www.layui.com/demo/发现可以这样写： 当我们的内容超出了我们的div，往往会出现滚动条，影响美观。 尤其是当我们在做一些导航菜单的时候。滚动条一出现就破坏了UI效果。我们不希望出现滚动条，也不希望超出去的内容被放逐，就要保留鼠标滚动的效果。大体思路是在div外面再套一个div。这个div设置overflow:hidden。而内容div设置 overflow-y: scroll;overflow-x: hidden;然后再设置外层div的width小于内层div的width。这个内层div其实是会出现滚动条的，所以不影响鼠标的滚动效果，而且我们看不到滚动条了。 css代码 1234567891011121314151617181920212223242526272829303132&lt;style&gt; ul,li&#123; margin: 0; padding: 0; list-style: none; &#125; .nav-wrap &#123; width: 200px; height: 400px; overflow: hidden; border: 1px solid #ccc; margin: 100px auto 50px; &#125; .nav-list &#123; height: 100%; width: 220px; overflow-y: auto; overflow-x: hidden; &#125; .nav-item &#123; width: 200px; margin: -1px; height: 40px; line-height: 40px; text-align: center; border: 1px solid #ccc; &#125; .btn-wrap &#123; width: 100%; text-align: center; &#125;&lt;/style&gt; html代码 12345678&lt;div class="nav-wrap"&gt; &lt;ul class="nav-list"&gt; &lt;li class="nav-item"&gt;子菜单一&lt;/li&gt; &lt;li class="nav-item"&gt;子菜单二&lt;/li&gt; &lt;li class="nav-item"&gt;子菜单三&lt;/li&gt; &lt;li class="nav-item"&gt;子菜单四&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 演示链接：https://sywsywsyw.github.io/CSS-scroll/layui: http://www.layui.com/demo/]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular]]></title>
    <url>%2F2016%2F01%2F03%2F%E6%B2%A1%E7%94%A8%E7%9A%84%2Fangular%2F</url>
    <content type="text"><![CDATA[angular.js 一个全局对象angular 123456789101112131415161718192021&#123; fromJson:fn, toJsonL:fn, forEach:fn, module:fn(str,arry) eg:var XX = angular.module(&apos;项目名字&apos;,[])&#125;一个模块对象的内部结构&#123; controller:fn, directive:fn, config:fn, factory:fn, service:fn, constant:fn, value:fn, filter:fn,&#125;$scope.$location,$routeProvider$routePramas 基本使用 1234567html ng-app="xx"body ng-controller="mainctrl"&lt;script&gt;var xx = angular.module('xx',[])nw.controller('mainCtrl',['$scope',function($scope)&#123;&#125;])&lt;/script&gt; 模块 var xx = angular.module(‘xx’,[‘ngAnimate’]) 可以自定义创建一个模块但必须遵循规则 控制器 xx.controller(‘mainCtrl’,[‘$scope’,function($scope){ $scope.state=true; }]) 双向数据绑定 ng-bind作用域的概念 装饰性指令 在页面的装饰性指令中可以使用angular表达式 ng-repeat = “ v in xx $index $last $first $middle $odd $even” 优先级1000 angular指令中最高的 自定义指令时切忌高过1000 ng-bind === ng-class=”{a:(state==false),b:,c:}” ng-if ng-show ng-hide ng-click ng-dblclick ng-[event] 组件化开发 angular会以ajax请求的方式去调用 xx.directive(‘sywTop’,[function(){ return { restrict:’AECM’, //E元素,A属性,C Class,M replace:true, 隐藏自定义标签 template:’‘ templageUrl:’views/tab.html’, link:function(); link:function($scope,elem){ 先引入jQuery 永远不要在controller写dom操作和注册事件 第一个是作用域 第二个是JQ对象 console.log($scope.shwo,elem) angular.elements(); } } }])在weixin.html tongxunlu.html 中只能使用一个父元素包起来 不能并排使用 在指令中使用jQuery angular 内部提供了一个jqLite; angular.elements() === $(); 永远不要在controller写dom操作和注册事件 第一个是作用域 第二个是JQ对象 在指令中的link函数中不想使用Jqlite先引入jQuery 再引入angular angular会自动把jqLite 替换为 jQuery 在指令的link函数中去添加事件 操作DOM 使用路由 var xx = angular.module(‘xx’,[‘ngRoute’]); xx.controller(‘weixinCtrl’,[‘$scope’,function($scope){}]) xx.controller(‘tongxunluCtrl’,[‘$scope’,function($scope){}]) xx.controller(‘faxianCtrl’,[‘$scope’,function($scope){}]) xx.controller(‘meCtrl’,[‘$scope’,function($scope){}]) xx.config([&apos;$routeProvider&apos;,function($routeProvider){ $routeProvider.when(&apos;/&apos;,{ controller:&apos;indexCtrl&apos;, templateUrl:&apos;views/weixin.html&apos; }).when(&apos;/weixin&apos;,{ controller:&apos;weixinCtrl&apos;, templateUrl:&apos;views/weixin.html&apos; }).when(&apos;/tongxunlu&apos;,{ controller:&apos;tongxunluCtrl&apos;, templateUrl:&apos;views/tongxunlu.html&apos; }).when(&apos;/faxian&apos;,{ controller:&apos;faxianCtrl&apos;, templateUrl:&apos;views/faxian.html&apos; }).when(&apos;/me&apos;,{ controller:&apos;meCtrl&apos;, templateUrl:&apos;views/me.html&apos; }).otherwise({ redirectTo:&apos;/&apos; }); }]); 使用动画&lt;script src=&quot;angular-animate.js&quot;&gt;&lt;/script&gt; var xx = angular.moudel(&apos;xx&apos;,[&apos;ngAnimate&apos;]) .ng-if .ng-hide div{ transition:all .8s ease; } div.ng-hide{ opactiy:0; } ng-class .add .remove ng-repeat .enter .enter-active .leave .leave-active ng-view .enter .enter-active .leave .leave-active 使用内置服务把服务依赖注入到控制器,指令，服务，过滤器 $scope $routeProvider $routeProvider.when(‘/liaotian/:aaa’,{ controller:’liaotianCtrl’, templateUrl:’views/liaotian.html’}) weixin.html li a href = “#/liaotian“ test.controller(‘liaotianCtrl’,[$scope,$routeParams,function($scope,$routeParams){ var id = $routeParams.aaa}]) 服务名字用$开头 一般推荐在自定义指令的link函数中使用jquery去操作dom元素. 在link函数中操作$scope身上的数据时一定要注意 调用$scope.$apply()方法让angular启动脏检查机制来自动刷新页面 才能实行数据的双向绑定 调用$scope.$apply()方法让angular启动脏检查机制来自动刷新页面 调用$scope.$apply()方法让angular启动脏检查机制来自动刷新页面]]></content>
      <categories>
        <category>环境框架语言</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpcms使用和oneThink使用]]></title>
    <url>%2F2016%2F01%2F01%2FME-%E6%A1%86%E6%9E%B6%E7%8E%AF%E5%A2%83%2Fphpcms%E4%BD%BF%E7%94%A8%E5%92%8ConeThink%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[oneThink简单而强大的内容管理框架,让WEB开发更快速! thinkphp网站搭建过程 准备开发 下载官方软件v1.0正式版 http://www.onethink.cn/ 下载本地服务器wampserver http://www.wampserver.com/ 开发步骤 解压v1.0安装包将www文件目录的所有文件copy到C:\wamp64\www或C:\wamp32\www目录中 启动wampserver等待指示灯有红变绿 黄色不行 进入http://localhost/phpmyadmin/index.php?token=6de2f4e9ae5b49d31d01b84dd98ed44d 账号root 密码为空 新建一个数据库后面需要用到 启动浏览器输入localhost执行安装步骤 如果一直无法进入下一步说明cookie出错了，打开C:\wamp64\www\Application\Install\Controller\InstallController.class.php注释掉92行和103行代码，如果还是不行请删除C:\wamp64\www\Runtime所有文件夹，如果不行 重复此步骤或者去百度。执行第三步之后出现&quot;Access denied for user &#39;admin&#39;@&#39;localhost&#39; (using password: YES)&quot;说明数据库用户名不对，wampserver默认用户名 root 密码不用填 部署阿里云开发步骤与上面相同，数据库账号密码以及数据库名称统一更换为阿里云的账户名称。 其他后台模板安装与之一样 1.将phpcmsv9.zip解压 然后将install_package 下面的所有东西拷贝到www目录 2.打开localhost/index.html 3.安装过程中 第3步选择全新安装 第5步选择 账户 root root root 空 email1@2.com 一个是L一个是1 4.后台管理 phpcms phpcms phpcms的安装 将phpcmsv9.zip解压 然后将install_package 下面的所有东西拷贝到www目录 打开localhost/index.html 安装过程中 第3步选择全新安装 第5步选择 账户 root root root 空 email1@2.com 一个是L一个是1 后台管理 phpcms phpcms 后台入口：localhost/admin.php 前台入口：localhost/index.php phpcms使用localhost/admin.php 什么是内容管理系统？用来制作动态网站的一个系统 phpcmsv9 把index.php公开给用户去访问 index.php是一段程序 这段程序根据得到的参数决定把哪个页面发送给用户 这段程序会在web服务器上寻找html和脚本,图片，拼接起来发送给用户 html文件在哪里?phpcms/templates(模板)/default/content/ 脚本和图片在哪里?statics/css statics/js statics/image 1234567891011引入js,css,image&lt;link rel="stylesheet" href="&#123;CSS_PATH&#125;xxx/yyy.css"&gt;&lt;script src="&#123;JS_PATH&#125;xxx/yyy.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div class="logo"&gt; &lt;img src="&#123;IMG_PATH&#125;xxx/yyy.png" alt=""&gt; &lt;/div&gt;&lt;/body&gt;.log&#123; background-image:url(/statics/images/xxx/a.png)&#125; 如果想改样式和结构怎么？header.html+ index.html + footer.html 修改header.html body以下都注释掉 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;div class="1_header"&gt; &lt;ul&gt; &lt;!-- nav-site --&gt; &#123;pc&#125; &#123;loop&#125; &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt; &#123;/pc&#125; &#123;/loop&#125; &lt;/ul&gt;&lt;/div&gt;```html### 栏目页( 有子栏目的栏目)图片模型 category_picture.html文章模型 category.html商品模型 category_shangpin.html教师模型 category_jiaoshi.html### 栏目页(没有子栏目的栏目)图片模型 list_picture.html文章模型 list.html商品模型 list_shangpin.html教师模型 list_jiaoshi.html### 内容页图片模型 show_picture.html文章模型 show.html商品模型 show_shangpin.html教师模型 show_jiaoshi.html ## index.html -&gt; category.html -&gt; list.html -&gt; show.html```html取一级栏目&#123;pc:content action="category" catid="0"&#125;&#123;loop $data $r&#125;&#123;/loop&#125;&#123;/pc&#125;&lt;!-- &lt;div class="l_header"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="&#123;siteurl($siteid)&#125;"&gt;首页&lt;/a&gt;&lt;/li&gt; &#123;pc:content action="category" catid="0" num="25" siteid="$siteid" order="listorder ASC"&#125; &#123;loop $data $r&#125; &lt;li&gt;&lt;a href="&#123;$r[url]&#125;"&gt;&#123;$r[catname]&#125;&lt;/a&gt;&lt;/li&gt; &#123;/loop&#125; &#123;/pc&#125; &lt;/ul&gt;&lt;/div&gt; --&gt;取某个一级栏目下的二级栏目&#123;pc:content action="category" catid="$catid"&#125;&#123;loop $data $r&#125;&#123;/loop&#125;&#123;/pc&#125;&lt;!-- &lt;div class="main"&gt; &lt;ul&gt; &#123;pc:content action="category" catid="$catid"&#125; &#123;loop $data $r&#125; &lt;li&gt;&lt;a href="&#123;$r[url]&#125;"&gt;&lt;span&gt;&#123;$r[catname]&#125;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &#123;/loop&#125; &#123;/pc&#125; &lt;/ul&gt;&lt;/div&gt; --&gt;取栏目下的内容&#123;pc:content action="lists" catid="$catid"&#125;&#123;loop $data $r&#125;&#123;/loop&#125;&#123;/pc&#125;&lt;!-- &lt;div class="main"&gt; &lt;ul&gt; &#123;pc:content action="lists" catid="$catid"&#125; &#123;loop $data $r&#125; &lt;li&gt;&lt;a href="&#123;$r[url]&#125;"&gt;&lt;span&gt;&#123;$r[title]&#125;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &#123;/loop&#125; &#123;/pc&#125; &lt;/ul&gt;&lt;/div&gt; --&gt;取内容中的标题和文章 &#123;title&#125; &#123;content&#125;&lt;!-- &lt;div class="main"&gt; &lt;div class="biaoti"&gt;&lt;h1&gt;&#123;$title&#125;&lt;/h1&gt;&lt;/div&gt; &lt;div class="neirong"&gt;&lt;span&gt;&#123;$content&#125;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt; --&gt; 从推荐位取东西 {pc:content action=”position” posid=”1”} {loop $data $r} {/loop} {/pc} 12&#123;php print_r(get_defined_vars() )&#125; //输出页面中所有能使用的变量 1&#123;php print_r($r)&#125; 在每个页面中我们能使用哪些php变量index.html $CATEGORYS; category.html $CATEGORYS $catid= 点击的当前一级栏目的id list.html $CATEGORYS $catid= 点击的当前栏目的id show.html $CATEGORYS $catid= 这个内容属于的那个栏目的id 数据模型中的字段 {title} {content} moreinfo=”1” 取更多内容 thumb 缩略图 description 描述 {template “content”,”header”} list {$r[title]} {$r[thumb]} {$r[url]} show {$title} {$url} {$thumb} lis.hide().eq(this).show() 建立模型 新建三个 category_xxx.html list_xxx.html show_xxx.html 模型管理–&gt;添加模型–&gt;添加字段 添加栏目 添加内容 pc atcion=lists moreinfo=”1” index.php =&gt; h+index+f 创建模型,添加字段 nav-list {$r[catdir]} {if $r[catid] == $catid}active{/if} {$r[catdir]} catud=”$CATEGORYS[catid][‘parentid’]} 取父元素 .center{ width:980px; margin:0 auto; boreder:1px solid black; } .center:after{ clear:both; display:block; } .header{ height:100px; background:red; }]]></content>
      <categories>
        <category>环境框架语言</category>
      </categories>
      <tags>
        <tag>phpcms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[form]]></title>
    <url>%2F2016%2F01%2F01%2FME-HTML%2FHTML-form%2F</url>
    <content type="text"><![CDATA[1、 阻止掉form表单提交改用ajax。（如果有图片还是无法使用正常的ajax提交，请去ajax常见问题寻找答案） 12345678$("form").submit(function()&#123; var self = $(this); $.post(self.attr("action"), self.serialize(), success, "json"); return false; function success(data)&#123; console.log(data); &#125;&#125;); 2、form 表单一个页面可以存在多个但是无法嵌套在一起使用，如果嵌套则被嵌套的form表单不会输出到页面中来。 3、form 表单设置为 disabled=”disabled”则这个参数无法提交给后台， 如果要设置只读然后提交请使用 readonly=”readonly”。 readonly和disabled是用在表单中的两个属性，它们都能够做到使用户不能够更改表单域中的内容。但是它们之间有着微小的差别，总结如下： Readonly只针对input(text / password)和textarea有效，而disabled对于所有的表单元素都有效，包括select, radio, checkbox, button等。但是表单元素在使用了disabled后，当我们将表单以POST或GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去（这种情况出现在我们将某个表单中的textarea元素设置为disabled或readonly，但是submit button却是可以使用的）。 4、]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML-dom]]></title>
    <url>%2F2016%2F01%2F01%2FME-HTML%2FHTML-dom%2F</url>
    <content type="text"><![CDATA[#DOM是什么 Document Object Modal(文档对象模型) 我们在页面中看到的 div,span,p,h1 等等元素或文字在 javascript 眼中都是一个对象 从一个web应用的开发说起第一步，从页面中去选取一个元素出来当我们的代码在浏览器中去运行时，浏览器已经帮我们创建了很多对象，对象中有很多方法，可供我们使用这些东西都在一个叫做window的全局变量里 window对象中的属性，可以省略window. 去调用eg: window.setTimeout 选取元素，我们从window.document开始 选取元素的方式快速从document中取出一个DOM对象的办法 document.body document.head document.title document.documentElement 代表了整个html标签的一个DOM对象 document.querySelector() document.getElementById()返回值单个 document.querySelectorAll() document.getElementsByClassName() document.getElementsByTagName() document.getElementsByName() 这些方法的返回结果是什么？前两个的返回结果是一个代表了页面中元素的对象 我们把他叫做DOM对象后四个的返回结果是一个类数组对象，对象中用 我们把他叫做DOM集合var obj={ 0:Dom对象, 0:Dom对象, …… length:12} DOM对象中的常见的属性和方法object toString() valueOf() 内部的方法 EventTarget addEventListener() removeEventListener() dispatchEvent() Node所有的DOM对象都是一个’节点‘这三个属性用来描述节点 nodeName nodeType nodeValue 我们能从每个DOM对象身上取到自己的相邻或父节点或子节点 ChildNode 返回值DOM对象 firstChild 返回值DOM对象 lastChild 返回值DOM对象 parentElement parentNode previousSibling removeChild() 取节点的文本内容（会过滤掉标签） textContent 每个DOM对象中都提供了一些操作节点的方法 通常采用 父DOM对象.xxx （DOM)这种方式 appendChild() box.appendChild(el).style.color = ‘red’ 返回值为一个DOM对象所以可以继续使用DOM里面的方法 insertBefore() 返回值 为你插入的那个DOM对象 replaceChild() 返回值 替换成的那个DOM对象 removeChild() 返回值 移除成的那个DOM对象 var tmp = box.removeChild(el) haChildNodes() contains() （true,flase）查看节点是否包括另外一个节点？可以做唯一的标识符 cloneNode() (true复制全部，false复制结构) hasChildNodes() 返回值 布尔类型 el.children.length contains() 返回值 布尔类型 cloneNode() 返回值 DOM对象(true,false) childNodes() replaceChild() Element(元素)元素和节点的区别不带标签的，比如div内容的文字，比如注释，它们只是节点，不是元素 children 取一个DOM对象的所有子元素 DOM集合 firstElementChild lastElementChild nextElementSibling previousElementSibling 对元素属性的操作 （HTML元素的属性 就是头标签里的那些k=””中的k) classList 操作类 className 可读写 id 可读写 getAttribute() setAttribute() 没有返回值，只是做一个操作 hasAttribute() 判断元素标签中有没有某个属性 removeAttribute() 没有返回值，只是做一个操作 outerHTML tagName 获取该元素的视察坐标(和offset区别)或者和其他位置相关信息的坐标 getBoundingClientRect() 返回值是{top:x,left:x,bottom:1,width:1,height:1};el.getBoundingClientRect.top scrollLeft 相对于父元素滚动的距离 scrollTop 相对于父元素滚动的距离 clientWidth 一般用来结合document.documentElementl.clienWidth clientHeight 从某个DOM对象开始，可以缩小范围纠结去查找元素 getElementsByClassName() getElementsByTagName() querySelector() querySelectorAll() HEMLElement innerHTML 可读写的 能设置某个DOM对象内部的html结构 innerText 剥离标签直接获取取文本 实时获取元素信息 offsetHeight 前四个返回不带px具体的数值 offsetWidth offsetTop offsetLeft offsetParent 获取具有定位属性的元素 返回值DOM对象 操作行内样式 style 可读写 读的时候实时获取元素行内样式的值，不会去计算 Css文件中定义属性 HTML xxx Element value checked src 添加事件的两种方式及其区别事件 事件对象 添加事件的方式 不同方式之间的区别阻止事件默认行为 阻止事件流 事件委托 我们给DOM对象的onclick属性赋值，值为一个函数这次赋值和普通 的对象赋值不太一样js会告诉浏览器，密切关注这个元素，如果有人点击它帮我把这个函数运行一下，运行函数的时候给我传一个参数，参数为一个对象对象中要详细的记录这次点击的一些信息 这个对象被称为事件对象 ```javascript // 使用 onxxx var el=document.getElementById(‘box’)el.style.color=’red’;el.onclick=(function(){ return function(){ } })(); // 使用addEventListener el.addEventListener(‘’,function(){ console.log(e)},flase) 区别： 一些H5事件并没有onxxx这个版本 onxxx 再赋值一次，会覆盖上次赋值的那个 函数，addEventListener 没有这个问题。它可以给事件添加多个函数，事件触发的时候 按照添加顺序，逐个调用处理函数 移除事件 取消事件注册 onxxxthis.onxxx=null; addEventListenervar clickHandler = function(e){console.log(e) this.style.background = &apos;red&apos;; this.removeEventListener(&apos;click&apos;,clickHandler); } yi.addEventListener(‘click’,clickHandler) 自定义事件//不要给自定义事件阻止冒泡 e.stopPropagation()//鼠标按住5秒触发一个事件eg: var fiveonclick= new Event(‘fiveonclick’) yi.addEventListener(‘mousedown’,function(){ console.log(‘5秒事件触发了’) clearInterval(timerId) }) var timerId; yi.addEventListener(‘mousedown’,function(){ var i=0; timerId=setInterval(function(){ i +=1; if( i === 5 ){ yi.dispatchEvent(fiveonclick) yi.style.background=’red’ } },1000) }) yi.dispatchEvent(fiveonclick); //三次点击函数 var onclickwu=function(el,fn){ var clickwu = new Event(‘clickwu’) el.addEventListener(‘clickwu’,function(e){ //不要给自定义事件阻止冒泡 fn.call(el,e); }) var i=0; el.addEventListener(‘click’,function(e){ e.stopPropagation(); i += 1; if( i === 3 ){ el.dispatchEvent(clickwu) el.style.background=’blue’ } }) el.addEventListener(‘click’,function(e){ // console.log(1) e.stopPropagation(); }) // el.addEventListener(‘click’,function(e){ // console.log(1); // e.stopPropagation(); // }); } onclickwu(yi,function(){ alert(1) }) onclickwu(er,function(){ alert(2) }) onclickwu(san,function(){ alert(3) })//长按事件函数// el对象 fn替换的this c控制时间eg:var changan=function(el,fn,c){ var changan= new Event(‘changan’) el.addEventListener(‘changan’,function(e){ fn() }) var timerId; el.addEventListener(‘mousedown’,function(){ var i=0; setInterval(function(){ i += 1; if( i === c ){ el.dispatchEvent(changan) el.style.background=’red’ } },1000) }) document.addEventListener(‘mouseup’,function(){ console.log(‘5秒事件触发了’) clearInterval(timerId) }) } changan(yi,function(){ alert(1)},5) click dblclick threeclick var threeclick = new Event(‘threeclick’); //用变量存储下来var box=document.querySelector(‘.box’);box.addEventListener(‘threeclick’,function(){ console.log(‘threeclick’)})box.addEventListener(‘click’,(function(){ var cishu=0; return function(){ cishu += 1; if( cishu ===3){ box.dispatchEvent(threeclick) } setTimeout(function(){ cishu=0; },500) } })())box.dispatchEvent(threeclick); //dispatchEvent 分发 阻止事件冒泡和事件 从页面结构上调整,让元素之间不再是包含关系 使用事件对象身上的stopPropagation去阻止它box.addEventListener(‘click’,function(e){console.log(1); e.stopPropagation(); });eg:yi.addEventListener(‘click’,function(e){console.log(1); e.stopPropagation(); }); er.addEventListener(‘click’,function(){console.log(2); }); san.addEventListener(‘click’,function(){console.log(3); }); 阻止事件的默认行为document.addEventListener(&apos;dblclick&apos;,function(e){ e.preventDefault(); }) //从事件的根源去阻止它 document.addEventListener(&apos;mousedown&apos;,function(e){ e.preventDefault(); }) document.addEventListener(&apos;keydown&apos;,function(e){ e.preventDefault(); }) document.querySelector(&apos;input&apos;).addEventListener(&apos;mousedown&apos;,function(){ e.preventDefault(); }) 回调函数当我们把函数X作为参数传给函数Y函数Y内部有对函数X的调用我们把函数X叫做回调函数 ##遍历一个函数var arr=[1,2,3,4,5]arr.forEach(function(v){ console.log(v)})如果就是数组，我们遍历的时候可以使用var arr = [1,2,3,4,5]arr.forEach(function(v){ console.log(v)})如果是类数组对象，我们遍历的时候可以使用var arr=[];forEach = arr.forEach;filter = arr.filtervar els = document.querySelectorAll(‘div’)forEach.call(els,function(v){ console.log(v) //v就是dom集合中的dom对象})arr.filter(function(v){ return v.id = id //filter 条件为真保存下来如果满足就放到新数组中 要不就不操作})]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML标签学习]]></title>
    <url>%2F2016%2F01%2F01%2FME-HTML%2FHTML-html5%2F</url>
    <content type="text"><![CDATA[[html标签中lang属性及xml:lang属性的作用]lang属性：HTML语言声明属性，用来定义当前文档显示的语言。 如：lang=”en”表示定义语言为英文；lang=”zh-CN”表示定义语言为中文。其实对于文档显示来说怎样写都无所谓，定义成en的文档也可以显示中文，定义成zh-CN的文档也可以显示英文。但还是应该遵循标准，毕竟这个属性对浏览器和搜索引擎还是有作用的。 其实，在新的XHTML文档中，lang属性已经被xml:lang属性代替。但是，XHTML规范建议在XHTML 1.0文档的元素中同时使用lang属性和xml:lang属性，以在不同的浏览器之间获得最大的兼容性。如果网页定义为XHTML1.1或者XML格式,那么可以使用xml:lang属性(因为xml:lang属性是在XML中确定语言信息的标准用法)。 设计 lang 属性是为了向用户提供语言特有的显示，尽管它对主要的浏览器具有较小的影响。使用lang属性后，真正受益的是搜索引擎(搜索引擎利用它能够告诉用户采用哪一种语言编写文档)、屏幕阅读器(屏幕阅读器利用它能够以不同的方式发音不同的语言)以及一些应用程序(应用程序能够在它们不支持所提供的语言或者该语言与它们的默认语言不同时向用户发出警报)。当lang属性用于元素中时，它将作用于整个文档；而在用于其他元素中时，它将仅作用于这些元素的内容。 lang属性的值是ISO-639标准两字符语言代码。如果希望指定某种语言的方言，可以在语言代码后面紧跟一个破折号和一个子代码名称。 示例如下：1234声明英文文档： `&lt;``html` `lang``=``&quot;en&quot;` `xml:lang``=``&quot;en&quot;``&gt;`声明中文文档： `&lt;``html` `lang``=``&quot;zh-CN&quot;` `xml:lang``=``&quot;zh-CN&quot;``&gt;` 以上就是html中lang属性的一些简介，详情可以参考W3C官方文档： HTML a 标签的属性 HTML a 标签的 href 属性 HTML a 标签的 type 属性 HTML a 标签的 download 属性 只有 Firefox 和 Chrome 支持 download 属性。download里面的属性值为用户想要下载图片的名字 可以留空 1&lt;a href="/images/myw3schoolimage.jpg" download="w3logo"&gt; HTML a 标签的 target 属性 12345_blank 在新窗口中打开被链接文档。_self 默认。在相同的框架中打开被链接文档。_parent 在父框架集中打开被链接文档。_top 在整个窗口中打开被链接文档。framename 在指定的框架中打开被链接文档。 HTML a 标签的 name 属性 name 属性用于指定锚（anchor）的名称。 1234&lt;ul&gt;&lt;li&gt;&lt;a href="#C1"&gt;第一章&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#C2"&gt;第二章&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 第一章 本章讲解的内容是 … … 第二章 本章讲解的内容是 … … 123456789* &lt;a href=&quot;http://www.w3school.com.cn/tags/att_a_charset.asp&quot;&gt;HTML a 标签的 charset 属性&lt;/a&gt; &gt; a 标签的 charset 属性用于指定作为链接目标的文档中所使用的字符编码。charset 属性的值必须是标准字符集的名称，例如 &quot;UTF-8&quot;，默认值是 &quot;ISO-8859-1&quot;。 &gt; 主流的浏览器几乎都不支持 charset 属性。```html&lt;a charset=&quot;gb2312&quot; href=&quot;&quot;&gt;charset&lt;/a&gt; HTML a 标签的 hreflang 属性 1&lt;a href="http://www.w3school.com.cn" hreflang="zh"&gt;W3School&lt;/a&gt; HTML a 标签的 coords 属性 coords 属性与 shape 属性配合，可以规定 object 或 img 元素中链接的尺寸、形状和位置。注释：左上角的坐标是 0,0。 只有 Firefox 和 Opera 支持 coords 属性。 1234567&lt;object data="planets.gif" alt="Planets" type="image/gif" usemap="#Map1"&gt; &lt;map name="Map1"&gt; &lt;a href="sun.htm" shape="rect" coords="0,0,110,260"&gt;Sun&lt;/a&gt; &lt;a href="mercur.htm" shape="circle" coords="129,161,10"&gt;Mercury&lt;/a&gt; &lt;a href="venus.htm" shape="circle" coords="180,139,14"&gt;Venus&lt;/a&gt; &lt;/map&gt;&lt;/object&gt; HTML a 标签的 shape 属性 HTML a 标签的 media 属性 media 属性规定目标 URL 是为什么类型的媒介/设备进行优化的。该属性用于规定目标 URL 是为特殊设备（比如 iPhone）、语音或打印媒介设计的。该属性可接受多个值。只能在 href 属性存在时使用。 1&lt;a href="att_a_media.asp?output=print" media="print and (resolution:300dpi)"&gt;打开用于打印的 media 属性页面&lt;/a&gt; HTML a 标签的 rel 属性 a 标签的 rel 属性用于指定当前文档与被链接文档的关系。从源到目标的关系是移动到下一个文档，而从目标到源的关系则是返回前一个文档。 1&lt;a rel="friend" href="http://www.w3c.com/"&gt;w3c&lt;/a&gt; HTML a 标签的 rev 属性 a 标签的 rev 属性用于指定当前文档与被链接文档的关系。从源到目标的关系是移动到下一个文档，而从目标到源的关系则是返回前一个文档。 1&lt;a rev="friend" href="http://www.w3c.com/"&gt;w3c&lt;/a&gt; HTML abbr 简称 缩写 标签 标签指示简称或缩写，比如 “WWW” 或 “NATO”,通过对缩写进行标记，您能够为浏览器、拼写检查和搜索引擎提供有用的信息。提示：可以在 标签中使用全局的 title 属性，这样就能够在鼠标指针移动到 元素上时显示出简称/缩写的完整版本。 1The &lt;abbr title="People's Republic of China"&gt;PRC&lt;/abbr&gt; was founded in 1949. HTML acronym 首字母缩略 标签(html5不支持) HTML5 中不支持 标签。请使用 标签代替。 1&lt;acronym title="World Wide Web"&gt;WWW&lt;/acronym&gt; HTML address 地址 标签 标签定义文档或文章的作者/拥有者的联系信息。如果 元素位于 元素内，则它表示文档联系信息。如果 元素位于 元素内，则它表示文章的联系信息。 元素中的文本通常呈现为斜体。大多数浏览器会在 address 元素前后添加折行。 HTML applet 小程序 标签(html5不支持) 标签定义图像映射中的区域（注：图像映射指得是带有可点击区域的图像）。area 元素总是嵌套在 标签中。注释： 标签中的 usemap 属性与 map 元素 name 属性相关联，创建图像与映射之间的联系。 HTML 与 XHTML 之间的差异在 HTML 中， 没有结束标签。在 XHTML 中， 必须正确地关闭。 HTML article 文章 标签 标签规定独立的自包含内容。一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发。 元素的潜在来源：论坛帖子报纸文章博客条目用户评论 1234&lt;article&gt; &lt;h1&gt;Internet Explorer 9&lt;/h1&gt; &lt;p&gt;Windows Internet Explorer 9（简称 IE9）于 2011 年 3 月 14 日发布.....&lt;/p&gt;&lt;/article&gt; HTML aside 侧栏 标签 的内容可用作文章的侧栏。 HTML audio 音频 标签 标签定义声音，比如音乐或其他音频流。可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。您的浏览器不支持 audio 标签。 HTML b 粗体文本 标签HTML base 规定页面所有的链接 在页面header头部放一个 标签HTML basefont 规定页面上的默认字体颜色和字号：只有 Internet Explorer 支持 basefont 标签。应该避免使用该标签。 标签HTML bdi 标签 把用户名从周围的文本方向设置中隔离出来： bdi 指的是 bidi 隔离。 bdi 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。 在发布用户评论或其他您无法完全控制的内容时，该标签很有用。 HTML bdo 标签 bdo 元素可覆盖默认的文本方向。 dir ltr rtlHTML big 标签 big 标签呈现大号字体效果。HTML blockquote 标签HTML body 标签 body 元素定义文档的主体。换行HTML button 标签HTML canvas 标签HTML em strong dfn code samp kbd var cite 标签 把文本定义为强调的内容。 把文本定义为语气更强的强调的内容。 HTML col 标签 col 元素为表格中的三个列规定了不同的对齐方式：HTML datalist 标签 下面是一个 input 元素，datalist 中描述了其可能的值：所有主流浏览器都支持 标签，除了 Internet Explorer 和 Safari。HTML dl 标签HTML dt 标签HTML dd 标签HTML embed 标签 embed 标签定义嵌入的内容，比如插件。HTML figcaption 标签 用作文档中插图的图像，带有一个标题HTML figure 标签 用作文档中插图的图像：HTML 页脚 标签HTML form 标签 表单提交TML frame 标签 引入一个框架TML frameset 标签 框架集TML h1-h6 标签TML head 标签TML header 标签 对主页的描述 h5新标签HTML hr 标签 被水平线分隔的标题和段落：HTML i 标签 斜体HTML iframe 标签HTML img 标签]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[input标签]]></title>
    <url>%2F2016%2F01%2F01%2FME-HTML%2FHTML-input%2F</url>
    <content type="text"><![CDATA[检测input内容值改变的事件 常用写法 用于文字检测 1234&lt;!-- IE9 以下不支持 --&gt;$(obj).on('input',function()&#123;&#125;)&lt;!-- IE支持 --&gt;$(obj).on('propertychange',function()&#123;&#125;) onchange 用于上传图片onchange 事件会在域的内容改变时触发。支持的标签input,textarea,select,keygen。注意：在元素的值改变了且失去焦点时触发（两次的值一样不会触发）。缺陷：通过js代码改变DOM的值不会触发，解决在js代码里改值了调用其change 的function() 或者调.change()方法。 1234JS： &lt;input type="text" id="cc" onchange="function()"&gt;JQuery:$("#cc").change(function()&#123;&#125;); onpropertychange 用于文字检测onpropertychange会实时触发，会在元素的属性改变时就触发事件。当元素disable=true时不会触发。缺陷：只在IE 下支持，其他浏览器不支持，用oninput来解决。 oninputoninput在input或textarea的值发生改变时触发，不需要等到元素失去焦点，是实时的。它是HTML5的事件，可用于检测文本类输入框的值。缺陷：从脚本中修改值不会触发事件。从浏览器下拉提示框里选取值时不会触发。IE9 以下不支持，所以IE9以下可用onpropertychange 事件代替。 1234JS：&lt;input type="text" oninput="functionName()"&gt;JQuery: $("#cc").on('input propertychange',functionName); addEventListeneraddEventListener()用于向指定元素添加事件方法。使用removeEventListener()移除添加的事件方法。IE9以下不支持，用attachEvent代替。 123element.addEventListener(event, function, useCapture)https://www.cnblogs.com/littlesummer/p/6428116.html input、textarea标签获取焦点时，光标出现在文本末尾。 文本框自动获取光标，但是光标总是出现在文本框最前面 1234567891011121314151617181920212223242526272829&lt;!-- jq方法 --&gt;&lt;!-- 获取焦点后光标在字符串后 --&gt;&lt;!-- 其原理就是获得焦点后重新把自己复制粘帖一下 --&gt;var _val=$(obj).val(); $(obj).val("").focus().val(_val); &lt;!-- js方法 --&gt;&lt;input type="text" id="test" value="1234568790"&gt;&lt;input type="button" id="focus" value="编辑"&gt;$('#focus').on('click', function() &#123; var test = document.getElementById('test') test.focus(); moveToEnd(test); &#125;);function moveToEnd(el) &#123; if (typeof el.selectionStart == "number") &#123; el.selectionStart = el.selectionEnd = el.value.length; &#125; else if (typeof el.createTextRange != "undefined") &#123; el.focus(); var range = el.createTextRange(); range.collapse(false); range.select(); &#125;&#125; 'selectionStart' 表示输入性元素selection起点的位置，'selectionEnd' 表示输入性元素selection末点的位置，都是 DOM 属性。 input、textarea文本区域选中1234567891011&lt;!-- js方法 --&gt;&lt;input type="text" id="test" value="1234568790"&gt;&lt;input type="button" id="focus" value="编辑"&gt;$('#focus').on('click', function() &#123; var test = document.getElementById('test'); test.selectionStart = 2; test.selectionEnd = 6; &#125;);https://www.cnblogs.com/LY-leo/p/5796722.html]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe]]></title>
    <url>%2F2016%2F01%2F01%2FME-HTML%2FHTML-iframe%2F</url>
    <content type="text"><![CDATA[iframe使用问题 怎么获取iframe内容的高度？(iframe自适应高度的问题)123&lt;div class="iframe-wrap" &gt;&lt;iframe src="index - 副本.html" frameborder="0" id="login_container" scrolling="no" width="1000" height="400" onLoad="iFrameHeight()"&gt;&lt;/iframe&gt;&lt;/div&gt; 123456789function iFrameHeight() &#123;var ifm= document.getElementById("login_container");console.log(ifm);var subWeb = document.frames ? document.frames["login_container"].document :ifm.contentDocument; if(ifm != null &amp;&amp; subWeb != null) &#123; ifm.height = subWeb.body.scrollHeight; console.log(ifm.height) &#125;&#125; 为了测试，iframe的height你可以预先设置一个固定高度比如：height=”400”（也可以使用100%）,iframe加载完，会自动调整页面大小。 iframe怎样刷新父页面的父页面？frame页面是内嵌到父页面的，当点击iframe页面的服务器控件时，默认只刷新iframe页面，父页面是不会刷新的。若想刷新父页面，可以使用js来实现，如 1. parent.location.reload(); 这种方法会重新加载整个页面。但如果要在原页面的基础上传递参数，则可以使用下面的方法： 2.top.document.location.href=&apos;xxx.aspx?id=xx&apos;。 但这两种方法都有一个共同的缺点，就是iframe内嵌页面的状态不会保存了，刷新后会重新回到第一次加载的状态。 怎么使iframe在iOS设备上支持滚动？123&lt;div class="iframe-wrap" &gt;&lt;iframe src="index - 副本.html" frameborder="0" id="login_container" scrolling="no" width="1000" height="400" onLoad="iFrameHeight()"&gt;&lt;/iframe&gt;&lt;/div&gt; 怎麼判断iframe是否加载完成？12&lt;iframe id="previewFrame" scrolling="no" class="previewFrame" frameborder="0"&gt;&lt;/iframe&gt;` 123456789101112var iframe = document.getElementById("previewFrame"); if (iframe.attachEvent) &#123; iframe.attachEvent("onload", function() &#123; //以下操作必须在iframe加载完后才可进行 $("#themes").find(".selected").trigger("click"); &#125;); &#125; else &#123; iframe.onload = function() &#123; //以下操作必须在iframe加载完后才可进行 $("#themes").find(".selected").trigger("click"); &#125;; &#125; CSS 代码要让IFRAME支持滚动,需要一个常用的CSS属性和一个很少人知道的CSS属性(property): -webkit-overflow-scrolling: touch; 属性值就是专为浏览器中溢出(overflow)时需要滚动的元素设计的。 如果没有指定这个属性,当你想滚动iframe时,实际上会导致外层页面的滚动,通过它你就可以对IFRAME的滚动进行控制! 在原作者的博客站点中,使用了下面的CSS: 12345678910111213.iframe-wrap &#123; position: fixed; right: 0; bottom: 0; left: 0; top: 0; -webkit-overflow-scrolling: touch; overflow-y: scroll; &#125; .login_container&#123; height: 100%; width: 100%; &#125; iframe原理 把iframe解释成“浏览器中的浏览器“很是恰当 1&lt;iframe frameborder=0 width=170 height=100 marginheight=0 marginwidth=0 scrolling=no src=http://www.163.com&gt;&lt;/iframe&gt; iframe用于设置文本或图形的浮动图文框或容器。 border1&lt;iframe border="3"&gt;&lt;/iframe&gt; 设定围绕图文框的边缘宽度 frameborder1&lt;iframe frameborder="0"&gt;&lt;/iframe&gt; 设置边框是不否为3维（0=否，1=是） height,width1&lt;iframe height="31" width="88"&gt;&lt;/iframe&gt; 设质边框的宽度和高度 scrolling1&lt;iframe scrolling="no"&gt;&lt;/iframe&gt; 是否有滚动条（yse,no,auto) src1&lt;iframe src="girl.gif"&gt;&lt;/iframe&gt; 指定iframe调用的文件或图片(HTML,HTM,GIF,JPEG,JPG,PNG,TXT,.)]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事件流]]></title>
    <url>%2F2016%2F01%2F01%2FME-HTML%2F%E4%BA%8B%E4%BB%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[事件和事件流overflow:scroll 超出后出现流动条 默认情况下;当一个元素身上的 某类 事件触发的时候，该元素的祖先元素都会收到通知。如果祖先元素身上也注册了 同类 事件，那些事件函数也会被一一调用，调用从下往上，这种行为被称为事件冒泡。冒泡只和文档结构有关，和元素位置无关。 事件冒泡是任何时刻都在进行的，元素身上注没注册某类事件，事件都会冒泡。 根据事件流的这个特点带来一种编程技巧叫做事件委托（委派） 事件委托(xiao div 将自己需要处理的东西给了大div ) 3种情况下 嵌套型 布局中没有某个子元素js添加上了子元素 防止子元素 父元素事件冲突e.target 事件委派(大 div 将收到的命令分发给不同函数进行处理) var el=e.target // if(el.classList.contains(“dj”)){ } 用在展示信息的web页面中用在web app中 ()]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2016%2F01%2F01%2FME-HTML%2Fcanvas%2F</url>
    <content type="text"><![CDATA[解决用dom 建立小游戏会出现大量卡顿的现象canvas 游戏必须 没法用样式设置 必须用内置属性设置width,height 不建议用css强制修改 var canvas = document.querySelector('#canvas') var ctx = canvas.getContext('2d') 画笔 CanvasRenderingContext2D画布的渲染 console.dir(ctx) ctx.beginPath(); 开始这是一只笔 ctx.moveTo(0,0); 开始坐标 ctx.lineTo(300,300); 结束坐标 ctx.stroke(); 直线 ctx.closPath();结束 #canvas 常用API ##形状 矩形ctx.fillRect(x,y,widht,height); 填充矩形ctx.strokeRect(x,y,widht,height); 框线矩形 ctx.clearRect(); 清除矩形区域 绘制上的元素无法更改 圆形ctx.arc(x,y,半径，开始角度,布尔值); 圆 线ctx.beginPath(); 开始一个路径ctx.moveTo(); 移动画笔到某点ctx.lineTo(); 让路径中拥有一条到某点的线（不会直接绘制）ctx.rect(x,y,widht,height); 让路径拥有一个矩形（不会直接绘制）ctx.fill(); 填充当前路径ctx.stroke(); 描边当前路径ctx.closePath(); 结束一个路径 ctx.quadraticCurveTo(cp1x, cp1y, x, y)二次贝塞尔ctx.bezierCurveTo(cp1x.cp1y,cp2x,cp2y,x,y)三次贝塞尔 样式ctx.fillStyle = “rgb(200,0,0)”;ctx.strokeStyle=’red’;ctx.globalAlpha = 0.2; 透明度 线型 Line stylesEDIT可以通过一系列属性来设置线的样式。 lineWidth = value设置线条宽度。lineCap = type设置线条末端样式。lineJoin = type设定线条与线条间接合处的样式。miterLimit = value限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。getLineDash()返回一个包含当前虚线样式，长度为非负偶数的数组。setLineDash(segments)设置当前虚线样式。lineDashOffset = value设置虚线样式的起始偏移量。 位移(挪动画布)ctx.save() 保存快照 只能保存画布状态不能保存东西（包含画笔）ctx.restore() 引用以前的 ctx.translate(x,y)ctx.rotate((Math.PI/180)*30)ctx.scale(); //清除画面的两种方式document.onclick = function(){canvas.width = canvas.height = 600;ctx.clearRect(0,0,600,600)} 获得时间var now = new Date()毫秒var m = now.getMilliseconds();秒var s = now.getSeconds()分var f = now.getMinutes()时var h = now.getHours() window.onload = function(){var img = document.querySelector(‘#img’);var xxx =ctx.createPattern(img,’no-repeat’);ctx.fillStyle = xxx;} var img = new Image();img.src = ‘a.png’;img.onload = function(){var xxx =ctx.createPattern(img,’no-repeat’);ctx.fillStyle = xxx;}]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事件对象]]></title>
    <url>%2F2016%2F01%2F01%2FME-HTML%2F%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[事件对象 浏览器检测到事件发生时，会调用事件的注册函数 //&gt;描述 浏览器在调用注册的时候，会给该函数传递一个参数 这个参数是一个对象，对象中详细的记录了和本次事件相关的一切信息 Atom软件 谷歌浏览器 1234567var el=document.getElementById('one');var fn=function()&#123; alert(1);&#125;//var xx=new Event();//fn(xx)el.onclick=fn; 鼠标事件 事件对象中的一些属性 shiftKey altKey ctrlKey clinetX clinetY selintX selintY ##键盘事件 keydown 按下 （除了被操作系统拦截的按键 其他能触发） keyup 弹起来 keypress （只在能产生可打印字符的按键时触发） down up press down,up up,press down,up,press num 26个字母 * / + enter . 10个数字 上下左右这一坚行 ##键盘事件 键盘对象 shiftKey ctrlKey altKey keycode…e.keyCode 会返回按键的unicode码 在keyup和keydown事件中按下字母的e.keyCode永远是大写字母的unicode码 String.fromCharCode() 将字符转换为ascii码 函数在定义的时候会记录下自己可见范围内的所有变量形成一个链条，叫做函数的作用域链函数调用时。如果在函数内部有对变量的引用函数会在自己的作用域中由近及远的支寻找这个变量匿名函数是一个单独的函数闭包el.onclick=(function(){})()123456789101112131415 // el.onclick=function()&#123; // // alert(1) // this.className="da selected"; // &#125;el.onclick=(function()&#123; return function(e)&#123; //浏览器解析是一定会传输一个实参 可以先给函数定义一个形参 var kaiguan=true; if(e.shiftKey&amp;&amp;e.altKey&amp;&amp;e.ctrlKey)&#123; this.className=kaiguan?"da selected":"da"; kaiguan=!kaiguan; &#125;else&#123; this.className="da" &#125; &#125; &#125;)(); // 函数的自调用 ###事件定位属性static 默认方式定位fixed 固定定位absolute 绝对定位relative 相对定位 ##颜色默认值backgroundColor默认值 transparent ##监视者transition:all .5s ease; 12345var obj=&#123;&#125;; for(var i=0;i&lt;100;i++)&#123; obj[i]=String.fromCharCode(i) &#125; console.log(JSON.stringify(obj)) var box=document.querySelector(‘.box’);firstElementChild 第一个元素createElement 创建一个元素appendChild 追加到父元素String.fromCharCode(i) 变ascii ###取随机数100-140 100+Math.random()*40delete obj[key] 删除一个数据的元素 ##表单事件 focus 获得焦点 blur 失去焦点 change 改变事件 必须改变表单里的内容 *setAttribute 给元素自定义一个属性]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试]]></title>
    <url>%2F2012%2F02%2F28%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[http://www.w3school.com.cn/careers/index.asp https://www.epubit.com/selfpublish/article/1265;jsessionid=EE26E307FBE5B6AFABBA93C6AB210212 CSS1. 盒子模型 （box model） ： IE 和 w3c 模型 包括 width height margin padding border content W3C 和 IE 模型的区别 IE的content包含了 padding,border 2. box-sizing:border-box;作用 主要为了简化盒模型 让宽度 width 包含了border+padding+内容1234/* 设置当前盒子为 标准盒模型（默认） */box-sizing: content-box;/* 设置当前盒子为 IE盒模型 */box-sizing: border-box; 123element.style.width/height;缺点：通过这种方式，只能获取行内样式，不能获取内嵌或者外链的样式window.getComputedStyle(element).width/height;（兼容 Chrome、火狐。是通用型方式）element.currentStyle.width/height; （IE） 标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。 3. css选择器 标签选择器 id选择器 类（class）选择器 属性选择器 派生选择器（上下文选择器） 伪类选择器 属性选择器 4.css形状12345678910111213// 圆角.test1&#123; width:50px; height:150px; border-radius : 50%; background:red;&#125;// 椭圆.test2&#123; width: 50px; height: 50px; border-radius : 50%;&#125; JSthis 指向问题 this 普通模式 指向window , 对象函数调用的时候指向的是所执行环境 ES6(严格模式下) 为undefined this 作为对象方法调用 会指向这个对象，多个对象嵌套 会指向最近的哪个值多个函数嵌套 函数里面在嵌套一个函数的时候里面的函数会指向window this 通过构造函数调用 通过new一个对象 会指向这个新对象， 如果return 一个对象的时候 this会变为 return的这个值， call、apply区别 同：都是为了改变this的指向，将this指向为第一个参数异：call（obj,a,b,c,d） apply（obj,[a,b,c,d]） call第二个参数一个接受很多个值， apply接受的是一个数组。 bind（obj）会生成一个新的函数，新函数永远指向第一次传入的那个对象，用bind改变的指向，无法用call，apply、bind去改变。 箭头函数 会从上一层作用域链继承 this 不能通过 call、apply改变他的指向。 link - this 指向问题 es6 了解let, 作用域不同，循环中var i =0 ； 循环结束之后还在，let就undefined了 const, 常量，改变不了。 如果定义一个对象,或者数组，因为这两个本身是可变的所以会改变它，不建议使用这个定义你想要改变的值， promise , 箭头函数和普通函数的区别， 简化回调函数，修正this的指向， module 模块化 0.1+0.2 != 0.3 ？ 不等于 为了数值更加精确造成精度的缺失， 一般在计算钱的时候乘以100，计算完成之后在除以100 原理就是转为整数计算，保留几位小数就全部化为整数计算之后在转为小数 什么是闭包？ 要理解闭包，首先要理解javascript的特殊的变量作用域。变量的作用域无非就两种：全局变量和局部变量。javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。所以当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。12345678910// 解决了可以读取函数内部变量function a()&#123; var n = 10; function b()&#123; console.log(n); &#125; return b;&#125;var c = a();c(); 优点：解决了可以读取函数内部变量，当我们需要定义一些变量，并希望这些变量一直保存在内存中但又不会 “污染” 全局的变量时，就可以用闭包来解决。缺点: 因为嵌套的那个整个函数的变量都被保存在内存中，有可能会造成网页性能问题。 link 什么是闭包？link 阮一峰js闭包理解 什么是原型链？ 因为每个对象和原型都有原型，对象的原型指向原型对象，而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。js里面的东西都是对象，任何一个对象，通过原型链，找到它上面的原型对象中的方法和属性，一层一层查找。1234var A= &#123;&#125;;console.log(A.__proto__)var B= function &#123;&#125;;console.log(B.prototype) js里所有的对象都有proto属性，指向该构造函数的原型。但只有函数有prototype属性，这个属性是个指针，指向一个对象，这个对象的用途包含了实例共享的属性和方法，我们把这个对象叫做原型对象。 什么是作用域？js作用域（全局变量，局部变量） 数组中的去重12345678var data = [1,2,2,3,4,5,5,4];var newData = [];for(var i=0;i&lt;data.length;i++)&#123; if( newData.indexOf(data[i]) == -1 )&#123; newData.push(data[i]) &#125;&#125;console.log(newData); 5. 数组的方法有哪些？ sort() 排序 、shift 删除数组第一个 、unshift 最前面添加一个数据 、push 最后面添加一个join 数组转为字符串、 6. 字符串的方法 split(‘,’) 字符串转为数组toFixed(2) 保留两位小数 我叫*，从事前端开发三年左右，我上一家公司都是做的项目都是自己集团旗下网站的搭建，有小程序，移动端页面，积极参与开发用户体验的优化，项目需求，功能测试，代码优化，也做过直播、电商类型的h5页面开发，小程序。技术方面，使用到Weui ,layUI，vue技术栈等前端框架，es6，webpack，node, git等前端技术，脾气品性好，不易和同事产生冲突，在前两家公司中，除了学习到一些新的技术的收获，业务能力，自学能力，为人处世方面也有了很大的提升，因为刚开始入职第一家公司的时候因为是新人，所以很把握每一次开发的机会，很注重和同事之间的和谐相处，因为很专注，认真工作和学习的时候忽视身边的一些声音，我对每一份工作都抱着认真负责，有责任心的态度，老爹说过每个老板都想要的是认真负责的员工，所以做事情上面会比较负责和较真的。以上就是我的自我介绍。谢谢。 MVVMModel-View-viewModel数据类型UI视图监听数据和视图之间的交互ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 Vue技术栈vue-cli工程1、构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？webpack 打包发布node 搭建环境 2、vue-cli 工程常用的 npm 命令有哪些？npm install 下载node-modules 资源包的命令npm run dev 启动vue-cli 开发环境的命令npm run bulid 生产环境部署资源的命令npm run build –report 生产环境部署资源文件大小的命令 3、请说出vue-cli工程中每个文件夹和文件的用处build 用于配置webpack相关配置和脚本，开发中less,sass预编译，配置UI库config 配置文件存放 用于区分开发环境和生产环境的区别，dist 文件node_modules 依赖的资源包src 存放项目源码及需要引用的资源文件 asstes static 静态资源文件夹package.json 描述 用于 node_modules资源和启动、打包项目的npm命令行管理 4、config文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置build 对象下 对于 生产环境 的配置： index：配置打包后入口.html文件的名称以及文件夹名称assetsRoot：配置打包后生成的文件名称和路径assetsPublicPath：配置 打包后 .html 引用静态资源的路径，一般要设置成 “./“productionGzip：是否开发 gzip 压缩，以提升加载速度 dev 对象下 对于 开发环境 的配置： port：设置端口号autoOpenBrowser：启动工程时，自动打开浏览器proxyTable：vue设置的代理，用以解决 跨域 问题 5、请你详细介绍一些 package.json 里面的配置项目信息工具的版本信息打包执行程序生产环境依赖资源包开发环境依赖资源包 Vue核心知识点1、对于Vue是一套渐进式框架的理解简洁、高效、渐进式 不做别的事情，所有的都位置 数据驱动和组件系统去做 然后就是你可以在一个大系统里像引入jq一样引入他 2、vue.js的两个核心是什么？双向数据绑定，组件， 3、请问 v-if 和 v-show 有什么区别v-if 页面加载的时候不去加载，按需加载，减轻服务器压力v-show页面渲染的时候渲染出来了，css diaplay none的效果 4、vue常用的修饰符v-bind: :v-on: @v-for 、 v-if 、v-show、v-else 5、v-on可以监听多个方法吗？可以，v-on:keyup.enter 按下的时候判断是不是按的 回车键 6、vue中 key 值的作用用于 管理可复用的元素。因为Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做使 Vue 变得非常快，但是这样也不总是符合实际需求。 7、vue-cli工程升级vue版本前言：此命令谨慎使用，实际开发中如需升级建议直接使用 vue-cli 脚手架搭建，只需要了解即可！//升级插件npm-check-updatesnpm install npm-check-updates -g 8、vue事件中如何使用event对象？注意在事件中要使用 $ 符号1234567891011//html部分&lt;a href=&quot;javascript:void(0);&quot; data-id=&quot;12&quot; @click=&quot;showEvent($event)&quot;&gt;event&lt;/a&gt;//js部分showEvent(event)&#123; //获取自定义data-id console.log(event.target.dataset.id) //阻止事件冒泡 event.stopPropagation(); //阻止默认 event.preventDefault()&#125; 9、$nextTick的使用因为Vue的异步更新队列，$nextTick是用来知道什么时候DOM更新完成的。 10、Vue 组件中 data 为什么必须是函数11、v-for 与 v-if 的优先级12、vue中子组件调用父组件的方法$emit 13、vue中 keep-alive 组件的作用缓存页面，active 减轻服务器压力，提升用户体验 14、vue中如何编写可复用的组件？15、什么是vue生命周期和生命周期钩子函数？生命周期是指vue实例从创建开始，到初始化数据，编译模板，挂载Dom渲染，数据更新渲染，以及最后实例的销毁前后发生的一系列的行为就是vue的生命周期。 16、vue生命周期钩子函数有哪些？beforeCreate/created mounte/mounted 17、vue如何监听键盘事件中的按键？v-on:keyup.enter 18、vue更新数组时触发视图更新的方法19、vue中对象更改检测的注意事项20、解决非工程化项目初始化页面闪动问题21、v-for产生的列表，实现active的切换22、v-model语法糖的组件中的使用23、十个常用的自定义过滤器24、vue等单页面应用及其优缺点优点：数据驱动，简洁，高效，组件化，轻量，缺点：不利于seo，首次加载耗时相对较长，需要自己执行前进后退 25、什么是vue的计算属性？computed 26、vue-cli提供的几种脚手架模板3种，gulb 、webpack(常用) 27、vue父组件如何向子组件中传递数据？props :[]; 28、vue-cli开发环境使用全局常量29、vue-cli生产环境使用全局常量30、vue弹窗后如何禁止滚动条滚动？31、计算属性的缓存和方法调用的区别32、vue-cli中自定义指令的使用什么叫闭包，什么叫回调，什么叫原型，原型链，手写个数组排序，数组排序的方式，手写个数组去重 什么叫递归 说说路由 原形就是js中对象包含一个prototype的内部属性 这个属性就是这个对象的原形 proto 因为每个对象和原型都有原型，对象的原型指向原型对象，而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。 回调就是一个函数执行了 然后 你可以做任何事情去 不用管他了 当他执行完成之后 会进行接下来的流程 也就是说得回调函数 JavaScript 中的所有事物都是对象：字符串、数字、数组、日期，函数，等等。在 JavaScript 中，对象是拥有属性和方法的数据。 闭包就是能够读取其他函数内部变量的函数。 比如在一个函数中 声明一个 闭包函数 然后再函数执行的最后 return 出来这个闭包函数因为js 原理机制问题 函数内部的函数是可以读取到父函数的变量内容的 所以就可以在外面通过声明变量= 函数1 拿到函数1的变量 因为他占用大量内存所以不能随便滥用 1.构建一个新的数组存放结果2.for循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比3.若结果数组中没有该元素，则存到结果数组中 123456789101112131415161718Array.prototype.unique1 = function()&#123; var res = [this[0]]; for(var i = 1; i &lt; this.length; i++)&#123; var repeat = false; for(var j = 0; j &lt; res.length; j++)&#123; if(this[i] == res[j])&#123; repeat = true; break; &#125; &#125; if(!repeat)&#123; res.push(this[i]); &#125; &#125; return res;&#125;var arr = [1, 'a', 'a', 'b', 'd', 'e', 'e', 1, 0]alert(arr.unique1()); 思路：1.创建一个新的数组存放结果2.创建一个空对象3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。 12345678910111213Array.prototype.unique3 = function()&#123; var res = []; var json = &#123;&#125;; for(var i = 0; i &lt; this.length; i++)&#123; if(!json[this[i]])&#123; res.push(this[i]); json[this[i]] = 1; &#125; &#125; return res;&#125;var arr = [112,112,34,'你好',112,112,34,'你好','str','str1'];alert(arr.unique3()); 数组的增、删、改、查 增 删 改 查 字符串的增、删、改、查 增 删 改 查 数组转字符串字符串转数组数组的排序与去重js删除数组某个元素12345678910111213Array.prototype.remove = function(from, to) &#123;var rest = this.slice((to || from) + 1 || this.length);this.length = from &lt; 0 ? this.length + from : from;return this.push.apply(this, rest);&#125;;// 移除数组中的第二项array.remove(1);// 移除数组中的倒数第二项array.remove(-2);// 移除数组中的第二项和第三项（从第二项开始，删除2个元素）array.remove(1,2);// 移除数组中的最后一项和倒数第二项（数组中的最后两项）array.remove(-2,-1); // 数组排序1234567Array.prototype.sortNumber = function (property) &#123;return function (a, b) &#123;var value1 = a[property];var value2 = b[property];return value1 - value2;&#125;&#125;; js追加到数组第一个12var arr = [1,2];arr.unshift(&apos;0&apos;); 判断数据是否在数组中12345678Array.prototype.isInArray = function (value) &#123;for (var i = 0; i &lt; this.length; i++) &#123;if (value === this[i]) &#123;return true;&#125;&#125;return false;&#125;; 掉字符串中所有空格(包括中间空格, 需要设置第2个参数为: g)1234567891011String.prototype.Trim = function (is_global)&#123;var result;result = this.replace(/(^\s+)|(\s+$)/g, &quot;&quot;);if( is_global == &apos;&apos; || is_global == undefined )&#123;is_global = &apos;&apos;;&#125;if (is_global.toLowerCase() == &quot;g&quot;) &#123;result = result.replace(/\s/g, &quot; &quot;);&#125;return result;&#125; 打印原型链12var cc = &apos;1&apos;;console.log(cc.__proto__) JS判断字符串是否为空或是否全为空格1234567891011121314var test = &quot; \n &quot;;//var test = &quot; &quot;;if(test.match(/^\s+$/))&#123; console.log(&quot;all space or \\n&quot;)&#125;if(test.match(/^[ ]+$/))&#123; console.log(&quot;all space&quot;)&#125;if(test.match(/^[ ]*$/))&#123; console.log(&quot;all space or empty&quot;)&#125;if(test.match(/^\s*$/))&#123; console.log(&quot;all space or \\n or empty&quot;)&#125; 1、display:none和visibility:hidden的区别？ ？？？ 2、position的absolute与fixed区别 position:absolute是绝对定位 依托于fixed position:relative 如果不设置 依托的定位则当body为 依托元素 position:fixed 固定定位 在整个body中的定位 3、CSS优先级算法如何计算 行内样式》链式选择器》id选择器》class选择器》类名选择器同级样式后面的会覆盖前面的样式越靠后越优先。 4、如何实现浏览器内多个标签页之间的通信? 前端框架 ajax 模板语言 截取url信息 localStorage sessionStorage cookies 5、iframe有那些缺点？ 如果直接将链接填入url中会在缓存页面的时候就将iframe缓存出来，其实本意是不想要的，造成资源请求的浪费。如果点击事件触发url的时候用户体验效果会差一点，用加载动画进行模态加载，提高用户体验。不利于页面的seo。内外部控制逻辑比较混乱。 好处： 页面复用 6、请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookies 存储数据少 会上传到服务器 下面两个不会给服务器上传资源 只是在做一个本地存储 数据存储大sesionStorage 是单个会话的数据 页面销毁 数据消失localStorage 持久化的数据存储 本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除 相同点：都存储在客户端不同点：1.存储大小cookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。2.有效时间localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除。cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 数据与服务器之间的交互方式cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 数组的增删改查字符串的截取判断元素是否存在在数组中判断字符串是否在一个对象中判断元素是否隐藏数组排序 删除对象的某个属性值 delete _obj.sku_id 字符串转为数组 var string = ‘a,b,c’string.split(‘,’) 数组转为字符串 var arr = [1,2,3]arr.join(‘-‘)]]></content>
      <categories>
        <category>SPEC</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入世-49条神的回答]]></title>
    <url>%2F1900%2F01%2F04%2FME-%E4%B8%AA%E4%BA%BA%2F%E5%85%A5%E4%B8%96-49%E6%9D%A1%E7%A5%9E%E7%9A%84%E5%9B%9E%E7%AD%94%2F</url>
    <content type="text"><![CDATA[笑看生活各种尴尬，从平凡中汲取知识。 1、朋友的标准是什么?1答：出世的智者，入世的强者，或者正常而阳光的普通人。 2、男性更看重女性的身材、脸蛋，还是思想?1答：脸蛋和身材决定了我是否想去了解她的思想，思想决定了我是否会一票否决掉她的脸蛋和身材。 3、”别让孩子输在起跑线上”有道理吗?1答：一辈子都要和别人去比较，是人生悲剧的源头。 4、做哪些事情可以提升生活品质?1答：定期扔东西。 5、结婚以后两个人在一起最重要的是什么?1答：就当这婚还没结。 6、怎么反驳”你行你上啊”的逻辑?1答：“我评论个电冰箱，自己还得会制冷啊?” 7、把学费拿来念书还是环游世界更合适? 为什么?1答：读书在没有充分的知识做为前提的情况下，即使行了万里路也不过是邮差而已。 8、为什么部分人会产生”聪明智慧的姑娘都被憨憨的小伙儿搞定了”的印象?1答：严肃地说，我觉得，要么姑娘只是看起来聪明，要么小伙儿只是看起来憨…… 9、你心中的完美爱情是怎么样的?1答：可以有不完美。 10、异国长期生活，改变了你的哪些”是非观”?1答：很多事情只是不同，并无是非。 11、是不是一个人越成熟就越难爱上一个人?1答：不是越成熟越难爱上一个人。是越成熟，越能分辨那是不是爱。 12、如何让这个世界变得美好?1答：把你自己变得更美好。 13、苦难有什么价值?1答：永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。 14、如何反驳”现实点，这个社会就是这样”?1答：&quot;你是怎样，你的世界就是怎样。&quot; 15、你对自由的理解是什么?1答：说“不”的能力。 16、怎么看待励志的书籍?1答：看再多，那都是别人的人生。 17、同样是别人比自己强，为什么有时会产生嫉妒心理，而有时会产生崇拜?1答：远的崇拜，近的嫉妒；够不着的崇拜，够得着的嫉妒；有利益冲突的嫉妒，没利益冲突的崇拜。 18、为什么当看到好照片时人们通常的反应是”真不错，你用的是什么相机?”，当看到烂照片时，则往往笑话拍摄者水平很臭?1答：人习惯性的将自己的成功归因于自身，失败归因于环境;而将他人的成功归因于环境，失败归因于其自身。 19、怎样有效提出推荐或建议同时，避免给人灌输和强迫的感觉?1答：说服他人不要诉诸理性，应求于利益。 20、哪些技能，经较短时间的学习，就可以给人的生活带来巨大帮助?1答：夸奖他人。 21、你是如何走出人生的阴霾的?1答：多走几步。 22、二十六岁，工作三年却将留学三年，值得吗?1答：普通玩家选择标准配置，高端玩家选择自定义配置。 23、如何看待”年轻时就释怀与淡泊，是没有希望的”这句话?1答：试图用一句话就来总结复杂的人生，是没有希望的。 24、要怎样努力，才能成为很厉害的人?1答：如果你注定要成为厉害的人，那问题的答案就深藏在你的血脉里;如果你注定不是厉害的人，那你便只需要做好你自己。 26、前半生与后半生的分界线是在哪里?1答：此时此刻。 27、你遇到过哪些让你眼前一亮、醍醐灌顶或对你改变很大的理念?1答：天赋决定了你能达到的上限，努力程度决定了你能达到的下限。以绝大多数人的努力程度之低，远远没有达到要去拼天赋的地步 28、人这一生为什么要努力？1答：最痛苦的事，不是失败，是我本可以。 29、在一个足够小的星球上行走，我们是在上坡还是下坡?1答：你感觉累就是上坡，感觉轻松就是下坡。 30、听过最落寞的一句话或诗句是什么?1答：不如意事常八九，可与言者无二三。 31、世界上有那么多好书好电影好动漫注定看不完，我们对这个事实该持何种态度?1答：怕什么真理无穷，进一寸有一寸的欢喜。——胡适 32、三十岁才开始学习编程靠谱吗?1答：种一棵树最好的时间是十年前，其次是现在。 33、向喜欢的女生表白被拒绝了，还是喜欢她，怎么办?1答：也许你弄错了什么是表白，表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。 34、省钱的好办法有哪些?1答：在买任何东西之前牢记九字箴言：你喜欢，你需要，你适合。 PS：适用于很多事，包括感情也一样。 35、王阳明的”知行合一”到底如何理解?又怎样运用到实际生活中?1答：知道做不到，等于不知道。 36、什么叫见过大世面?1答：能享受最好的，能承受最坏的。 37、科学和迷信的分界点是哪里?1答：我错了。 38、扎克伯格初期是怎么保护 Facebook 的最初创意?为什么 Facebook 上线后没被其他大公司抄走?1答：保护创意的最好方法，就是将其最好地执行。 39、员工辞职最主要的原因是什么?1答：钱少事多离家远，位低权轻责任重。 40、你在生活中得到过的最好的建议是什么?1答：“过度自我关注是万恶之源”、“永远不要为尚未发生的事儿拧巴”、“觉得为时已晚的时候，恰恰是最早的时候”。 41、哪些行为是浪费时间?1答：思而不学+犹豫不决。 42、最能燃起你学习激情的一句话是什么?1答：你不能把这个世界，让给你所鄙视的人。 43、如果好人没好报，我们为什么还要做好人?1答：我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。——哈维尔 44、恋爱半年，女朋友觉得没有了开始时的新鲜感，怎么办?1答：所谓新鲜感，不是和未知的人一起去做同样的事情，而是和已知的人一起去体验未知的人生。 45、为什么大家都要上大学找工作，而不太喜欢开出租车、开小店、开饭馆、摆街边早餐小吃摊等”短平快”项目?1答：“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。”----龙应台 46、情商不高的例子有哪些?1答：对陌生人毕恭毕敬，对亲近的人随意发怒…… 47、如何看待”年轻的时候需要的是朋友而不是人脉”?1答：没有目的之交往，才能感动人。 48、有哪些道理是你读了不信，听不进去，直到你亲身经历方笃信不疑的?1答：不要低估你的能力，不要高估你的毅力。 49、有哪些我们熟知的名言其实还有后半句?1答：“人是生而自由的”，下一句是：“但无往不在枷锁之中。”，再下一句是：“自以为是其他一切主人的人，反而比其他一切更是奴隶。]]></content>
      <categories>
        <category>L78Z</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[极简主义者]]></title>
    <url>%2F1900%2F01%2F03%2FME-%E4%B8%AA%E4%BA%BA%2F%E5%85%A5%E4%B8%96-%E6%9E%81%E7%AE%80%E4%B8%BB%E4%B9%89%E8%80%85%2F</url>
    <content type="text"><![CDATA[收纳整理 | 这个日本大叔变态地扔了98%的家当后，瞬间从屌丝逆袭成人生赢家！ 断舍离不仅仅是一种口号，更是一种态度。无论是时间还是生活都需要整理。 —序说 就在昨天，小编花了一整天的时间在进行一年一度的”断舍离”，完了发现最终要”扔扔扔”的东西只有5%，房间里还是那么拥挤… 而昨晚，在写这篇文章之前又在无意识地”买买买”，心满意足地下完单后，打开了yahoo，打算学一学日本主妇的收纳大法，突然就看到了这样一组照片。▼ 原本以为是某个房产公司的样板房，看完才发现这是日本一位奉行极简主义的单身大叔家…（当时第一反应就是：这不是鬼扯吗？这也太极简了吧…） 但是大叔说，自从过上这种生活后，他从一名穷小编逆袭为了一家出版社的副总编辑… （其实不该给大叔叫大叔，因为大叔今年才37岁，但是叫小哥？大哥？和胡子的定位也不符啊，所以还是叫大叔吧，纠结死我了…） 看到大叔这样说，现在还是穷编辑的我眼前一亮，择日不如撞日，今天就让我好好八一八这位大叔是怎么靠”极简生活”神奇地逆袭为人生大赢家的！ ————逆 袭 分 割 线———— 两年前，35岁的佐佐木典士蜗居在东京的一个小房子里，是一个穷编辑，无存款，工作和生活也没有什么长进，3坪大的房间里堆得到处都是东西，书、零食、衣服、洗浴用品… 一张图足以说明他以前的生活状态▼ 最后女朋友也离他而去…大叔面对不如意，开始觉得自己不幸，一直觉得【得不到自己想要的东西】，嫌弃自己的家不够大，沙发放不下，朋友来了也没地方坐等等等等…每天在背后数落公司，觉得自己怀才不遇… 陷入这种死循环的佐佐木典士开始觉得喘不过气来了，在同伴的劝说下，佐佐木典士拿着刚发下来的工资和同伴来到了克罗地亚，开始一次久违的旅行，但没想到这次的旅行真的改变了佐佐木典士的人生！ 在旅途中，佐佐木典士第一次听到了”Minimalist“（极简主义者/最低要求者），立马产生了浓厚的兴趣，因为这是一种和目前的自己正对立的极端状态… 回日本之后，佐佐木典士开始在网络上搜索Minimalist，于是看到了只拥有15件的”极限民”安得烈和奉行极简主义的乔布斯。 了解了极简主义的佐佐木典士觉得这才是自己想要的生活。他突然想起当初千辛万苦搬到这个找了很久才满意的房子时的喜悦，也想起了当初收到公司录取通知时的雀跃，原来是自己把一直拥有的幸福用欲望埋藏了起来… 于是佐佐木典子开始动手处理包围自己的物品。 扔掉了穿了一次就不再穿又舍不得扔的衣服，衣柜里只剩下了三件一模一样的白衬衫、三件外套以及三条裤子。▼ 佐佐木典士的家产大概就是满屋子的书籍了，一部分忍痛送给了需要的朋友，一部分卖给了旧书店，用最终到手的1000多块钱买了个Kindle。▼ 搬走了多余的家具，卧室里几乎空无一物。▼ 书房只剩下一张小书桌和凳子。▼ 客厅只有一张迷你小餐桌，没有凳子，席地而坐。▼ 卫生间更简约更干净。▼ 厨房里只保留一人份的碗盘和咖啡壶。▼ 而玄关处更是给人一种舒畅的视觉感。▼ 而大叔随身携带的只有四样东西。▼ 大叔一瞬间从”腰缠万贯”变为”一贫如洗”，现在家中的所有物件加起来不超过150件，别以为150件很多，你看就这些。▼ 现在的佐佐木典士一身轻松，瞬间没有了以前那种没来由的顾虑和牵挂，感觉自己正鼓足干劲想放开手去做些什么事… 再来看看大叔在公司的办公桌，干净整洁。▼ 而零零总总的文件和各种资料都做编上了序号，分好类后排列在抽屉里。▼ 当一切简单起来，做事的效率就会越来越高。正是这样的生活，两年时间，佐佐木典士从之前那位不如意的无名小编晋升为了出版社的副总编辑。▼ 因为有付出才会有收获。 过去的时间里，他做好了放弃一些东西的准备，忍痛将自己曾经依赖的那些生活物品全部扫地出门，因为只有放下所有的事情，让生活回归空白，在没有任何事情干扰的情况下，才会知道自己想要的究竟是什么，自己不需要的又是什么。 扔扔扔的过程让他找回了当初买这件衣服时的喜悦心情，找回了租到这间房的满足和对未来美好的憧憬，更理清了自己现在最应该做的事情。 当一切返璞归真，才发现生活简单起来，精神就越集中，就像钱钟书先生的一句话：洗一个澡，看一朵花，吃一顿饭，假使你觉得快活，并非全因为澡洗得干净，花开得好，或者菜合你口味，主要是因为你心上没有挂碍。 2017年，让我们更简单地面对生活吧！]]></content>
      <categories>
        <category>L78Z</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[杂语]]></title>
    <url>%2F1900%2F01%2F02%2FME-%E4%B8%AA%E4%BA%BA%2F%E5%85%A5%E4%B8%96-%E6%9D%82%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[-.-哲言警句自己 斗米恩，升米仇。 世界上根本没有无解的问题，只是还没有找到答案，任何时候请你不要说做不到。 宛如傻逼智障样的自己，请牢记永远不要把两个人之间的话，传给第三个人。 东西越买越好，就跟升级打怪一样，紧张而又舒服，以后的日子里理性消费。 一个人成熟的标志之一，就是明白每天发生在自己身上99%的事情，对于别人而言根本毫无意义。 作为成年人，无论谁回家带孩子，暂停职业进阶之路，都是对家庭巨大的奉献，需要承担巨大的人生风险，这一点，你队友必须明确和认可。 婚姻是一个团队，回家带孩子的哪位，跟在外打开的哪位，只是分工不同，没有谁比谁更累，谁比谁更重要，谁靠谁养着。 育人 每个孩子的生日都是母难日让自己的孩子牢记。 有没有能力都要给还在认真挑选学校（幼儿园，小学，初中）。 给小孩子身上安装监控设备（3-6岁）尽量避免侵犯别人隐私。 7岁之后提供给小孩子分房。 16岁以后让孩子自己赚钱，20岁之后一切不管。 孩子的名字最好起名为单字，（简单大方利于孩子以后的为人处事交朋友）越好记越好。 交友 不要以为你和朋友关系铁，朋友的东西就是你的。 不要以为你和朋友关系铁，就可以让朋友给你埋单。 不要以为你和朋友关系铁，就可以侵犯朋友的私人空间。 不在以为你和朋友关系铁，就可以和朋友天天黏在一起。 不要以为你和朋友关系铁，就可以不注重礼节。 不要以为你和朋友关系铁，就可以随便借钱。 不要以为你和朋友关系铁，就可以让他（她）替你做决定。 不要以为你和朋友关系铁，就可以靠朋友过一辈子。 律己 己所不欲勿施于人，己所欲也慎施于人。 静坐常思己过，闲谈莫论人非。 水深则流缓，语迟则人贵。 勿以善小而不为，勿以恶小而为之。 学而不思则罔，思而不学则殆。 不懂我的人，请闭嘴。 以德报怨，何以报德。那么何以抱怨？以直报怨！ 管住嘴，不把坏脾气发泄到爱自己的人身上。管住嘴，不去跟不同层次的人纠缠辩解。管住嘴，不要跟喜欢自己，自己不喜欢的人搞暧昧。管住嘴，不要总为人师。管住嘴，维护不在场的人，所言不多余所知。管住嘴，话不要说的太满。 子非鱼，安知鱼之乐。 醒世 天地不仁以万物为刍狗，圣人不仁以百姓为刍狗。 圣人之道，无异于百姓日用，凡有异者，皆是异端！率性所行，纯任自然，便谓之道。 抄录 “翩若惊鸿，婉若游龙。荣曜秋菊，华茂春松。”固然是美丽不可方物，“淡柔情于俗内，负雅志于高云”又何尝不是美？ “家有良田，可能要被水淹掉，家有宫殿，可能要被火烧掉，肚子里文化，水淹不掉，火烧不掉，谁都拿不走。” 朋友 (20170808) 女人不狠，何以站稳。（ghj） 每一次跌宕都是崛起的伏笔。 （zx） 种一棵树最好的时间是十年前，其次是现在。（yyk） 机会是给有准备的人的。（gw） 让一个人成长的所有事，都是孤独的。 ​​​（cjz） 心安茅屋稳，性定菜根香，世事静方现，人情淡始长。 （yx） 水深则流缓，语迟则人贵。（wwy） 知世故而不世故，才是最善良的成熟。（zyy） 世上无难事，只要肯放弃。（grz） 言必行，行必果。路在脚下，事在人为。（lzw） 只有苦练72变才能应对81难。（js） 宁可错过，不可做错。（小小） 以不变应万变。（小小） 现在应该为以前吹过的牛逼奋斗了！（ysp） 不合适的人请下车。（zy） 走自己的路，让别人去说吧。（bg） 以我之姓，冠你之名。（wyl） 古诗集李延年歌两汉：李延年北方有佳人，绝世而独立。一顾倾人城，再顾倾人国。宁不知倾城与倾国？佳人难再得。 “樱花落下的速度是每秒五厘米， 我该用怎么样的速度，才能与你相遇。”——秒速五厘米 “雨滴降落的速度是每秒十米，我该用怎么样的速度，才能将你挽留。”——言叶之庭 “陨石坠落的速度是每秒十千米，我该用怎么样的速度，才能将你拯救。”——你的名字 杂言杂语2017-07-31 最近几天有一些私事处理换了新的手持设备，导致断更有点严重，后天开始发力。 2017-08-01 今天出了上个月账单感觉很。。。明天加油 2017-08-02 不知道太累了吧，最近，今天睡了好几个小时。 2017-08-05 最近不知道怎么了老是犯困没精神。 2017-08-06 也太嗜睡了，睡了16个小时。明天开始跑步 2017-08-13 今天整理下关于video的知识，忽然感觉两年的前端生涯学会的还是不够多，整理整理就没了。 2017-08-14 周一我来了。 大概最难过的事情就是听见老奶奶说在写鞋子，我说不是有洗衣机？奶奶说洗衣机洗不了泥泞鞋子，好想马上回去哦。 2017-09-17 最近网站一直在备案就没有上传什么东西，最近写了一份实名认证，银行卡信息验证的功能过几天会上传上。 2017-09-27 最近事比较忙，网站也一直在备案，离职的日子快了，有点怅怅的感觉。今天备案总算通过审核了，我的评论马上就可以上架了。 2018-01-08 最近心情不好，看了一部电影《素媛》调节自己。很感动的电影。 2018-01-17 最近在写项目文档，准备新的一轮。 2018-03-18 最穷不过讨饭，不死总会出头。 2018-04-16 要多丧有多丧。 2018-10-08 爱情可以不分贵贱，但婚姻要门当户对。 2018-12-20 打什么疫苗，反正自己心疼自己。 2019-06-06 疯狂加班中 2020-03-11 新入职了，最近加班赶进度。 2020-03-12 加班 2020-04-05 换新房子了 2020-04-05 今天吃了灰哥的土豆丝。还蹭了胖子的网。]]></content>
      <categories>
        <category>L78Z</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[看过的电影、动画、电视剧]]></title>
    <url>%2F1900%2F01%2F01%2FME-%E4%B8%AA%E4%BA%BA%2F%E5%BD%B1%E9%9F%B3-%E7%9C%8B%E8%BF%87%E7%9A%84%E7%94%B5%E5%BD%B1%E3%80%81%E5%8A%A8%E7%94%BB%E3%80%81%E7%94%B5%E8%A7%86%E5%89%A7%2F</url>
    <content type="text"><![CDATA[从故事中找寻存在的价值和意义。 看过的电影、动画、电视剧电影2020年大赢家 周星驰，成龙系列都喜欢就不一一列举了，列举部分自己喜欢的在下面。 一代巨星桑杰君 念念手纪 花牌情缘 寻梦环游记 勇往直前 阿甘正传 面对巨人 当幸福来敲门 这个杀手不太冷 一条狗的使命 忠犬八公物语 我是山姆 大鱼 萨利机长 雪狼犬 紧急迫降 火星救援 拆弹部队 世界末日 三傻大闹宝莱坞 我的个神啊 摔跤吧！爸爸 地球上的星星 神秘巨星 神战权利之战 极速救援 驴得水 战狼二 泰坦尼克号 斯巴达300勇士 湄公河行动 战狼 港囧 分手大师 夏洛特烦恼 同桌的妳 28岁未成年 致我们终将逝去的青春 左耳 那些年，我们一起追过的女孩 匆匆那年 功夫瑜伽 满城尽带黄金甲 让子弹飞 中国个人明星周星驰 大话西游之月光宝盒 大话西游之大圣娶亲 唐伯虎点秋香 赌圣 长江七号 功夫 无敌幸运星 赌侠 赌侠2：上海滩赌圣 喜剧之王 百变星君 逃学威龙 逃学威龙2 逃学威龙3之龙过鸡年 鹿鼎记2：神龙教 大内密探零零发 算死草 破坏之王 整蛊专家 济公 千王之王2000 九品芝麻官 国产凌凌漆 武状元苏乞儿 美人鱼 咖喱辣椒 少林足球 望夫成龙 回魂夜 成龙 新警察故事 宝贝计划 神话 我是谁 奇谋妙计五福星 双龙会 飞鹰计划 警察故事续集 醉拳 尖峰时刻 电视动画片合集中国 爱情公寓一二三四 家有儿女 喜羊羊与灰太狼 虹猫蓝兔 神兵小将 蓝猫淘气三千问 大耳朵图图 美国 猫和老鼠 海绵宝宝 狮子王 日本 神侦探柯南 四驱兄弟 山林小猎人]]></content>
      <categories>
        <category>L78Z</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Atom编辑器]]></title>
    <url>%2F1899%2F11%2F30%2F%E6%B2%A1%E7%94%A8%E7%9A%84%2F%E5%B7%A5%E5%85%B7-Atom%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[为什么选择使用Atom？ Atom是GitHub推出的一款编辑器, 被称为21世纪的黑客编辑器.作为一个现代的代码编辑器，Atom 有着各种流行编辑器都有的特性，功能上非常丰富，支持各种编程语言的代码高亮(HTML / CSS / Javascript / PHP / Python / C / C++ / Objective C / Java / JSON / Perl / CoffeeScript / Go / Sass / YAML / Markdown 等等)、 与大多数其他编辑器相比，Atom的语言支持已经算是覆盖非常全面了。另外，它的代码补全功能（也叫Snippets） 也非常好用，你只需输入几个字符即可展开成各种常用代码，可以极大提高编程效率。 chinese 汉化 pigments 显示颜色 color-picker 快捷颜色插件 vim-mode emmet 安装打开官方主页 网页会自动判断你的操作系统, 给出其对应的下载按钮 基本使用命令面板Atom的很多功能学习和参考了其他优秀的编辑器, 命令面板就是其一. 当你第一次看到它时, 还以为在用Sublime呢 命令面板是Atom中最常用的功能之一, 当你在编辑器中使用快捷键Ctrl+Shift+P时, 就会看到它 在控制面板中可以输入Atom中和插件中定义的所有命令, 并且支持模糊搜索 比如说当你输入cboo时, 所有包含有这4个字符的命令就都列出来了 在列出的命令后还显示了此命令对应的快捷键(如果有的话) 设置窗口自带可视化的设置界面是Atom使用很方便的原因之一, 而不像传统的编辑器那样需要手动修改配置文件. 你可以使用下面三种方法来打开设置窗口 主菜单Edit-&gt;Preferences 在命令面板中输入命令Settings View:Open. 因为命令窗口支持模糊查询, 因此只需要输入svo, 就可以了 使用快捷键Ctrl+, 在设置窗口中可以设置和管理各种编辑器行为, 键盘快捷键, 插件, 主题等内容 设置窗口界面主题和代码高亮Atom自带了4种窗口主题和8种代码高亮方式 可以通过设置窗口中的Themes页面来配置和修改 安装插件通过设置窗口Settings界面的Install选项中，可以搜索插件或者主题进行下载安装 常用的一些插件1、simplified-chinese-menuAtom的简体中文语言包，完整汉化，兼容所有已发布的版本Atom。 2、linter-js-standard用来使javascript代码格式化。 3、emmet这款插件是用来支持zend-coding，Emmet的前身是大名鼎鼎的Zen coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度 4、autoclose-htmlhtml标签自动比较。 5、atom-ternjs该插件能对一个对象中拥有的对外提供的属性和方法都能通过suggest的形式提示出来，能对一个对象对外提供的接口有一个选择过程，可以理解为js代码自动提示。 6、atom-bootstrap3bootstrap3代码提示插件。 7、autocomplete-paths文件路径自动提示。 8、jquery-snippetsjquery代码提示，安装完之后要重新启动Atom。 9、autoprefixercss代码前缀自动补全。 10、color-picker取色器。 右键单击并选择Color Picker，或者点击CMD-SHIFT-C/ CTRL-ALT-C打开它。目前读HEX，HEXa，RGB，RGBa，HSL，HSLa，HSV，HSVa，VEC3和VEC4颜色-并能在格式之间的转换。 它还检查Sass和LESS颜色变量。只需Color Picker用光标打开一个变量，它就会查找你的定义。从那里，您可以单击定义并直接转到定义的位置。 11、activate-power-mode编写代码特效 12、atom-ternjsJS代码智能提示。 新增功能：增加了对ES5，6，ES7，Node.js，jQuery的支持，和更多的可扩展插件。 13、snippets按tab键自动填充代码。 14、atom-beautify代码美化 打开命令选项板，键入Beautify并运行Beautify Editor。 右键或者快捷键 ‘ctrl-alt-b’：’atom-beautify：美化编辑器’ (https://atom.io/packages/atom-beautify) 2、原生Markdown书写和预览Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML标记语言来说，Markdown可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 Atom原生支持Markdown的书写和预览，这相较于Sublime的需要安装第三方Markdown插件使用起来还要优秀，由于时Github自家打造，Markdown语法当然也是与github语法完全同步。 使用快捷键 Ctrl + Shift + M 则可打开Markdown的预览界面。 Atom的markdown Preview官方效果图如下： 3、原生Git支持作为一个程序员，Git无疑是一个版本控制神器。如果你编辑了你从GitHub上Pull代码，那么在编辑器的右下角或者菜单树中能直观的看到自己编辑代码的状态，当然还有其他很多功能。这个大家可以自行去摸索。 三，常用快捷键Atom设置选项 keybindings 中列举了相当长的一份关于快捷键的绑定列表，你也可以自定义快捷键的配置文件，有相同的快捷键则会覆盖掉原有的，使用你自己设定的。下面是一些常用的快捷键： Crtl+Shift+M 开启Markdown实时预览 Command+Shift+P 打开命令窗口，可以运行各种菜单功能 Command + T 快速多文件切换 Command + F 文件内查找和替换 Command + Shift + F 多文件查找和替换 Command + [ 对选中内容向左缩进 Command + ] 对选中内容向右缩进 Command + \ 显示或隐藏目录树 Crtl + m 相应括号之间，html tag之间等跳转 Crtl + Alt + B 格式化代码（需要安装atom-beautify） Crtl + ` 调起CLI命令行界面（需要安装terminal-panel） 四，常用的一些插件Atom的常用插件基本上都在 Atom Packages 首页中能找到，选择热门的、下载量较多的适合自己需要的基本上都是正确的选择，下面列举一写比较好用的插件： 1、minimapminimap是一个预览全部代码的一个插件，同时能方便的移动到指定的文件位置。 2、atom-beautifyatom-beautify是一个格式化代码的插件，支持HTML, CSS, JavaScript, PHP, Python, Ruby, Java, C, C++, C#, Objective-C,CoffeeScript, TypeScript, SQL等多种语言。 安装后可以使用 Crtl + Alt + B 快捷键进行格式化。 也可以点击菜单”Packages”-&gt;”Atom Beautify”-&gt;”Beautify”进行格式化。 3、emmetemmet是HTML,CSS快速编写的神器,具体的使用可以参看emmet官网。 4、autocomplete-* 系列autocomplete-*系列包含各个语言的代码自动补全功能，你需要什么语言的就可以下载该语言相关的插件即可。 autocomplete-paths：填写路径的时候有Sug提示 autocomplete-php：php代码提示补全 autocomplete-java：java代码提示补全 5、pigmentspigments是项目文件中，样式显色显示的的插件。在Atom中的下载量可是相当的高。对于前端人员来讲还是很重要的一个插件。 6、terminal-panel用于执行命令并显示输出。打开终端面板快捷键：Ctrl + ` 7、docblockr可以帮助我们方便快速地写注释。 8、javascript-snippets让我们书写js时使用各种缩写，自动补全代码。 9、file-icons让文件前面有彩色图片，使文件类型看得更加清除舒服。(如果使用着 seti-ui 主题，则体现不了效果哦) 五、常用主题Atom 的主题是分为UI主题和语法主题，默认情况下软件已经提供了好几套主题（有暗色调、也有亮色调）供我们使用。 在菜单”Atom”-&gt;”Preferences”-&gt;”Themes” 页面中可以分别切换 UI Theme 和 Syntax Theme 在菜单”Atom”-&gt;”Preferences”-&gt;”Install” 页面中可以搜索安装各种主题。 除了默认自带的主题，下面推荐几个优秀的Theme，大家可以自行安装。 #1，seti-ui + seti-syntax 每个文件前的icons是最大亮点 2，atom-material-ui + atom-material-syntax颜色正 （1）暗色调 （2）亮色调 原文出自：www.hangge.com 转载请保留原文链接：http://www.hangge.com/blog/cache/detail_1149.html 快速打开命令行ctrl+shift+p http://blog.csdn.net/hunyxv/article/details/52549153 代码兼容性https://atom.io/packages/autoprefixer 自动保存 OS X: cmd-,, Windows &amp; Linux: Ctrl-, https://atom.io/packages/autosave version control with git and github tracks changes to your code as you work.Branch,commit,push,and pull widthout leaving the comfort of you editor. collaborate with other developers on GitHub. 版本控制与git和github 跟踪您的代码的变化，在您工作时。分配，提交，推送和拉扯，没有离开您的编辑器的舒适。 与GitHub上的其他开发人员合作。 当打开一个或多个目录时,你可以: 通过Ctrl+T或Ctrl+P来搜索目录中的文件 通过Ctrl+B来搜索一个当前打开的文件 通过Ctrl+Shift+B来搜索一个新建的或更改过的文件 atom 扩展插件报错解决办法：https://github.com/atom/apm/issues/32212345678910111213141516171819202122Updating to “file-icons@2.1.17” failed.Hide output…gyp info it worked if it ends with okgyp info using node-gyp@3.4.0gyp info using node@6.9.5 | win32 | x64gyp http GET https://atom.io/download/electron/v1.6.16/iojs-v1.6.16.tar.gzgyp WARN install got an error, rolling back installgyp ERR! install error gyp ERR! stack Error: connect ETIMEDOUT 54.231.120.19:443gyp ERR! stack at Object.exports._errnoException (util.js:1022:11)gyp ERR! stack at exports._exceptionWithHostPort (util.js:1045:20)gyp ERR! stack at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1087:14)gyp ERR! System Windows_NT 10.0.16299gyp ERR! command "C:\\Users\\SUI\\AppData\\Local\\atom\\app-1.24.0\\resources\\app\\apm\\bin\\node.exe" "C:\\Users\\SUI\\AppData\\Local\\atom\\app-1.24.0\\resources\\app\\apm\\node_modules\\node-gyp\\bin\\node-gyp.js" "install" "--runtime=electron" "--target=1.6.16" "--dist-url=https://atom.io/download/electron" "--arch=x64" "--ensure"gyp ERR! cwd C:\Users\SUI\.atomgyp ERR! node -v v6.9.5gyp ERR! node-gyp -v v3.4.0gyp ERR! not ok Compiler tools not foundPackages that depend on modules that contain C/C++ code will fail to install.Read here for instructions on installing Python and Visual Studio.Run apm install --check after installing to test compiling a native module.]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text使用技巧]]></title>
    <url>%2F1899%2F11%2F30%2F%E6%B2%A1%E7%94%A8%E7%9A%84%2F%E5%B7%A5%E5%85%B7-sublime%2F</url>
    <content type="text"><![CDATA[Sublime插件：Markdown篇 Sublime Text 如何安装插件详见：https://packagecontrol.io/installation MarkDown Editing：支持Markdown语法高亮；支持Github Favored Markdown语法；自带3个主题。 MarkDown Editing 界面 主题选择 注：如果你安装完之后，遇到了如下的错误，那么你安装的时候可能开着一个Markdown文件，所以卸载完之后在不打开Markdown的情况下再次安装就可以解决了。 Markdown.tmLanguage错误 这个自己用到了哦 MarkdownPreview：按CTRL + B生成网页HTML；在最前面添加[TOC]自动生成目录； Markdown 生成HTML预览 Markdown Extended + Extends Monokai：不错的Markdown主题，支持对多种语言的高亮 C语言语法高亮 OmniMarkupPreviwer：实时在浏览器中预，而MarkdownPreview是需要手动生成的和F5的。览如果双屏的话，应该具有不错的体验。快捷键如下： Ctrl+Alt+O: Preview Markup in Browser. Ctrl+Alt+X: Export Markup as HTML. Ctrl+Alt+C: Copy Markup as HTML. 实时在浏览器中显示编辑的文档 TableEditor：Markdown中的表格书写体验真心不咋样，所有有人为这个开发了一个插件，具有较好的自适应性，会自动对齐，强迫症患者喜欢。 首先需要用ctrl + shift + p打开这个功能（Table Editor: Enable for current syntax or Table Editor: Enable for current view or “Table Editor: Set table syntax … for current view”），然后就可以狂用tab来自动完成了~~~ 用tab来自动完成表格间的切换和下一行表格的生成 Markdown TOC：编辑MD文件的时候可以查看自动生成，并且可以控制生产目录的层次，不过不会自动跳转。编辑的时候可以看看，如果需要生成的HTML具有超链接跳转的功能，还是用MarkdownPreview吧。 修改目录深度实时在MD文件中预览，不过这个用CTRL+R就可以产看，个人觉得不太实用 SmartMarkdown：貌似是为Emacs用户打造的。 《转》12个Sublime Text使用技巧 文为您提供Sublime Text编辑器的12个技巧和诀窍，深入挖掘这个看似简洁的代码编辑器，背后所隐藏的实现各种高级功能的无限可能。 1) 选择 以下是一些Sublime Text选择文本的快捷键： Command + D 选中一个单词 Command + L 选中一行 Command + A 全选 Ctrl + Command + M 选中括号内所有内容 (编写CSS或JS时非常实用)Sublime Text还支持一次选中多行的操作，它可以显著提高您的工作效率。有几种方法来执行此功能：Command 按住Command键再点击想选中的行Command + Ctrl + G (选中部分文本时) 按此键选中所有相同文本Command + D (选中部分文本时) 直接选中下一次出现的该文本 2) CSS排序 CSS属性的顺序一般不重要，因为无论何种顺序浏览器都能正确渲染。但排序所有的属性还是有助于代码的整洁。在Sublime Text中，选中CSS属性后按F5就可以按字母顺序排序。 也可以使用 CSSComb 等第三方插件，更详细的控制排序的方法。 3) 命令面板（Command Palette） ▼ 重命名文件 ▼ 设置文件为HTML语法 ▼ 插入代码片段 4) 切换标签页与工程 在同时打开多个标签页时，可以用以下的热键切换： Command + T 列出所有的标签页 Command + Shift + ] 下一标签页Command + Shift + [ 上一标签页 Command + Ctrl + P 切换侧边栏显示的工程 5) 跨文件编辑 同一个编辑操作可以在多个文件中同时重复。举个例子，多个文件中有同一段代码时，可用以下的步骤快速编辑： 1.按Command + Shift + F在Find框中输入待查找的代码。可按Command + E快速使用选择中的代码段。 2.在Where框中指定需要查找的文件范围，或填写表示查找目前打开的文件。 3.在Replace框中输入要替换成的代码，按Replace按钮批量替换。 6) 文件爬虫 按Command + R可以列出文档中所有的CSS选择器。可以选择并立刻跳转查看。这个操作比使用一般的”查找”功能快得多。 7) 拼写检查 如果你经常使用Sublime Text从事英文创作，那么启用拼写检查就非常有用处了。选择Preferences &gt; Settings – User菜单，添加以下代码： “spell_check”: true, 8) 增强侧边栏 SideBarEnhancements插件有效地改进了Sublime Text的侧边栏。安装插件后在侧边栏上点击右键，可以找到一下新功能：在资源管理器中打开、新建文件、新建文件夹、以…打开、在浏览器中打开。 9) 更换主题 Sublime Text的外观主题可以更换。Soda Theme就是一个不错的主题，可以在包管理器中安装。 如果要安装的主题并不在在线软件仓库中，也可以手动安装： 1.下载并解压缩主题包 2.点击菜单 Preferences &gt; Browse Packages… 3.把主题文件夹复制到Packages文件夹中. 4.点击菜单 Preferences &gt; Settings – Users 并加入以下代码：”theme”: “Soda Light.sublime-theme” 10) 更换Sublime Text程序图标 不仅主题可以更换，图标也可以。在Dribbble上有大量重新设计的Sublime Text精美图标。更换方法： 下载一个图标，有.icns格式的最好。如果没有，用iConvert转换之。 终端执行：open /Applications/Sublime\ Text.app/Contents/Resources/ 替换Sublime Text 3.icns或Sublime Text 2.icns文件。 11) 同步选项 如果在多台计算机上工作，同步选项设置应该是一个好主意。我们借用Dropbox完成这一任务。 首先在终端中运行以下命令上传设置文件： mkdir $HOME/Dropbox/sublime-text-3/ mv “$HOME/Library/Application Support/Sublime Text 3/Packages” “$HOME/Dropbox/sublime-text-3/“ mv “$HOME/Library/Application Support/Sublime Text 3/Installed Packages” “$HOME/Dropbox/sublime-text-3/“ 然后在所有需要同步的计算机上运行以下命令下载设置： DSTPATH=”$HOME/Library/Application Support/Sublime Text 3”DROPBOX_PATH=”$HOME/Dropbox/sublime-text-3” rm -rf “$DSTPATH/Installed Packages” rm -rf “$DSTPATH/Packages” mkdir -p “$DSTPATH” ln -s “$DROPBOX_PATH/Packages” “$DSTPATH/Packages” ln -s “$DROPBOX_PATH/Installed Packages” “$DSTPATH/Installed Packages” 12) 可点击的URL 使用小插件ClickableURLs可以让文件中的URL能够点击。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webstrom编辑器]]></title>
    <url>%2F1899%2F11%2F30%2F%E6%B2%A1%E7%94%A8%E7%9A%84%2F%E5%B7%A5%E5%85%B7-Webstrom%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1、登录官网，认准https://www.jetbrains.com/webstorm/，其他的百度出来的什么鬼下载地址可能存在捆绑，一律不鸟； 2、点击下载，选择适合的系统版本（window、linux、mac）； 3、双击运行（基本就是无脑next），完毕。 webstorm激活 webstorm更新很快，各版本的破解需要时间，同时只适合对应的版本，这里下载的webstorm是2017.1.1，采用JetBrains 授权服务器作为激活方式，详情参考此网址http://idea.imsxm.com/，激活时选择License server,填入http://idea.imsxm.com/，点击Active则激活完成（在线激活有一个过期时间，这个时间一过就必须再次联网授权服务器请求激活）。 webstorm汉化汉化找的也是webstorm的2017.1.1版，网址为数码资源网：http://www.smzy.com/smzy/down318439.html#a2，打开网址拉到最下才是正确的下载地址，直接讲汉化包里面的resources_cn.jar复制到.\Webstorm\lib目录则汉化完成（大部分汉化，但不影响使用）。 1、在本站下载安装Webstorm 2017汉化包. 2、将.\Webstorm 2017.1\lib目录下的resources_en.jar文件复制出来，并更名为resources_cn.jar。 3、双击打开resources_cn.jar(注意是打开而不是解压出来)，将下载的汉化包zh_CN目录下的所有文件拖到刚才打开的resources_cn.jar文件内的messages目录中，并保存。 4、将resources_cn.jar文件复制回.\Webstorm\lib目录。或是直接讲汉化包里面的resources_cn.jar复制到.\Webstorm\lib目录即可. 5、汉化完毕，重新打开Webstorm就可以显示中文。 Webstorm汉化补丁注意事项： 如果打开后显示乱码，请先删除resources_cn.jar，然后打开Webstorm，在菜单上依次选择 File -&gt; Settings -&gt; Appearance&amp;Behavior -&gt; Appearance -&gt; 选中Override default fonts by(not recommended) Name: Microsoft YaHei (选择任意中文字体) 然后将resources_cn.jar 复制到 .\lib 目录，重新打开Webstorm 就能正常显示中文了 网站HTML模版突然变成写一行代码就空一行 最近使用ftp上传 老出现诡异的代码 https://zhidao.baidu.com/question/362896057092145932.html 这个以前遇到过，跟上传到服务器的时候选择的 上传模式有关系。上传ftp的时候可以在工具上选择传输模式设置为二进制(图象)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>WebStrom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime快速生成html标签(emmet语法)]]></title>
    <url>%2F1899%2F11%2F30%2F%E6%B2%A1%E7%94%A8%E7%9A%84%2F%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90html%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[sublime快速生成html标签、Vscode快速生成html标签、Atom快速生成标签、 安装完emmet插件的编辑器都可以用不光是sublime,Vscode、Atom、···都可以用。 html1所有`输入`输完之后都需要按下`tab`触发。 1.创建标准页面创建标准xhtml页面。 1输入： html:xxs 创建标准html5页面 1输入：! / html:5 2.创建html标记输入任何标记、双标记按下tab出现正常标签对 1输入：style 3.创建html标签含Id、多个类名的标记创建格式和css选择器命名方式一致 1例如：id #id class .class 4.创建html示例 创建Id名为box的div标记 1输入： div#box 创建类名为box的div标记 1输入： div.box 同时创建两个div标记 Id为box 类名为box2 1输入：div#box+div.box2 创建两个div标记 Id为box 包含 类名为box 1输入：div#box&gt;div.box 创建Id为box的标记包含两个类名为box2的标记 1输入：div#box&gt;div.box2 同时创建2个div并且给它包含2个类名 aa bb，它里面有两个类名为box的div。 1输入：div.aa.bb*2&gt;div.box2*2 同时创建2个div并且给它2个类名 aa bb，它里面包含box2、box3两个div标记。1输入：div.aa.bb*2&gt;div.box2+div.box3 创建5个div类名为box、内容为1-51输入：div.box&#123;$&#125;5 创建5个div类名为box1-51输入：div.box$*5 创建1个div类名为box，内容为’Hellow world!’1输入：div.box&#123;Hellow world!&#125;]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
